From fec6c6df759e2900c6343269645f2a30cbc6ceb5 Mon Sep 17 00:00:00 2001
From: jacob431 <jacob_wu@asus.com>
Date: Fri, 11 Dec 2020 18:14:48 +0800
Subject: [PATCH 2/2] Update kernel patch for Intel LTS kernel 5.4

---
 ...d-support-to-map-GPIO-resources-to-ranges.patch |  136 --
 ...d-support-to-map-GPIO-resources-to-ranges.patch |  136 ++
 ...-override-on-LPSS-UART-with-Auto-Flow-Con.patch |   54 -
 ...-override-on-LPSS-UART-with-Auto-Flow-Con.patch |   54 +
 ...052-allow-driver-to-be-matched-using-ACPI.patch |   29 -
 ...allow-multiple-pin-controllers-for-a-GPIO.patch |  150 +-
 ...se-regmap_writable-function-to-check-if-a.patch |   30 +-
 ...052-allow-device-to-be-matched-using-acpi.patch |   71 -
 ...05-mfd-Add-support-for-UP-board-CPLD-FPGA.patch | 1514 ++++++++++++++++++++
 ...06-mfd-Add-support-for-UP-board-CPLD-FPGA.patch | 1514 --------------------
 ...l-Bring-in-legacy-fpga-and-pinctrl-driver.patch | 1312 +++++++++++++++++
 ...node_add_pin_mapping-added-to-header-file.patch |   43 +
 ...l-Bring-in-legacy-fpga-and-pinctrl-driver.patch | 1309 -----------------
 ...node_add_pin_mapping-added-to-header-file.patch |   43 -
 ...6-upboard-fix-gpio-pinctrl-API-references.patch |   49 +
 ...pboard-added-support-for-UP-core-CREX-HAT.patch |   12 +-
 .../0010-upboard-Add-support-for-UP-CRST02.patch   |   10 +-
 ...oard-add-regmap-patches-for-CREX-and-CRST.patch |   17 +-
 ...oard-add-separate-regmap-patches-for-CREX.patch |   10 +-
 ...-number-of-GPIOs-for-CREX-and-CRST02-boar.patch |    8 +-
 ...ignware-platdrv-Cleanup-setting-of-the-ad.patch |   78 -
 ...-upboard-fpga-Enable-fpga-on-UP3-platform.patch |   81 ++
 ...ignware-platdrv-Always-use-a-dynamic-adap.patch |   80 --
 ...pboard-Dont-initialise-UART1-RTS-as-input.patch |   27 +
 ...e-translate-gpio-to-pin-before-set-config.patch |   54 +
 .../0016-upxtreme-Add-support-for-UP-Xtreme.patch  |   83 --
 ...pboard-Dont-initialise-UART1-RTS-as-input.patch |   27 -
 ..._dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch |   56 +
 ...-core-translate-gpio-to-pin-before-config.patch |   74 -
 ...-up-fpga-dmi-Update-DMI-match-date-string.patch |   40 +
 ...019-pinctrl-fpga-up-Update-DMI-data-match.patch |   44 +
 ..._dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch |   55 -
 ...new-Baytrail-Cherrytrail-PCM512x-machine-.patch |  275 ++++
 ...6-upboard-fix-gpio-pinctrl-API-references.patch |   49 -
 ...-bytcht_pcm512x-use-modern-dai_link-style.patch |  122 ++
 ...pinctrl-drop-regmap-patches-for-UP-Xtreme.patch |   47 -
 ...are-platdrv-Add-module-parameter-to-overr.patch |   46 -
 ...-core-translate-gpio-to-pin-before-config.patch |   83 ++
 ...are-platdrv-Use-ACPI-method-FREQ-to-get-i.patch |   50 -
 ...pinctrl-drop-regmap-patches-for-UP-Xtreme.patch |   47 +
 ...Set-dir-and-value-when-requesting-cs-gpio.patch |   32 -
 ...change-SoC-gpio-references-to-use-h-w-pin.patch |  122 ++
 ...6-upboard-Add-gpio-chip-select-for-UP-Boa.patch |   81 --
 ...Set-dir-and-value-when-requesting-cs-gpio.patch |   32 +
 ...6-upboard-Add-gpio-chip-select-for-UP-Boa.patch |   81 ++
 ...change-SoC-gpio-references-to-use-h-w-pin.patch |  122 --
 .../0027-up-pinctrl-fix-null-pointer-issue.patch   |   57 +
 ...ore-no-need-to-check-mux-usage-on-upboard.patch |   70 +
 ...29-upboard-fpga-support-upn-apl01-project.patch |   33 +
 ...-NULL-pointer-after-modifying-up_spi_cs_g.patch |   29 +
 .../linux/files/up-board-user-config.cfg           |    1 -
 recipes-kernel/linux/files/up-board.cfg            |    1 -
 recipes-kernel/linux/linux-intel_4.19.bbappend     |   39 -
 recipes-kernel/linux/linux-intel_5.4.bbappend      |   43 +
 54 files changed, 4487 insertions(+), 4175 deletions(-)
 delete mode 100644 recipes-kernel/linux/files/0000-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch
 create mode 100755 recipes-kernel/linux/files/0001-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch
 delete mode 100644 recipes-kernel/linux/files/0001-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch
 create mode 100755 recipes-kernel/linux/files/0002-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch
 delete mode 100644 recipes-kernel/linux/files/0002-iio-adc128s052-allow-driver-to-be-matched-using-ACPI.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch
 delete mode 100644 recipes-kernel/linux/files/0005-iio-adc128s052-allow-device-to-be-matched-using-acpi.patch
 create mode 100755 recipes-kernel/linux/files/0005-mfd-Add-support-for-UP-board-CPLD-FPGA.patch
 delete mode 100644 recipes-kernel/linux/files/0006-mfd-Add-support-for-UP-board-CPLD-FPGA.patch
 create mode 100755 recipes-kernel/linux/files/0006-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch
 create mode 100755 recipes-kernel/linux/files/0007-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch
 delete mode 100644 recipes-kernel/linux/files/0007-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch
 delete mode 100644 recipes-kernel/linux/files/0008-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch
 create mode 100755 recipes-kernel/linux/files/0008-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0009-upboard-added-support-for-UP-core-CREX-HAT.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0010-upboard-Add-support-for-UP-CRST02.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch
 delete mode 100644 recipes-kernel/linux/files/0014-i2c-i2c-designware-platdrv-Cleanup-setting-of-the-ad.patch
 create mode 100755 recipes-kernel/linux/files/0014-upboard-fpga-Enable-fpga-on-UP3-platform.patch
 delete mode 100644 recipes-kernel/linux/files/0015-i2c-i2c-designware-platdrv-Always-use-a-dynamic-adap.patch
 create mode 100755 recipes-kernel/linux/files/0015-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch
 create mode 100755 recipes-kernel/linux/files/0016-pinctrl-core-translate-gpio-to-pin-before-set-config.patch
 delete mode 100644 recipes-kernel/linux/files/0016-upxtreme-Add-support-for-UP-Xtreme.patch
 delete mode 100644 recipes-kernel/linux/files/0017-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch
 create mode 100755 recipes-kernel/linux/files/0017-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch
 delete mode 100644 recipes-kernel/linux/files/0018-pinctrl-core-translate-gpio-to-pin-before-config.patch
 create mode 100755 recipes-kernel/linux/files/0018-up-fpga-dmi-Update-DMI-match-date-string.patch
 create mode 100755 recipes-kernel/linux/files/0019-pinctrl-fpga-up-Update-DMI-data-match.patch
 delete mode 100644 recipes-kernel/linux/files/0019-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch
 create mode 100755 recipes-kernel/linux/files/0020-ASoC-Intel-new-Baytrail-Cherrytrail-PCM512x-machine-.patch
 delete mode 100644 recipes-kernel/linux/files/0020-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch
 create mode 100755 recipes-kernel/linux/files/0021-ASoC-Intel-bytcht_pcm512x-use-modern-dai_link-style.patch
 delete mode 100644 recipes-kernel/linux/files/0021-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch
 delete mode 100644 recipes-kernel/linux/files/0022-i2c-designware-platdrv-Add-module-parameter-to-overr.patch
 create mode 100755 recipes-kernel/linux/files/0022-pinctrl-core-translate-gpio-to-pin-before-config.patch
 delete mode 100644 recipes-kernel/linux/files/0023-i2c-designware-platdrv-Use-ACPI-method-FREQ-to-get-i.patch
 create mode 100755 recipes-kernel/linux/files/0023-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch
 delete mode 100644 recipes-kernel/linux/files/0024-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch
 create mode 100755 recipes-kernel/linux/files/0024-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch
 delete mode 100644 recipes-kernel/linux/files/0025-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch
 create mode 100755 recipes-kernel/linux/files/0025-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch
 create mode 100755 recipes-kernel/linux/files/0026-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch
 delete mode 100644 recipes-kernel/linux/files/0026-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch
 create mode 100755 recipes-kernel/linux/files/0027-up-pinctrl-fix-null-pointer-issue.patch
 create mode 100755 recipes-kernel/linux/files/0028-pinctrl-core-no-need-to-check-mux-usage-on-upboard.patch
 create mode 100755 recipes-kernel/linux/files/0029-upboard-fpga-support-upn-apl01-project.patch
 create mode 100755 recipes-kernel/linux/files/0030-upboard-fix-NULL-pointer-after-modifying-up_spi_cs_g.patch
 mode change 100644 => 100755 recipes-kernel/linux/files/up-board-user-config.cfg
 mode change 100644 => 100755 recipes-kernel/linux/files/up-board.cfg
 delete mode 100644 recipes-kernel/linux/linux-intel_4.19.bbappend
 create mode 100755 recipes-kernel/linux/linux-intel_5.4.bbappend

diff --git a/recipes-kernel/linux/files/0000-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch b/recipes-kernel/linux/files/0000-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch
deleted file mode 100644
index ae2b02f..0000000
--- a/recipes-kernel/linux/files/0000-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch
+++ /dev/null
@@ -1,136 +0,0 @@
-From 4c0f50aaa56077957d627a79277eb0d75caca30a Mon Sep 17 00:00:00 2001
-From: Carlos Calderon <carlos.calderon@emutex.com>
-Date: Wed, 20 Feb 2019 16:49:37 +0000
-Subject: [PATCH] ACPI: Add support to map GPIO resources to ranges
-
-Add a function to gpiolib to facilitate registering a pin controller for
-a range of GPIO pins, but using ACPI resource references and without
-claiming the GPIO resource.
----
- drivers/gpio/gpiolib-acpi.c | 88 ++++++++++++++++++++++++++++++++++++---------
- 1 file changed, 71 insertions(+), 17 deletions(-)
-
-diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
-index 57d157e..9ff45a3 100644
---- a/drivers/gpio/gpiolib-acpi.c
-+++ b/drivers/gpio/gpiolib-acpi.c
-@@ -1213,6 +1213,32 @@ static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
- 	return 1;
- }
- 
-+static int acpi_gpio_count_from_property(struct acpi_device *adev,
-+					 const char *propname)
-+{
-+	const struct acpi_gpio_mapping *gm;
-+	const union acpi_object *obj;
-+	int count = -ENOENT;
-+	int ret;
-+
-+	ret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
-+				    &obj);
-+	if (ret == 0) {
-+		if (obj->type == ACPI_TYPE_LOCAL_REFERENCE)
-+			count = 1;
-+		else if (obj->type == ACPI_TYPE_PACKAGE)
-+			count = acpi_gpio_package_count(obj);
-+	} else if (adev->driver_gpios) {
-+		for (gm = adev->driver_gpios; gm->name; gm++)
-+			if (strcmp(propname, gm->name) == 0) {
-+				count = gm->size;
-+				break;
-+			}
-+	}
-+
-+	return count;
-+}
-+
- /**
-  * acpi_gpio_count - return the number of GPIOs associated with a
-  *		device / function or -ENOENT if no GPIO has been
-@@ -1223,10 +1249,7 @@ static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
- int acpi_gpio_count(struct device *dev, const char *con_id)
- {
- 	struct acpi_device *adev = ACPI_COMPANION(dev);
--	const union acpi_object *obj;
--	const struct acpi_gpio_mapping *gm;
- 	int count = -ENOENT;
--	int ret;
- 	char propname[32];
- 	unsigned int i;
- 
-@@ -1239,20 +1262,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
- 			snprintf(propname, sizeof(propname), "%s",
- 				 gpio_suffixes[i]);
- 
--		ret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
--					    &obj);
--		if (ret == 0) {
--			if (obj->type == ACPI_TYPE_LOCAL_REFERENCE)
--				count = 1;
--			else if (obj->type == ACPI_TYPE_PACKAGE)
--				count = acpi_gpio_package_count(obj);
--		} else if (adev->driver_gpios) {
--			for (gm = adev->driver_gpios; gm->name; gm++)
--				if (strcmp(propname, gm->name) == 0) {
--					count = gm->size;
--					break;
--				}
--		}
-+		count = acpi_gpio_count_from_property(adev, propname);
- 		if (count > 0)
- 			break;
- 	}
-@@ -1284,6 +1294,50 @@ bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
- 	return con_id == NULL;
- }
- 
-+/**
-+ * acpi_node_add_pin_mapping - add a pin mapping for named GPIO resources
-+ * @fwnode: pointer to an ACPI firmware node to get the GPIO information from
-+ * @propname: Property name of the GPIO
-+ * @pinctrl_name: the dev_name() of the pin controller to map to
-+ * @pin_offset: the start offset in the pin controller number space
-+ * @npins: the maximum number of pins from the offset of each pin space (GPIO
-+ *         and pin controller) to map
-+ *
-+ * Lookup the GPIO resources and map them individually to the specified pins.
-+ */
-+int acpi_node_add_pin_mapping(struct fwnode_handle *fwnode,
-+			      const char *propname,
-+			      const char *pinctl_name,
-+			      unsigned int pin_offset,
-+			      unsigned int npins)
-+{
-+	struct acpi_device *adev = to_acpi_device_node(fwnode);
-+	int count, i;
-+
-+	count = acpi_gpio_count_from_property(adev, propname);
-+	if (count < 0)
-+		return count;
-+
-+	for (i = 0; i < count && i < npins; i++) {
-+		struct gpio_desc *desc;
-+		int ret;
-+
-+		desc = acpi_node_get_gpiod(fwnode, propname, i, NULL);
-+		if (IS_ERR(desc))
-+			return PTR_ERR(desc);
-+
-+		/* The GPIOs may not be contiguous, so add them 1-by-1 */
-+		ret = gpiochip_add_pin_range(gpiod_to_chip(desc), pinctl_name,
-+					     gpio_chip_hwgpio(desc),
-+					     pin_offset + i, 1);
-+		if (ret)
-+			return ret;
-+	}
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(acpi_node_add_pin_mapping);
-+
- /* Run deferred acpi_gpiochip_request_irqs() */
- static int acpi_gpio_handle_deferred_request_irqs(void)
- {
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0001-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch b/recipes-kernel/linux/files/0001-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch
new file mode 100755
index 0000000..90d25f7
--- /dev/null
+++ b/recipes-kernel/linux/files/0001-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch
@@ -0,0 +1,136 @@
+From 176893060a1bb522535dcfcaf3996d13b834ce4d Mon Sep 17 00:00:00 2001
+From: Carlos Calderon <carlos.calderon@emutex.com>
+Date: Wed, 20 Feb 2019 16:49:37 +0000
+Subject: [PATCH 01/30] ACPI: Add support to map GPIO resources to ranges
+
+Add a function to gpiolib to facilitate registering a pin controller for
+a range of GPIO pins, but using ACPI resource references and without
+claiming the GPIO resource.
+---
+ drivers/gpio/gpiolib-acpi.c | 88 ++++++++++++++++++++++++++++++-------
+ 1 file changed, 71 insertions(+), 17 deletions(-)
+
+diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
+index b2e186047014..bed1b8bdb2ce 100644
+--- a/drivers/gpio/gpiolib-acpi.c
++++ b/drivers/gpio/gpiolib-acpi.c
+@@ -1281,6 +1281,32 @@ static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
+ 	return 1;
+ }
+ 
++static int acpi_gpio_count_from_property(struct acpi_device *adev,
++					 const char *propname)
++{
++	const struct acpi_gpio_mapping *gm;
++	const union acpi_object *obj;
++	int count = -ENOENT;
++	int ret;
++
++	ret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
++				    &obj);
++	if (ret == 0) {
++		if (obj->type == ACPI_TYPE_LOCAL_REFERENCE)
++			count = 1;
++		else if (obj->type == ACPI_TYPE_PACKAGE)
++			count = acpi_gpio_package_count(obj);
++	} else if (adev->driver_gpios) {
++		for (gm = adev->driver_gpios; gm->name; gm++)
++			if (strcmp(propname, gm->name) == 0) {
++				count = gm->size;
++				break;
++			}
++	}
++
++	return count;
++}
++
+ /**
+  * acpi_gpio_count - count the GPIOs associated with a device / function
+  * @dev:	GPIO consumer, can be %NULL for system-global GPIOs
+@@ -1293,10 +1319,7 @@ static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
+ int acpi_gpio_count(struct device *dev, const char *con_id)
+ {
+ 	struct acpi_device *adev = ACPI_COMPANION(dev);
+-	const union acpi_object *obj;
+-	const struct acpi_gpio_mapping *gm;
+ 	int count = -ENOENT;
+-	int ret;
+ 	char propname[32];
+ 	unsigned int i;
+ 
+@@ -1309,20 +1332,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
+ 			snprintf(propname, sizeof(propname), "%s",
+ 				 gpio_suffixes[i]);
+ 
+-		ret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
+-					    &obj);
+-		if (ret == 0) {
+-			if (obj->type == ACPI_TYPE_LOCAL_REFERENCE)
+-				count = 1;
+-			else if (obj->type == ACPI_TYPE_PACKAGE)
+-				count = acpi_gpio_package_count(obj);
+-		} else if (adev->driver_gpios) {
+-			for (gm = adev->driver_gpios; gm->name; gm++)
+-				if (strcmp(propname, gm->name) == 0) {
+-					count = gm->size;
+-					break;
+-				}
+-		}
++		count = acpi_gpio_count_from_property(adev, propname);
+ 		if (count > 0)
+ 			break;
+ 	}
+@@ -1345,6 +1355,50 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
+ 	return count ? count : -ENOENT;
+ }
+ 
++/**
++ * acpi_node_add_pin_mapping - add a pin mapping for named GPIO resources
++ * @fwnode: pointer to an ACPI firmware node to get the GPIO information from
++ * @propname: Property name of the GPIO
++ * @pinctrl_name: the dev_name() of the pin controller to map to
++ * @pin_offset: the start offset in the pin controller number space
++ * @npins: the maximum number of pins from the offset of each pin space (GPIO
++ *         and pin controller) to map
++ *
++ * Lookup the GPIO resources and map them individually to the specified pins.
++ */
++int acpi_node_add_pin_mapping(struct fwnode_handle *fwnode,
++			      const char *propname,
++			      const char *pinctl_name,
++			      unsigned int pin_offset,
++			      unsigned int npins)
++{
++	struct acpi_device *adev = to_acpi_device_node(fwnode);
++	int count, i;
++
++	count = acpi_gpio_count_from_property(adev, propname);
++	if (count < 0)
++		return count;
++
++	for (i = 0; i < count && i < npins; i++) {
++		struct gpio_desc *desc;
++		int ret;
++
++		desc = acpi_node_get_gpiod(fwnode, propname, i, NULL);
++		if (IS_ERR(desc))
++			return PTR_ERR(desc);
++
++		/* The GPIOs may not be contiguous, so add them 1-by-1 */
++		ret = gpiochip_add_pin_range(gpiod_to_chip(desc), pinctl_name,
++					     gpio_chip_hwgpio(desc),
++					     pin_offset + i, 1);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(acpi_node_add_pin_mapping);
++
+ /* Run deferred acpi_gpiochip_request_irqs() */
+ static int acpi_gpio_handle_deferred_request_irqs(void)
+ {
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0001-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch b/recipes-kernel/linux/files/0001-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch
deleted file mode 100644
index e4a4152..0000000
--- a/recipes-kernel/linux/files/0001-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch
+++ /dev/null
@@ -1,54 +0,0 @@
-From 59be0324275683118358d77f57d31e9588ba8412 Mon Sep 17 00:00:00 2001
-From: Dan O'Donovan <dan@emutex.com>
-Date: Wed, 15 Mar 2017 14:13:48 +0000
-Subject: [PATCH 02/19] disable RTS override on LPSS UART with Auto Flow
- Control
-
-Currently, Auto Flow Control is not working correctly on the Atom
-X5-Z8350 "Cherry Trail" SoC, because an "RTS override" feature is
-enabled in a vendor-specific register in the LPSS UART. The symptom
-is that RTS is not de-asserted as it should be when RTS/CTS flow
-control is enabled and the RX FIFO fills up.
-
-This appears to be introduced by commit 1f47a77c4e49 ("ACPI / LPSS:
-not using UART RTS override with Auto Flow Control").
-
-To _disable_ the RTS override, bit 3 needs to be _set_ in the
-"GENERAL" register at offset 808h.  The power-on default is 0. The
-aforementioned commit appears to have assumed the inverse of this.
-
-Signed-off-by: Dan O'Donovan <dan@emutex.com>
-Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
----
- drivers/acpi/acpi_lpss.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
-diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
-index 8c93466..d21c8d5 100644
---- a/drivers/acpi/acpi_lpss.c
-+++ b/drivers/acpi/acpi_lpss.c
-@@ -46,7 +46,7 @@ ACPI_MODULE_NAME("acpi_lpss");
- #define LPSS_RESETS_RESET_APB		BIT(1)
- #define LPSS_GENERAL			0x08
- #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
--#define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
-+#define LPSS_GENERAL_UART_RTS_NO_OVRD	BIT(3)
- #define LPSS_SW_LTR			0x10
- #define LPSS_AUTO_LTR			0x14
- #define LPSS_LTR_SNOOP_REQ		BIT(15)
-@@ -129,10 +129,10 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
- 	writel(val | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
- 
- 	val = readl(pdata->mmio_base + LPSS_UART_CPR);
--	if (!(val & LPSS_UART_CPR_AFCE)) {
-+	if (val & LPSS_UART_CPR_AFCE) {
- 		offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
- 		val = readl(pdata->mmio_base + offset);
--		val |= LPSS_GENERAL_UART_RTS_OVRD;
-+		val |= LPSS_GENERAL_UART_RTS_NO_OVRD;
- 		writel(val, pdata->mmio_base + offset);
- 	}
- }
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0002-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch b/recipes-kernel/linux/files/0002-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch
new file mode 100755
index 0000000..e915300
--- /dev/null
+++ b/recipes-kernel/linux/files/0002-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch
@@ -0,0 +1,54 @@
+From 9a4cd6df205ec07b81051c06ec5c592dc7313bdc Mon Sep 17 00:00:00 2001
+From: Dan O'Donovan <dan@emutex.com>
+Date: Wed, 15 Mar 2017 14:13:48 +0000
+Subject: [PATCH 02/30] disable RTS override on LPSS UART with Auto Flow
+ Control
+
+Currently, Auto Flow Control is not working correctly on the Atom
+X5-Z8350 "Cherry Trail" SoC, because an "RTS override" feature is
+enabled in a vendor-specific register in the LPSS UART. The symptom
+is that RTS is not de-asserted as it should be when RTS/CTS flow
+control is enabled and the RX FIFO fills up.
+
+This appears to be introduced by commit 1f47a77c4e49 ("ACPI / LPSS:
+not using UART RTS override with Auto Flow Control").
+
+To _disable_ the RTS override, bit 3 needs to be _set_ in the
+"GENERAL" register at offset 808h.  The power-on default is 0. The
+aforementioned commit appears to have assumed the inverse of this.
+
+Signed-off-by: Dan O'Donovan <dan@emutex.com>
+Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
+---
+ drivers/acpi/acpi_lpss.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
+index 751ed38f2a10..f34d4940e0f5 100644
+--- a/drivers/acpi/acpi_lpss.c
++++ b/drivers/acpi/acpi_lpss.c
+@@ -46,7 +46,7 @@ ACPI_MODULE_NAME("acpi_lpss");
+ #define LPSS_RESETS_RESET_APB		BIT(1)
+ #define LPSS_GENERAL			0x08
+ #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
+-#define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
++#define LPSS_GENERAL_UART_RTS_NO_OVRD	BIT(3)
+ #define LPSS_SW_LTR			0x10
+ #define LPSS_AUTO_LTR			0x14
+ #define LPSS_LTR_SNOOP_REQ		BIT(15)
+@@ -133,10 +133,10 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
+ 	writel(val | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
+ 
+ 	val = readl(pdata->mmio_base + LPSS_UART_CPR);
+-	if (!(val & LPSS_UART_CPR_AFCE)) {
++	if (val & LPSS_UART_CPR_AFCE) {
+ 		offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
+ 		val = readl(pdata->mmio_base + offset);
+-		val |= LPSS_GENERAL_UART_RTS_OVRD;
++		val |= LPSS_GENERAL_UART_RTS_NO_OVRD;
+ 		writel(val, pdata->mmio_base + offset);
+ 	}
+ }
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0002-iio-adc128s052-allow-driver-to-be-matched-using-ACPI.patch b/recipes-kernel/linux/files/0002-iio-adc128s052-allow-driver-to-be-matched-using-ACPI.patch
deleted file mode 100644
index e04199b..0000000
--- a/recipes-kernel/linux/files/0002-iio-adc128s052-allow-driver-to-be-matched-using-ACPI.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From 99d4c5caeb3b16517bbd539cd2adf55ca7ac2e51 Mon Sep 17 00:00:00 2001
-From: Dan O'Donovan <dan@emutex.com>
-Date: Thu, 19 Jan 2017 17:40:53 +0000
-Subject: [PATCH 03/19] iio: adc128s052: allow driver to be matched using ACPI
-
-Allow driver to be matched by compatible string in
-ACPI device properties.
-
-Signed-off-by: Dan O'Donovan <dan@emutex.com>
----
- drivers/iio/adc/ti-adc128s052.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/drivers/iio/adc/ti-adc128s052.c b/drivers/iio/adc/ti-adc128s052.c
-index 89dfbd3..1a51278 100644
---- a/drivers/iio/adc/ti-adc128s052.c
-+++ b/drivers/iio/adc/ti-adc128s052.c
-@@ -203,7 +203,7 @@ MODULE_DEVICE_TABLE(spi, adc128_id);
- static struct spi_driver adc128_driver = {
- 	.driver = {
- 		.name = "adc128s052",
--		.of_match_table = of_match_ptr(adc128_of_match),
-+		.of_match_table = adc128_of_match,
- 	},
- 	.probe = adc128_probe,
- 	.remove = adc128_remove,
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch b/recipes-kernel/linux/files/0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch
old mode 100644
new mode 100755
index 36006b9..bcd0851
--- a/recipes-kernel/linux/files/0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch
+++ b/recipes-kernel/linux/files/0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch
@@ -1,7 +1,7 @@
-From d2c815ce2e614eef2025c23dedf765b64047b0b0 Mon Sep 17 00:00:00 2001
+From f300ec8aa6cdbd2e1e7f6421b42453f115bc58db Mon Sep 17 00:00:00 2001
 From: Carlos Calderon <carlos@emutex.com>
-Date: Fri, 4 Jan 2019 10:58:24 +0000
-Subject: [PATCH 04/19] pinctrl: allow multiple pin controllers for a GPIO
+Date: Thu, 26 Nov 2020 09:58:40 +0800
+Subject: [PATCH 03/30] pinctrl: allow multiple pin controllers for a GPIO
 
 Add support for chaining pinctrl drivers controlling the same GPIO line.
 This allows for hardware configurations where multiple controllers must
@@ -16,14 +16,17 @@ configuration, this FPGA implements a pin controller for FPGA-connected
 pins. This setup requires coordination between the SoC GPIO controller
 and the FPGA-based controller, hence this patch.
 ---
- drivers/pinctrl/core.c | 309 +++++++++++++++++++++++++++----------------------
- 1 file changed, 170 insertions(+), 139 deletions(-)
+ drivers/pinctrl/core.c | 227 +++++++++++++++++++++++++++++++----------
+ 1 file changed, 172 insertions(+), 55 deletions(-)
+ mode change 100644 => 100755 drivers/pinctrl/core.c
 
 diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
-index a3dd777..aad7a67 100644
+old mode 100644
+new mode 100755
+index 6381745e3bb1..96250717637a
 --- a/drivers/pinctrl/core.c
 +++ b/drivers/pinctrl/core.c
-@@ -288,8 +288,7 @@ static int pinctrl_register_pins(struct pinctrl_dev *pctldev,
+@@ -264,8 +264,7 @@ static int pinctrl_register_pins(struct pinctrl_dev *pctldev,
   * and pin list based GPIO ranges is managed correctly by this function.
   *
   * This function assumes the gpio is part of the specified GPIO range, use
@@ -33,100 +36,25 @@ index a3dd777..aad7a67 100644
   */
  static inline int gpio_to_pin(struct pinctrl_gpio_range *range,
  				unsigned int gpio)
-@@ -329,92 +328,6 @@ pinctrl_match_gpio_range(struct pinctrl_dev *pctldev, unsigned gpio)
+@@ -318,7 +317,7 @@ pinctrl_match_gpio_range(struct pinctrl_dev *pctldev, unsigned gpio)
+  * is false, it means that pinctrl device may not be ready.
+  */
+ #ifdef CONFIG_GPIOLIB
+-static bool pinctrl_ready_for_gpio_range(unsigned gpio)
++static bool __attribute__((unused))pinctrl_ready_for_gpio_range(unsigned gpio)
+ {
+ 	struct pinctrl_dev *pctldev;
+ 	struct pinctrl_gpio_range *range = NULL;
+@@ -350,7 +349,7 @@ static bool pinctrl_ready_for_gpio_range(unsigned gpio)
+ 	return false;
  }
+ #else
+-static bool pinctrl_ready_for_gpio_range(unsigned gpio) { return true; }
++static bool __attribute__((unused))pinctrl_ready_for_gpio_range(unsigned gpio) { return true; }
+ #endif
  
  /**
-- * pinctrl_ready_for_gpio_range() - check if other GPIO pins of
-- * the same GPIO chip are in range
-- * @gpio: gpio pin to check taken from the global GPIO pin space
-- *
-- * This function is complement of pinctrl_match_gpio_range(). If the return
-- * value of pinctrl_match_gpio_range() is NULL, this function could be used
-- * to check whether pinctrl device is ready or not. Maybe some GPIO pins
-- * of the same GPIO chip don't have back-end pinctrl interface.
-- * If the return value is true, it means that pinctrl device is ready & the
-- * certain GPIO pin doesn't have back-end pinctrl device. If the return value
-- * is false, it means that pinctrl device may not be ready.
-- */
--#ifdef CONFIG_GPIOLIB
--static bool pinctrl_ready_for_gpio_range(unsigned gpio)
--{
--	struct pinctrl_dev *pctldev;
--	struct pinctrl_gpio_range *range = NULL;
--	struct gpio_chip *chip = gpio_to_chip(gpio);
--
--	if (WARN(!chip, "no gpio_chip for gpio%i?", gpio))
--		return false;
--
--	mutex_lock(&pinctrldev_list_mutex);
--
--	/* Loop over the pin controllers */
--	list_for_each_entry(pctldev, &pinctrldev_list, node) {
--		/* Loop over the ranges */
--		mutex_lock(&pctldev->mutex);
--		list_for_each_entry(range, &pctldev->gpio_ranges, node) {
--			/* Check if any gpio range overlapped with gpio chip */
--			if (range->base + range->npins - 1 < chip->base ||
--			    range->base > chip->base + chip->ngpio - 1)
--				continue;
--			mutex_unlock(&pctldev->mutex);
--			mutex_unlock(&pinctrldev_list_mutex);
--			return true;
--		}
--		mutex_unlock(&pctldev->mutex);
--	}
--
--	mutex_unlock(&pinctrldev_list_mutex);
--
--	return false;
--}
--#else
--static bool pinctrl_ready_for_gpio_range(unsigned gpio) { return true; }
--#endif
--
--/**
-- * pinctrl_get_device_gpio_range() - find device for GPIO range
-- * @gpio: the pin to locate the pin controller for
-- * @outdev: the pin control device if found
-- * @outrange: the GPIO range if found
-- *
-- * Find the pin controller handling a certain GPIO pin from the pinspace of
-- * the GPIO subsystem, return the device and the matching GPIO range. Returns
-- * -EPROBE_DEFER if the GPIO range could not be found in any device since it
-- * may still have not been registered.
-- */
--static int pinctrl_get_device_gpio_range(unsigned gpio,
--					 struct pinctrl_dev **outdev,
--					 struct pinctrl_gpio_range **outrange)
--{
--	struct pinctrl_dev *pctldev = NULL;
--
--	mutex_lock(&pinctrldev_list_mutex);
--
--	/* Loop over the pin controllers */
--	list_for_each_entry(pctldev, &pinctrldev_list, node) {
--		struct pinctrl_gpio_range *range;
--
--		range = pinctrl_match_gpio_range(pctldev, gpio);
--		if (range) {
--			*outdev = pctldev;
--			*outrange = range;
--			mutex_unlock(&pinctrldev_list_mutex);
--			return 0;
--		}
--	}
--
--	mutex_unlock(&pinctrldev_list_mutex);
--
--	return -EPROBE_DEFER;
--}
--
--/**
-  * pinctrl_add_gpio_range() - register a GPIO range for a controller
-  * @pctldev: pin controller device to add the range to
-  * @range: the GPIO range to add
-@@ -728,6 +641,57 @@ static inline void pinctrl_generic_free_groups(struct pinctrl_dev *pctldev)
+@@ -704,6 +703,57 @@ static inline void pinctrl_generic_free_groups(struct pinctrl_dev *pctldev)
  }
  #endif /* CONFIG_GENERIC_PINCTRL_GROUPS */
  
@@ -184,7 +112,7 @@ index a3dd777..aad7a67 100644
  /**
   * pinctrl_get_group_selector() - returns the group selector for a group
   * @pctldev: the pin controller handling the group
-@@ -768,28 +732,53 @@ int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
+@@ -772,28 +822,53 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_can_use_line);
   * as part of their gpio_request() semantics, platforms and individual drivers
   * shall *NOT* request GPIO pins to be muxed in.
   */
@@ -252,7 +180,7 @@ index a3dd777..aad7a67 100644
  
  	return ret;
  }
-@@ -803,47 +792,64 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_request);
+@@ -807,47 +882,64 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_request);
   * as part of their gpio_free() semantics, platforms and individual drivers
   * shall *NOT* request GPIO pins to be muxed out.
   */
@@ -271,13 +199,14 @@ index a3dd777..aad7a67 100644
 -	}
 -	mutex_lock(&pctldev->mutex);
 +	pinctrl_free_gpio_locked(gpio);
-+
+ 
+-	/* Convert to the pin controllers number space */
+-	pin = gpio_to_pin(range, gpio);
 +	mutex_unlock(&pinctrldev_list_mutex);
 +}
 +EXPORT_SYMBOL_GPL(pinctrl_gpio_free);
  
--	/* Convert to the pin controllers number space */
--	pin = gpio_to_pin(range, gpio);
+-	pinmux_free_gpio(pctldev, pin, range);
 +static int pinctrl_set_dir_if_match(struct pinctrl_dev *pctldev,
 +				    unsigned int gpio, bool input)
 +{
@@ -285,11 +214,10 @@ index a3dd777..aad7a67 100644
 +		pinctrl_match_gpio_range(pctldev, gpio);
 +	int ret = 0;
  
--	pinmux_free_gpio(pctldev, pin, range);
+-	mutex_unlock(&pctldev->mutex);
 +	if (range != NULL) {
 +		int pin;
- 
--	mutex_unlock(&pctldev->mutex);
++
 +		mutex_lock(&pctldev->mutex);
 +		pin = gpio_to_pin(range, gpio);
 +		ret = pinmux_gpio_direction(pctldev, range, pin, input);
@@ -306,13 +234,13 @@ index a3dd777..aad7a67 100644
 -	struct pinctrl_gpio_range *range;
 -	int ret;
 -	int pin;
-+	int ret = -EPROBE_DEFER;
- 
+-
 -	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 -	if (ret) {
 -		return ret;
 -	}
--
++	int ret = -EPROBE_DEFER;
+ 
 -	mutex_lock(&pctldev->mutex);
 +	mutex_lock(&pinctrldev_list_mutex);
  
@@ -345,7 +273,7 @@ index a3dd777..aad7a67 100644
  
  	return ret;
  }
-@@ -888,18 +894,43 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
+@@ -892,18 +984,43 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
  int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
  {
  	unsigned long configs[] = { config };
@@ -399,5 +327,5 @@ index a3dd777..aad7a67 100644
  	return ret;
  }
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch b/recipes-kernel/linux/files/0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch
old mode 100644
new mode 100755
index c468957..fe91055
--- a/recipes-kernel/linux/files/0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch
+++ b/recipes-kernel/linux/files/0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch
@@ -1,7 +1,7 @@
-From b0ec896e741f330df18785e931537be1862ff4c8 Mon Sep 17 00:00:00 2001
+From 22225c99efb7e8037a3c81b3baae2d8a8df098e9 Mon Sep 17 00:00:00 2001
 From: Nicola Lunghi <nicola.lunghi@emutex.com>
 Date: Thu, 27 Jul 2017 17:55:34 +0100
-Subject: [PATCH 05/19] regmap: Expose regmap_writable function to check if a
+Subject: [PATCH 04/30] regmap: Expose regmap_writable function to check if a
  register is writable
 
 Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
@@ -12,10 +12,10 @@ Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
  3 files changed, 11 insertions(+), 5 deletions(-)
 
 diff --git a/drivers/base/regmap/internal.h b/drivers/base/regmap/internal.h
-index a6bf34d63..de951a1 100644
+index 3d80c4b43f72..4d2fa740f354 100644
 --- a/drivers/base/regmap/internal.h
 +++ b/drivers/base/regmap/internal.h
-@@ -178,11 +178,6 @@ struct regcache_ops {
+@@ -177,11 +177,6 @@ struct regcache_ops {
  	int (*drop)(struct regmap *map, unsigned int min, unsigned int max);
  };
  
@@ -24,14 +24,14 @@ index a6bf34d63..de951a1 100644
 -bool regmap_readable(struct regmap *map, unsigned int reg);
 -bool regmap_volatile(struct regmap *map, unsigned int reg);
 -bool regmap_precious(struct regmap *map, unsigned int reg);
+ bool regmap_writeable_noinc(struct regmap *map, unsigned int reg);
  bool regmap_readable_noinc(struct regmap *map, unsigned int reg);
  
- int _regmap_write(struct regmap *map, unsigned int reg,
 diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
-index 0360a90..f61a24c 100644
+index 927ebde1607b..6062e6effc0c 100644
 --- a/drivers/base/regmap/regmap.c
 +++ b/drivers/base/regmap/regmap.c
-@@ -93,6 +93,7 @@ bool regmap_writeable(struct regmap *map, unsigned int reg)
+@@ -100,6 +100,7 @@ bool regmap_writeable(struct regmap *map, unsigned int reg)
  
  	return true;
  }
@@ -39,7 +39,7 @@ index 0360a90..f61a24c 100644
  
  bool regmap_cached(struct regmap *map, unsigned int reg)
  {
-@@ -116,6 +117,7 @@ bool regmap_cached(struct regmap *map, unsigned int reg)
+@@ -123,6 +124,7 @@ bool regmap_cached(struct regmap *map, unsigned int reg)
  
  	return true;
  }
@@ -47,7 +47,7 @@ index 0360a90..f61a24c 100644
  
  bool regmap_readable(struct regmap *map, unsigned int reg)
  {
-@@ -136,6 +138,7 @@ bool regmap_readable(struct regmap *map, unsigned int reg)
+@@ -143,6 +145,7 @@ bool regmap_readable(struct regmap *map, unsigned int reg)
  
  	return true;
  }
@@ -55,7 +55,7 @@ index 0360a90..f61a24c 100644
  
  bool regmap_volatile(struct regmap *map, unsigned int reg)
  {
-@@ -153,6 +156,7 @@ bool regmap_volatile(struct regmap *map, unsigned int reg)
+@@ -160,6 +163,7 @@ bool regmap_volatile(struct regmap *map, unsigned int reg)
  	else
  		return true;
  }
@@ -63,19 +63,19 @@ index 0360a90..f61a24c 100644
  
  bool regmap_precious(struct regmap *map, unsigned int reg)
  {
-@@ -167,6 +171,7 @@ bool regmap_precious(struct regmap *map, unsigned int reg)
+@@ -174,6 +178,7 @@ bool regmap_precious(struct regmap *map, unsigned int reg)
  
  	return false;
  }
 +EXPORT_SYMBOL_GPL(regmap_precious);
  
- bool regmap_readable_noinc(struct regmap *map, unsigned int reg)
+ bool regmap_writeable_noinc(struct regmap *map, unsigned int reg)
  {
 diff --git a/include/linux/regmap.h b/include/linux/regmap.h
-index 035129b..36bc898 100644
+index dfe493ac692d..7ec57ab64252 100644
 --- a/include/linux/regmap.h
 +++ b/include/linux/regmap.h
-@@ -1025,6 +1025,12 @@ void regcache_mark_dirty(struct regmap *map);
+@@ -1051,6 +1051,12 @@ void regcache_mark_dirty(struct regmap *map);
  bool regmap_check_range_table(struct regmap *map, unsigned int reg,
  			      const struct regmap_access_table *table);
  
@@ -89,5 +89,5 @@ index 035129b..36bc898 100644
  			  int num_regs);
  int regmap_parse_val(struct regmap *map, const void *buf,
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0005-iio-adc128s052-allow-device-to-be-matched-using-acpi.patch b/recipes-kernel/linux/files/0005-iio-adc128s052-allow-device-to-be-matched-using-acpi.patch
deleted file mode 100644
index 2b4a476..0000000
--- a/recipes-kernel/linux/files/0005-iio-adc128s052-allow-device-to-be-matched-using-acpi.patch
+++ /dev/null
@@ -1,71 +0,0 @@
-From 3a7637855ab7e54b919fae6e6df20532fa1233f6 Mon Sep 17 00:00:00 2001
-From: Carlos Calderon <carlos@emutex.com>
-Date: Wed, 3 Oct 2018 16:39:39 +0100
-Subject: [PATCH 08/19] iio: adc128s052: allow device to be matched using acpi
- _HID AANT1280
-
-The acpi _HID AANT1280 matches an ADC124S101 present on UP^2 board
-that is compatible with adc124s021.
-Add it to the driver.
----
- drivers/iio/adc/ti-adc128s052.c | 24 +++++++++++++++++++++++-
- 1 file changed, 23 insertions(+), 1 deletion(-)
-
-diff --git a/drivers/iio/adc/ti-adc128s052.c b/drivers/iio/adc/ti-adc128s052.c
-index 1a51278..fa84998 100644
---- a/drivers/iio/adc/ti-adc128s052.c
-+++ b/drivers/iio/adc/ti-adc128s052.c
-@@ -17,6 +17,7 @@
- #include <linux/module.h>
- #include <linux/iio/iio.h>
- #include <linux/regulator/consumer.h>
-+#include <linux/acpi.h>
- 
- struct adc128_configuration {
- 	const struct iio_chan_spec	*channels;
-@@ -137,9 +138,21 @@ static int adc128_probe(struct spi_device *spi)
- {
- 	struct iio_dev *indio_dev;
- 	struct adc128 *adc;
--	int config = spi_get_device_id(spi)->driver_data;
-+	int config;
- 	int ret;
- 
-+	if (ACPI_COMPANION(&spi->dev)) {
-+		const struct acpi_device_id *ad_id;
-+		ad_id = acpi_match_device(spi->dev.driver->acpi_match_table,
-+					  &spi->dev);
-+		if (!ad_id)
-+			return -ENODEV;
-+
-+		config = ad_id->driver_data;
-+	} else {
-+		config = spi_get_device_id(spi)->driver_data;
-+	}
-+
- 	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
- 	if (!indio_dev)
- 		return -ENOMEM;
-@@ -200,10 +213,19 @@ static const struct spi_device_id adc128_id[] = {
- };
- MODULE_DEVICE_TABLE(spi, adc128_id);
- 
-+#ifdef CONFIG_ACPI
-+static const struct acpi_device_id adc128_acpi_match[] = {
-+	{ "AANT1280", 2 }, /* ADC124S021 compatible ACPI ID */
-+	{ }
-+};
-+MODULE_DEVICE_TABLE(acpi, adc128_acpi_match);
-+#endif
-+
- static struct spi_driver adc128_driver = {
- 	.driver = {
- 		.name = "adc128s052",
- 		.of_match_table = adc128_of_match,
-+		.acpi_match_table = ACPI_PTR(adc128_acpi_match),
- 	},
- 	.probe = adc128_probe,
- 	.remove = adc128_remove,
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0005-mfd-Add-support-for-UP-board-CPLD-FPGA.patch b/recipes-kernel/linux/files/0005-mfd-Add-support-for-UP-board-CPLD-FPGA.patch
new file mode 100755
index 0000000..4898cc1
--- /dev/null
+++ b/recipes-kernel/linux/files/0005-mfd-Add-support-for-UP-board-CPLD-FPGA.patch
@@ -0,0 +1,1514 @@
+From 8fdb08ccbf1b5502f82fdf90ff94876101db3ef9 Mon Sep 17 00:00:00 2001
+From: Carlos Calderon <carlos@emutex.com>
+Date: Thu, 4 Oct 2018 10:40:49 +0100
+Subject: [PATCH 05/30] mfd: Add support for UP board CPLD/FPGA
+
+The UP Squared board <http://www.upboard.com> implements certain
+features (pin control, onboard LEDs or CEC) through an on-board FPGA.
+
+This mfd driver implements the line protocol to read and write registers
+from the FPGA through regmap. The register address map is also included.
+
+The UP boards come with a few FPGA-controlled onboard LEDs:
+* UP Board: yellow, green, red
+* UP Squared: blue, yellow, green, red
+
+The UP Boards provide a few I/O pin headers (for both GPIO and
+functions), including a 40-pin Raspberry Pi compatible header.
+
+This patch implements support for the FPGA-based pin controller that
+manages direction and enable state for those header pins.
+
+Signed-off-by: Javier Arteaga <javier@emutex.com>
+[merge various fixes]
+Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
+---
+ drivers/leds/Kconfig              |   7 +
+ drivers/leds/Makefile             |   1 +
+ drivers/leds/leds-upboard.c       |  88 ++++
+ drivers/mfd/Kconfig               |   6 +
+ drivers/mfd/Makefile              |   1 +
+ drivers/mfd/upboard-fpga.c        | 411 +++++++++++++++
+ drivers/pinctrl/Kconfig           |  12 +
+ drivers/pinctrl/Makefile          |   1 +
+ drivers/pinctrl/pinctrl-upboard.c | 797 ++++++++++++++++++++++++++++++
+ include/linux/mfd/upboard-fpga.h  |  52 ++
+ 10 files changed, 1376 insertions(+)
+ create mode 100644 drivers/leds/leds-upboard.c
+ create mode 100644 drivers/mfd/upboard-fpga.c
+ create mode 100644 drivers/pinctrl/pinctrl-upboard.c
+ create mode 100644 include/linux/mfd/upboard-fpga.h
+
+diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
+index 1988de1d64c0..254512248f80 100644
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -823,6 +823,13 @@ config LEDS_LM36274
+ 	  Say Y to enable the LM36274 LED driver for TI LMU devices.
+ 	  This supports the LED device LM36274.
+ 
++config LEDS_UPBOARD
++	tristate "LED support for the UP board"
++	depends on LEDS_CLASS
++	depends on MFD_UPBOARD_FPGA
++	help
++	  This option enables support for the UP board LEDs.
++
+ comment "LED Triggers"
+ source "drivers/leds/trigger/Kconfig"
+ 
+diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
+index 41fb073a39c1..3941be58ba28 100644
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -79,6 +79,7 @@ obj-$(CONFIG_LEDS_MLXREG)		+= leds-mlxreg.o
+ obj-$(CONFIG_LEDS_NIC78BX)		+= leds-nic78bx.o
+ obj-$(CONFIG_LEDS_SPI_BYTE)		+= leds-spi-byte.o
+ obj-$(CONFIG_LEDS_MT6323)		+= leds-mt6323.o
++obj-$(CONFIG_LEDS_UPBOARD)		+= leds-upboard.o
+ obj-$(CONFIG_LEDS_LM3692X)		+= leds-lm3692x.o
+ obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
+ obj-$(CONFIG_LEDS_LM3601X)		+= leds-lm3601x.o
+diff --git a/drivers/leds/leds-upboard.c b/drivers/leds/leds-upboard.c
+new file mode 100644
+index 000000000000..16bd1b7c0a1e
+--- /dev/null
++++ b/drivers/leds/leds-upboard.c
+@@ -0,0 +1,88 @@
++/*
++ * UP Board FPGA-based LED driver
++ *
++ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
++ *
++ * Author: Javier Arteaga <javier@emutex.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/kernel.h>
++#include <linux/leds.h>
++#include <linux/mfd/upboard-fpga.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++
++struct upboard_led {
++	struct regmap_field *field;
++	struct led_classdev cdev;
++};
++
++static enum led_brightness upboard_led_brightness_get(struct led_classdev
++						      *cdev)
++{
++	struct upboard_led *led = container_of(cdev, struct upboard_led, cdev);
++	int brightness = 0;
++
++	regmap_field_read(led->field, &brightness);
++
++	return brightness;
++};
++
++static void upboard_led_brightness_set(struct led_classdev *cdev,
++				       enum led_brightness brightness)
++{
++	struct upboard_led *led = container_of(cdev, struct upboard_led, cdev);
++
++	regmap_field_write(led->field, brightness != LED_OFF);
++};
++
++static int __init upboard_led_probe(struct platform_device *pdev)
++{
++	struct upboard_fpga * const fpga = dev_get_drvdata(pdev->dev.parent);
++	struct reg_field fldconf = {
++		.reg = UPFPGA_REG_FUNC_EN0,
++	};
++	struct upboard_led_data * const pdata = pdev->dev.platform_data;
++	struct upboard_led *led;
++
++	if (!fpga || !pdata)
++		return -EINVAL;
++
++	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
++	if (!led)
++		return -ENOMEM;
++
++	fldconf.lsb = pdata->bit;
++	fldconf.msb = pdata->bit;
++	led->field = devm_regmap_field_alloc(&pdev->dev, fpga->regmap, fldconf);
++	if (IS_ERR(led->field))
++		return PTR_ERR(led->field);
++
++	led->cdev.brightness_get = upboard_led_brightness_get;
++	led->cdev.brightness_set = upboard_led_brightness_set;
++	led->cdev.name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "upboard:%s:",
++					pdata->colour);
++
++	if (!led->cdev.name)
++		return -ENOMEM;
++
++	return devm_led_classdev_register(&pdev->dev, &led->cdev);
++};
++
++static struct platform_driver upboard_led_driver = {
++	.driver = {
++		.name = "upboard-led",
++	},
++};
++
++module_platform_driver_probe(upboard_led_driver, upboard_led_probe);
++
++MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
++MODULE_DESCRIPTION("UP Board LED driver");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:upboard-led");
+\ No newline at end of file
+diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
+index 43169f25da1f..e90def5983e3 100644
+--- a/drivers/mfd/Kconfig
++++ b/drivers/mfd/Kconfig
+@@ -1968,6 +1968,12 @@ config MFD_STMFX
+ 	  additional drivers must be enabled in order to use the functionality
+ 	  of the device.
+ 
++config MFD_UPBOARD_FPGA
++	tristate "Support for the UP board FPGA"
++	select MFD_CORE
++	help
++	  Select this option to enable the UP and UP^2 on-board FPGA.
++
+ menu "Multimedia Capabilities Port drivers"
+ 	depends on ARCH_SA1100
+ 
+diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
+index c1067ea46204..7e9c9fe47eaa 100644
+--- a/drivers/mfd/Makefile
++++ b/drivers/mfd/Makefile
+@@ -246,6 +246,7 @@ obj-$(CONFIG_MFD_ALTERA_A10SR)	+= altera-a10sr.o
+ obj-$(CONFIG_MFD_ALTERA_SYSMGR) += altera-sysmgr.o
+ obj-$(CONFIG_MFD_STPMIC1)	+= stpmic1.o
+ obj-$(CONFIG_MFD_SUN4I_GPADC)	+= sun4i-gpadc.o
++obj-$(CONFIG_MFD_UPBOARD_FPGA)	+= upboard-fpga.o
+ 
+ obj-$(CONFIG_MFD_STM32_LPTIMER)	+= stm32-lptimer.o
+ obj-$(CONFIG_MFD_STM32_TIMERS) 	+= stm32-timers.o
+diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
+new file mode 100644
+index 000000000000..9f444f876af1
+--- /dev/null
++++ b/drivers/mfd/upboard-fpga.c
+@@ -0,0 +1,411 @@
++/*
++ * UP Board main platform driver and FPGA configuration support
++ *
++ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
++ *
++ * Author: Javier Arteaga <javier@emutex.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/acpi.h>
++#include <linux/dmi.h>
++#include <linux/gpio.h>
++#include <linux/kernel.h>
++#include <linux/mfd/core.h>
++#include <linux/mfd/upboard-fpga.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++
++static int upboard_fpga_read(void *, unsigned int, unsigned int *);
++static int upboard_fpga_write(void *, unsigned int, unsigned int);
++
++struct upboard_fpga_data {
++	const struct regmap_config *regmapconf;
++	const struct mfd_cell *cells;
++	size_t ncells;
++};
++
++#define UPBOARD_LED_CELL(led_data, n)                   \
++	{                                               \
++		.name = "upboard-led",                  \
++		.id = (n),                              \
++		.platform_data = &led_data[(n)],        \
++		.pdata_size = sizeof(*(led_data)),      \
++	}
++
++/* UP board */
++
++static const struct regmap_range upboard_up_readable_ranges[] = {
++	regmap_reg_range(UPFPGA_REG_PLATFORM_ID, UPFPGA_REG_FIRMWARE_ID),
++	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN0),
++	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR1),
++};
++
++static const struct regmap_range upboard_up_writable_ranges[] = {
++	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN0),
++	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR1),
++};
++
++static const struct regmap_access_table upboard_up_readable_table = {
++	.yes_ranges = upboard_up_readable_ranges,
++	.n_yes_ranges = ARRAY_SIZE(upboard_up_readable_ranges),
++};
++
++static const struct regmap_access_table upboard_up_writable_table = {
++	.yes_ranges = upboard_up_writable_ranges,
++	.n_yes_ranges = ARRAY_SIZE(upboard_up_writable_ranges),
++};
++
++static const struct regmap_config upboard_up_regmap_config = {
++	.reg_bits = UPFPGA_ADDRESS_SIZE,
++	.val_bits = UPFPGA_REGISTER_SIZE,
++	.max_register = UPFPGA_REG_MAX,
++	.reg_read = upboard_fpga_read,
++	.reg_write = upboard_fpga_write,
++	.fast_io = false,
++	.cache_type = REGCACHE_RBTREE,
++	.rd_table = &upboard_up_readable_table,
++	.wr_table = &upboard_up_writable_table,
++};
++
++static struct upboard_led_data upboard_up_led_data[] = {
++	{ .bit = 0, .colour = "yellow" },
++	{ .bit = 1, .colour = "green" },
++	{ .bit = 2, .colour = "red" },
++};
++
++static const struct mfd_cell upboard_up_mfd_cells[] = {
++	{ .name = "upboard-pinctrl" },
++	UPBOARD_LED_CELL(upboard_up_led_data, 0),
++	UPBOARD_LED_CELL(upboard_up_led_data, 1),
++	UPBOARD_LED_CELL(upboard_up_led_data, 2),
++};
++
++static const struct upboard_fpga_data upboard_up_fpga_data = {
++	.regmapconf = &upboard_up_regmap_config,
++	.cells = upboard_up_mfd_cells,
++	.ncells = ARRAY_SIZE(upboard_up_mfd_cells),
++};
++
++/* UP^2 board */
++
++static const struct regmap_range upboard_up2_readable_ranges[] = {
++	regmap_reg_range(UPFPGA_REG_PLATFORM_ID, UPFPGA_REG_FIRMWARE_ID),
++	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN1),
++	regmap_reg_range(UPFPGA_REG_GPIO_EN0, UPFPGA_REG_GPIO_EN2),
++	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR2),
++};
++
++static const struct regmap_range upboard_up2_writable_ranges[] = {
++	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN1),
++	regmap_reg_range(UPFPGA_REG_GPIO_EN0, UPFPGA_REG_GPIO_EN2),
++	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR2),
++};
++
++static const struct regmap_access_table upboard_up2_readable_table = {
++	.yes_ranges = upboard_up2_readable_ranges,
++	.n_yes_ranges = ARRAY_SIZE(upboard_up2_readable_ranges),
++};
++
++static const struct regmap_access_table upboard_up2_writable_table = {
++	.yes_ranges = upboard_up2_writable_ranges,
++	.n_yes_ranges = ARRAY_SIZE(upboard_up2_writable_ranges),
++};
++
++static const struct regmap_config upboard_up2_regmap_config = {
++	.reg_bits = UPFPGA_ADDRESS_SIZE,
++	.val_bits = UPFPGA_REGISTER_SIZE,
++	.max_register = UPFPGA_REG_MAX,
++	.reg_read = upboard_fpga_read,
++	.reg_write = upboard_fpga_write,
++	.fast_io = false,
++	.cache_type = REGCACHE_RBTREE,
++	.rd_table = &upboard_up2_readable_table,
++	.wr_table = &upboard_up2_writable_table,
++};
++
++static struct upboard_led_data upboard_up2_led_data[] = {
++	{ .bit = 0, .colour = "blue" },
++	{ .bit = 1, .colour = "yellow" },
++	{ .bit = 2, .colour = "green" },
++	{ .bit = 3, .colour = "red" },
++};
++
++static const struct mfd_cell upboard_up2_mfd_cells[] = {
++	{ .name = "upboard-pinctrl" },
++	UPBOARD_LED_CELL(upboard_up2_led_data, 0),
++	UPBOARD_LED_CELL(upboard_up2_led_data, 1),
++	UPBOARD_LED_CELL(upboard_up2_led_data, 2),
++	UPBOARD_LED_CELL(upboard_up2_led_data, 3),
++};
++
++static const struct upboard_fpga_data upboard_up2_fpga_data = {
++	.regmapconf = &upboard_up2_regmap_config,
++	.cells = upboard_up2_mfd_cells,
++	.ncells = ARRAY_SIZE(upboard_up2_mfd_cells),
++};
++
++static int upboard_fpga_read(void *context, unsigned int reg, unsigned int *val)
++{
++	struct upboard_fpga * const fpga = context;
++	int i;
++
++	gpiod_set_value(fpga->clear_gpio, 0);
++	gpiod_set_value(fpga->clear_gpio, 1);
++
++	reg |= UPFPGA_READ_FLAG;
++
++	for (i = UPFPGA_ADDRESS_SIZE; i >= 0; i--) {
++		gpiod_set_value(fpga->strobe_gpio, 0);
++		gpiod_set_value(fpga->datain_gpio, (reg >> i) & 0x1);
++		gpiod_set_value(fpga->strobe_gpio, 1);
++	}
++
++	gpiod_set_value(fpga->strobe_gpio, 0);
++	*val = 0;
++
++	for (i = UPFPGA_REGISTER_SIZE - 1; i >= 0; i--) {
++		gpiod_set_value(fpga->strobe_gpio, 1);
++		gpiod_set_value(fpga->strobe_gpio, 0);
++		*val |= gpiod_get_value(fpga->dataout_gpio) << i;
++	}
++
++	gpiod_set_value(fpga->strobe_gpio, 1);
++
++	return 0;
++};
++
++static int upboard_fpga_write(void *context, unsigned int reg, unsigned int val)
++{
++	struct upboard_fpga * const fpga = context;
++	int i;
++
++	gpiod_set_value(fpga->clear_gpio, 0);
++	gpiod_set_value(fpga->clear_gpio, 1);
++
++	for (i = UPFPGA_ADDRESS_SIZE; i >= 0; i--) {
++		gpiod_set_value(fpga->strobe_gpio, 0);
++		gpiod_set_value(fpga->datain_gpio, (reg >> i) & 0x1);
++		gpiod_set_value(fpga->strobe_gpio, 1);
++	}
++
++	gpiod_set_value(fpga->strobe_gpio, 0);
++
++	for (i = UPFPGA_REGISTER_SIZE - 1; i >= 0; i--) {
++		gpiod_set_value(fpga->datain_gpio, (val >> i) & 0x1);
++		gpiod_set_value(fpga->strobe_gpio, 1);
++		gpiod_set_value(fpga->strobe_gpio, 0);
++	}
++
++	gpiod_set_value(fpga->strobe_gpio, 1);
++
++	return 0;
++};
++
++static int __init upboard_fpga_gpio_init(struct upboard_fpga *fpga)
++{
++	enum gpiod_flags flags;
++
++	flags = fpga->uninitialised ? GPIOD_OUT_LOW : GPIOD_ASIS;
++	fpga->enable_gpio = devm_gpiod_get(fpga->dev, "enable", flags);
++	if (IS_ERR(fpga->enable_gpio))
++		return PTR_ERR(fpga->enable_gpio);
++
++	fpga->clear_gpio = devm_gpiod_get(fpga->dev, "clear", GPIOD_OUT_LOW);
++	if (IS_ERR(fpga->clear_gpio))
++		return PTR_ERR(fpga->clear_gpio);
++
++	fpga->strobe_gpio = devm_gpiod_get(fpga->dev, "strobe", GPIOD_OUT_LOW);
++	if (IS_ERR(fpga->strobe_gpio))
++		return PTR_ERR(fpga->strobe_gpio);
++
++	fpga->datain_gpio = devm_gpiod_get(fpga->dev, "datain", GPIOD_OUT_LOW);
++	if (IS_ERR(fpga->datain_gpio))
++		return PTR_ERR(fpga->datain_gpio);
++
++	fpga->dataout_gpio = devm_gpiod_get(fpga->dev, "dataout", GPIOD_IN);
++	if (IS_ERR(fpga->dataout_gpio))
++		return PTR_ERR(fpga->dataout_gpio);
++
++	/* The SoC pinctrl driver may not support reserving the GPIO line for
++	 * FPGA reset without causing an undesired reset pulse. This will clear
++	 * any settings on the FPGA, so only do it if we must.
++	 */
++	if (fpga->uninitialised) {
++		fpga->reset_gpio = devm_gpiod_get(fpga->dev, "reset",
++						  GPIOD_OUT_LOW);
++		if (IS_ERR(fpga->reset_gpio))
++			return PTR_ERR(fpga->reset_gpio);
++
++		gpiod_set_value(fpga->reset_gpio, 1);
++	}
++
++	gpiod_set_value(fpga->enable_gpio, 1);
++	fpga->uninitialised = false;
++
++	return 0;
++}
++
++static int __init upboard_fpga_detect_firmware(struct upboard_fpga *fpga)
++{
++	const unsigned int AAEON_MANUFACTURER_ID = 0x01;
++	const unsigned int SUPPORTED_FW_MAJOR = 0x0;
++	unsigned int platform_id, manufacturer_id;
++	unsigned int firmware_id, build, major, minor, patch;
++	int ret;
++
++	ret = regmap_read(fpga->regmap, UPFPGA_REG_PLATFORM_ID, &platform_id);
++	if (ret)
++		return ret;
++
++	manufacturer_id = platform_id & 0xff;
++	if (manufacturer_id != AAEON_MANUFACTURER_ID) {
++		dev_dbg(fpga->dev,
++			"driver not compatible with custom FPGA FW from manufacturer id 0x%02x. Exiting",
++			manufacturer_id);
++		return -ENODEV;
++	}
++
++	ret = regmap_read(fpga->regmap, UPFPGA_REG_FIRMWARE_ID, &firmware_id);
++	if (ret)
++		return ret;
++
++	build = (firmware_id >> 12) & 0xf;
++	major = (firmware_id >> 8) & 0xf;
++	minor = (firmware_id >> 4) & 0xf;
++	patch = firmware_id & 0xf;
++	if (major != SUPPORTED_FW_MAJOR) {
++		dev_dbg(fpga->dev, "unsupported FPGA FW v%u.%u.%u build 0x%02x",
++			major, minor, patch, build);
++		return -ENODEV;
++	}
++
++	dev_info(fpga->dev, "compatible FPGA FW v%u.%u.%u build 0x%02x",
++		 major, minor, patch, build);
++	return 0;
++}
++
++static const struct acpi_device_id upboard_fpga_acpi_match[] = {
++	{ "AANT0F00", (kernel_ulong_t) &upboard_up_fpga_data },
++	{ "AANT0F01", (kernel_ulong_t) &upboard_up2_fpga_data },
++	{ },
++};
++MODULE_DEVICE_TABLE(acpi, upboard_fpga_acpi_match);
++
++#define UPFPGA_QUIRK_UNINITIALISED  BIT(0)
++#define UPFPGA_QUIRK_HRV1_IS_PROTO2 BIT(1)
++
++static const struct dmi_system_id upboard_dmi_table[] __initconst = {
++	{
++		.matches = { /* UP */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
++		},
++		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
++	},
++	{
++		.matches = { /* UP2 */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-APL01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.3"),
++		},
++		.driver_data = (void *)(UPFPGA_QUIRK_UNINITIALISED |
++			UPFPGA_QUIRK_HRV1_IS_PROTO2),
++	},
++	{
++		.matches = { /* UP2 */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-APL01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
++		},
++		.driver_data = (void *)UPFPGA_QUIRK_HRV1_IS_PROTO2,
++	},
++	{ },
++};
++
++#define UPFPGA_PROTOCOL_V2_HRV 2
++
++static int __init upboard_fpga_probe(struct platform_device *pdev)
++{
++	struct upboard_fpga *fpga;
++	const struct acpi_device_id *id;
++	const struct upboard_fpga_data *fpga_data;
++	const struct dmi_system_id *system_id;
++	acpi_handle handle;
++	acpi_status status;
++	unsigned long long hrv;
++	unsigned long quirks = 0;
++	int ret;
++
++	id = acpi_match_device(upboard_fpga_acpi_match, &pdev->dev);
++	if (!id)
++		return -ENODEV;
++
++	handle = ACPI_HANDLE(&pdev->dev);
++	status = acpi_evaluate_integer(handle, "_HRV", NULL, &hrv);
++	if (ACPI_FAILURE(status)) {
++		dev_err(&pdev->dev, "failed to get PCTL revision");
++		return -ENODEV;
++	}
++
++	system_id = dmi_first_match(upboard_dmi_table);
++	if (system_id)
++		quirks = (unsigned long)system_id->driver_data;
++
++	if (hrv == 1 && (quirks & UPFPGA_QUIRK_HRV1_IS_PROTO2))
++		hrv = UPFPGA_PROTOCOL_V2_HRV;
++
++	if (hrv != UPFPGA_PROTOCOL_V2_HRV) {
++		dev_dbg(&pdev->dev, "unsupported PCTL revision: %llu", hrv);
++		return -ENODEV;
++	}
++
++	fpga_data = (const struct upboard_fpga_data *) id->driver_data;
++
++	fpga = devm_kzalloc(&pdev->dev, sizeof(*fpga), GFP_KERNEL);
++	if (!fpga)
++		return -ENOMEM;
++
++	if (quirks & UPFPGA_QUIRK_UNINITIALISED) {
++		dev_info(&pdev->dev, "FPGA not initialised by this BIOS");
++		fpga->uninitialised = true;
++	}
++
++	dev_set_drvdata(&pdev->dev, fpga);
++	fpga->dev = &pdev->dev;
++	fpga->regmap = devm_regmap_init(&pdev->dev, NULL, fpga,
++					fpga_data->regmapconf);
++	if (IS_ERR(fpga->regmap))
++		return PTR_ERR(fpga->regmap);
++
++	ret = upboard_fpga_gpio_init(fpga);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to init FPGA comm GPIOs: %d", ret);
++		return ret;
++	}
++
++	ret = upboard_fpga_detect_firmware(fpga);
++	if (ret)
++		return ret;
++
++	return devm_mfd_add_devices(&pdev->dev, 0, fpga_data->cells,
++				    fpga_data->ncells, NULL, 0, NULL);
++}
++
++static struct platform_driver upboard_fpga_driver = {
++	.driver = {
++		.name = "upboard-fpga",
++		.acpi_match_table = upboard_fpga_acpi_match,
++	},
++};
++
++module_platform_driver_probe(upboard_fpga_driver, upboard_fpga_probe);
++
++MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
++MODULE_DESCRIPTION("UP Board FPGA driver");
++MODULE_LICENSE("GPL v2");
+\ No newline at end of file
+diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
+index b5c969f9aa83..385b2934da60 100644
+--- a/drivers/pinctrl/Kconfig
++++ b/drivers/pinctrl/Kconfig
+@@ -372,6 +372,18 @@ config PINCTRL_RK805
+ 	help
+ 	  This selects the pinctrl driver for RK805.
+ 
++config PINCTRL_UPBOARD
++	tristate "UP board FPGA pin controller"
++	depends on ACPI
++	depends on MFD_UPBOARD_FPGA
++	select GENERIC_PINCONF
++	select PINMUX
++	select PINCONF
++	help
++	  Pin controller for the FPGA GPIO lines on UP boards. Due to the
++	  hardware layout, these are meant to be controlled in tandem with their
++	  corresponding Intel SoC GPIOs.
++
+ config PINCTRL_OCELOT
+ 	bool "Pinctrl driver for the Microsemi Ocelot and Jaguar2 SoCs"
+ 	depends on OF
+diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
+index 0847b710af6b..85fe0d9c02e1 100644
+--- a/drivers/pinctrl/Makefile
++++ b/drivers/pinctrl/Makefile
+@@ -45,6 +45,7 @@ obj-$(CONFIG_PINCTRL_STMFX) 	+= pinctrl-stmfx.o
+ obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
+ obj-$(CONFIG_PINCTRL_INGENIC)	+= pinctrl-ingenic.o
+ obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
++obj-$(CONFIG_PINCTRL_UPBOARD)	+= pinctrl-upboard.o
+ obj-$(CONFIG_PINCTRL_OCELOT)	+= pinctrl-ocelot.o
+ obj-$(CONFIG_PINCTRL_KEEMBAY)	+= pinctrl-keembay.o
+ 
+diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
+new file mode 100644
+index 000000000000..64899e988bb5
+--- /dev/null
++++ b/drivers/pinctrl/pinctrl-upboard.c
+@@ -0,0 +1,797 @@
++/*
++ * UP Board FPGA-based pin controller driver
++ *
++ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
++ *
++ * Authors: Javier Arteaga <javier@emutex.com>
++ *          Dan O'Donovan <dan@emutex.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/acpi.h>
++#include <linux/dmi.h>
++#include <linux/gpio.h>
++#include <linux/gpio/consumer.h>
++#include <linux/gpio/driver.h>
++#include <linux/kernel.h>
++#include <linux/mfd/upboard-fpga.h>
++#include <linux/module.h>
++#include <linux/pinctrl/pinctrl.h>
++#include <linux/pinctrl/pinmux.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/string.h>
++
++#include "core.h"
++
++struct upboard_pin {
++	struct regmap_field *funcbit;
++	struct regmap_field *enbit;
++	struct regmap_field *dirbit;
++};
++
++struct upboard_bios {
++	const struct reg_sequence *patches;
++	size_t npatches;
++};
++
++struct upboard_pinctrl {
++	struct device *dev;
++	struct pinctrl_dev *pctldev;
++	struct regmap *regmap;
++	struct gpio_chip chip;
++	const unsigned int *rpi_mapping;
++};
++
++enum upboard_func0_fpgabit {
++	UPFPGA_I2C0_EN = 8,
++	UPFPGA_I2C1_EN = 9,
++	UPFPGA_CEC0_EN = 12,
++	UPFPGA_ADC0_EN = 14,
++};
++
++static const struct reg_field upboard_i2c0_reg =
++	REG_FIELD(UPFPGA_REG_FUNC_EN0, UPFPGA_I2C0_EN, UPFPGA_I2C0_EN);
++
++static const struct reg_field upboard_i2c1_reg =
++	REG_FIELD(UPFPGA_REG_FUNC_EN0, UPFPGA_I2C1_EN, UPFPGA_I2C1_EN);
++
++static const struct reg_field upboard_adc0_reg =
++	REG_FIELD(UPFPGA_REG_FUNC_EN0, UPFPGA_ADC0_EN, UPFPGA_ADC0_EN);
++
++#define UPBOARD_BIT_TO_PIN(r, bit) \
++	((r) * UPFPGA_REGISTER_SIZE + (bit))
++
++/*
++ * UP board data
++ */
++
++#define UPBOARD_UP_BIT_TO_PIN(r, id) (UPBOARD_BIT_TO_PIN(r, UPFPGA_UP_##id))
++
++#define UPBOARD_UP_PIN_ANON(r, bit)					\
++	{								\
++		.number = UPBOARD_BIT_TO_PIN(r, bit),			\
++	}
++
++#define UPBOARD_UP_PIN_NAME(r, id)					\
++	{								\
++		.number = UPBOARD_UP_BIT_TO_PIN(r, id),			\
++		.name = #id,						\
++	}
++
++#define UPBOARD_UP_PIN_FUNC(r, id, data)				\
++	{								\
++		.number = UPBOARD_UP_BIT_TO_PIN(r, id),			\
++		.name = #id,						\
++		.drv_data = (void *)(data),				\
++	}
++
++enum upboard_up_reg1_fpgabit {
++	UPFPGA_UP_I2C1_SDA,
++	UPFPGA_UP_I2C1_SCL,
++	UPFPGA_UP_ADC0,
++	UPFPGA_UP_GPIO17,
++	UPFPGA_UP_GPIO27,
++	UPFPGA_UP_GPIO22,
++	UPFPGA_UP_SPI_MOSI,
++	UPFPGA_UP_SPI_MISO,
++	UPFPGA_UP_SPI_CLK,
++	UPFPGA_UP_I2C0_SDA,
++	UPFPGA_UP_GPIO5,
++	UPFPGA_UP_GPIO6,
++	UPFPGA_UP_PWM1,
++	UPFPGA_UP_I2S_FRM,
++	UPFPGA_UP_GPIO26,
++	UPFPGA_UP_UART1_TX,
++};
++
++enum upboard_up_reg2_fpgabit {
++	UPFPGA_UP_UART1_RX,
++	UPFPGA_UP_I2S_CLK,
++	UPFPGA_UP_GPIO23,
++	UPFPGA_UP_GPIO24,
++	UPFPGA_UP_GPIO25,
++	UPFPGA_UP_SPI_CS0,
++	UPFPGA_UP_SPI_CS1,
++	UPFPGA_UP_I2C0_SCL,
++	UPFPGA_UP_PWM0,
++	UPFPGA_UP_GPIO16,
++	UPFPGA_UP_I2S_DIN,
++	UPFPGA_UP_I2S_DOUT,
++};
++
++static struct pinctrl_pin_desc upboard_up_pins[] = {
++	UPBOARD_UP_PIN_FUNC(0, I2C1_SDA, &upboard_i2c1_reg),
++	UPBOARD_UP_PIN_FUNC(0, I2C1_SCL, &upboard_i2c1_reg),
++	UPBOARD_UP_PIN_FUNC(0, ADC0, &upboard_adc0_reg),
++	UPBOARD_UP_PIN_NAME(0, GPIO17),
++	UPBOARD_UP_PIN_NAME(0, GPIO27),
++	UPBOARD_UP_PIN_NAME(0, GPIO22),
++	UPBOARD_UP_PIN_NAME(0, SPI_MOSI),
++	UPBOARD_UP_PIN_NAME(0, SPI_MISO),
++	UPBOARD_UP_PIN_NAME(0, SPI_CLK),
++	UPBOARD_UP_PIN_FUNC(0, I2C0_SDA, &upboard_i2c0_reg),
++	UPBOARD_UP_PIN_NAME(0, GPIO5),
++	UPBOARD_UP_PIN_NAME(0, GPIO6),
++	UPBOARD_UP_PIN_NAME(0, PWM1),
++	UPBOARD_UP_PIN_NAME(0, I2S_FRM),
++	UPBOARD_UP_PIN_NAME(0, GPIO26),
++	UPBOARD_UP_PIN_NAME(0, UART1_TX),
++	/* register 1 */
++	UPBOARD_UP_PIN_NAME(1, UART1_RX),
++	UPBOARD_UP_PIN_NAME(1, I2S_CLK),
++	UPBOARD_UP_PIN_NAME(1, GPIO23),
++	UPBOARD_UP_PIN_NAME(1, GPIO24),
++	UPBOARD_UP_PIN_NAME(1, GPIO25),
++	UPBOARD_UP_PIN_NAME(1, SPI_CS0),
++	UPBOARD_UP_PIN_NAME(1, SPI_CS1),
++	UPBOARD_UP_PIN_FUNC(1, I2C0_SCL, &upboard_i2c0_reg),
++	UPBOARD_UP_PIN_NAME(1, PWM0),
++	UPBOARD_UP_PIN_NAME(1, GPIO16),
++	UPBOARD_UP_PIN_NAME(1, I2S_DIN),
++	UPBOARD_UP_PIN_NAME(1, I2S_DOUT),
++};
++
++static const unsigned int upboard_up_rpi_mapping[] = {
++	UPBOARD_UP_BIT_TO_PIN(0, I2C0_SDA),
++	UPBOARD_UP_BIT_TO_PIN(1, I2C0_SCL),
++	UPBOARD_UP_BIT_TO_PIN(0, I2C1_SDA),
++	UPBOARD_UP_BIT_TO_PIN(0, I2C1_SCL),
++	UPBOARD_UP_BIT_TO_PIN(0, ADC0),
++	UPBOARD_UP_BIT_TO_PIN(0, GPIO5),
++	UPBOARD_UP_BIT_TO_PIN(0, GPIO6),
++	UPBOARD_UP_BIT_TO_PIN(1, SPI_CS1),
++	UPBOARD_UP_BIT_TO_PIN(1, SPI_CS0),
++	UPBOARD_UP_BIT_TO_PIN(0, SPI_MISO),
++	UPBOARD_UP_BIT_TO_PIN(0, SPI_MOSI),
++	UPBOARD_UP_BIT_TO_PIN(0, SPI_CLK),
++	UPBOARD_UP_BIT_TO_PIN(1, PWM0),
++	UPBOARD_UP_BIT_TO_PIN(0, PWM1),
++	UPBOARD_UP_BIT_TO_PIN(0, UART1_TX),
++	UPBOARD_UP_BIT_TO_PIN(1, UART1_RX),
++	UPBOARD_UP_BIT_TO_PIN(1, GPIO16),
++	UPBOARD_UP_BIT_TO_PIN(0, GPIO17),
++	UPBOARD_UP_BIT_TO_PIN(1, I2S_CLK),
++	UPBOARD_UP_BIT_TO_PIN(0, I2S_FRM),
++	UPBOARD_UP_BIT_TO_PIN(1, I2S_DIN),
++	UPBOARD_UP_BIT_TO_PIN(1, I2S_DOUT),
++	UPBOARD_UP_BIT_TO_PIN(0, GPIO22),
++	UPBOARD_UP_BIT_TO_PIN(1, GPIO23),
++	UPBOARD_UP_BIT_TO_PIN(1, GPIO24),
++	UPBOARD_UP_BIT_TO_PIN(1, GPIO25),
++	UPBOARD_UP_BIT_TO_PIN(0, GPIO26),
++	UPBOARD_UP_BIT_TO_PIN(0, GPIO27),
++};
++
++/*
++ * Init patches applied to the registers until the BIOS sets proper defaults
++ */
++static const struct reg_sequence upboard_up_reg_patches[] __initconst = {
++	{ UPFPGA_REG_FUNC_EN0,
++		// enable I2C voltage-level shifters
++		BIT(UPFPGA_I2C0_EN) |
++		BIT(UPFPGA_I2C1_EN) |
++		// enable adc
++		BIT(UPFPGA_ADC0_EN)
++	},
++	/* HAT function pins initially set as inputs */
++	{ UPFPGA_REG_GPIO_DIR0,
++		BIT(UPFPGA_UP_I2C1_SDA)	    |
++		BIT(UPFPGA_UP_I2C1_SCL)	    |
++		BIT(UPFPGA_UP_ADC0)	    |
++		BIT(UPFPGA_UP_GPIO17)	    |
++		BIT(UPFPGA_UP_GPIO27)	    |
++		BIT(UPFPGA_UP_GPIO22)	    |
++		BIT(UPFPGA_UP_SPI_MISO)	    |
++		BIT(UPFPGA_UP_I2C0_SDA)	    |
++		BIT(UPFPGA_UP_GPIO5)	    |
++		BIT(UPFPGA_UP_GPIO6)	    |
++		BIT(UPFPGA_UP_GPIO26)
++	},
++	{ UPFPGA_REG_GPIO_DIR1,
++		BIT(UPFPGA_UP_UART1_RX)	|
++		BIT(UPFPGA_UP_GPIO23)	|
++		BIT(UPFPGA_UP_GPIO24)	|
++		BIT(UPFPGA_UP_GPIO25)	|
++		BIT(UPFPGA_UP_I2C0_SCL)	|
++		BIT(UPFPGA_UP_GPIO16)	|
++		BIT(UPFPGA_UP_I2S_DIN)
++	},
++};
++
++static const struct upboard_bios upboard_up_bios_info_dvt __initconst = {
++	.patches = upboard_up_reg_patches,
++	.npatches = ARRAY_SIZE(upboard_up_reg_patches),
++};
++
++/*
++ * UP^2 board data
++ */
++
++#define UPBOARD_UP2_BIT_TO_PIN(r, id) (UPBOARD_BIT_TO_PIN(r, UPFPGA_UP2_##id))
++
++#define UPBOARD_UP2_PIN_ANON(r, bit)					\
++	{								\
++		.number = UPBOARD_BIT_TO_PIN(r, bit),			\
++	}
++
++#define UPBOARD_UP2_PIN_NAME(r, id)					\
++	{								\
++		.number = UPBOARD_UP2_BIT_TO_PIN(r, id),		\
++		.name = #id,						\
++	}
++
++#define UPBOARD_UP2_PIN_FUNC(r, id, data)				\
++	{								\
++		.number = UPBOARD_UP2_BIT_TO_PIN(r, id),		\
++		.name = #id,						\
++		.drv_data = (void *)(data),				\
++	}
++
++enum upboard_up2_reg0_fpgabit {
++	UPFPGA_UP2_UART1_TXD,
++	UPFPGA_UP2_UART1_RXD,
++	UPFPGA_UP2_UART1_RTS,
++	UPFPGA_UP2_UART1_CTS,
++	UPFPGA_UP2_GPIO3,
++	UPFPGA_UP2_GPIO5,
++	UPFPGA_UP2_GPIO6,
++	UPFPGA_UP2_GPIO11,
++	UPFPGA_UP2_EXHAT_LVDS1n,
++	UPFPGA_UP2_EXHAT_LVDS1p,
++	UPFPGA_UP2_SPI2_TXD,
++	UPFPGA_UP2_SPI2_RXD,
++	UPFPGA_UP2_SPI2_FS1,
++	UPFPGA_UP2_SPI2_FS0,
++	UPFPGA_UP2_SPI2_CLK,
++	UPFPGA_UP2_SPI1_TXD,
++};
++
++enum upboard_up2_reg1_fpgabit {
++	UPFPGA_UP2_SPI1_RXD,
++	UPFPGA_UP2_SPI1_FS1,
++	UPFPGA_UP2_SPI1_FS0,
++	UPFPGA_UP2_SPI1_CLK,
++	UPFPGA_UP2_BIT20,
++	UPFPGA_UP2_BIT21,
++	UPFPGA_UP2_BIT22,
++	UPFPGA_UP2_BIT23,
++	UPFPGA_UP2_PWM1,
++	UPFPGA_UP2_PWM0,
++	UPFPGA_UP2_EXHAT_LVDS0n,
++	UPFPGA_UP2_EXHAT_LVDS0p,
++	UPFPGA_UP2_I2C0_SCL,
++	UPFPGA_UP2_I2C0_SDA,
++	UPFPGA_UP2_I2C1_SCL,
++	UPFPGA_UP2_I2C1_SDA,
++};
++
++enum upboard_up2_reg2_fpgabit {
++	UPFPGA_UP2_EXHAT_LVDS3n,
++	UPFPGA_UP2_EXHAT_LVDS3p,
++	UPFPGA_UP2_EXHAT_LVDS4n,
++	UPFPGA_UP2_EXHAT_LVDS4p,
++	UPFPGA_UP2_EXHAT_LVDS5n,
++	UPFPGA_UP2_EXHAT_LVDS5p,
++	UPFPGA_UP2_I2S_SDO,
++	UPFPGA_UP2_I2S_SDI,
++	UPFPGA_UP2_I2S_WS_SYNC,
++	UPFPGA_UP2_I2S_BCLK,
++	UPFPGA_UP2_EXHAT_LVDS6n,
++	UPFPGA_UP2_EXHAT_LVDS6p,
++	UPFPGA_UP2_EXHAT_LVDS7n,
++	UPFPGA_UP2_EXHAT_LVDS7p,
++	UPFPGA_UP2_EXHAT_LVDS2n,
++	UPFPGA_UP2_EXHAT_LVDS2p,
++};
++
++static struct pinctrl_pin_desc upboard_up2_pins[] = {
++	UPBOARD_UP2_PIN_NAME(0, UART1_TXD),
++	UPBOARD_UP2_PIN_NAME(0, UART1_RXD),
++	UPBOARD_UP2_PIN_NAME(0, UART1_RTS),
++	UPBOARD_UP2_PIN_NAME(0, UART1_CTS),
++	UPBOARD_UP2_PIN_NAME(0, GPIO3),
++	UPBOARD_UP2_PIN_NAME(0, GPIO5),
++	UPBOARD_UP2_PIN_NAME(0, GPIO6),
++	UPBOARD_UP2_PIN_NAME(0, GPIO11),
++	UPBOARD_UP2_PIN_NAME(0, EXHAT_LVDS1n),
++	UPBOARD_UP2_PIN_NAME(0, EXHAT_LVDS1p),
++	UPBOARD_UP2_PIN_NAME(0, SPI2_TXD),
++	UPBOARD_UP2_PIN_NAME(0, SPI2_RXD),
++	UPBOARD_UP2_PIN_NAME(0, SPI2_FS1),
++	UPBOARD_UP2_PIN_NAME(0, SPI2_FS0),
++	UPBOARD_UP2_PIN_NAME(0, SPI2_CLK),
++	UPBOARD_UP2_PIN_NAME(0, SPI1_TXD),
++	UPBOARD_UP2_PIN_NAME(1, SPI1_RXD),
++	UPBOARD_UP2_PIN_NAME(1, SPI1_FS1),
++	UPBOARD_UP2_PIN_NAME(1, SPI1_FS0),
++	UPBOARD_UP2_PIN_NAME(1, SPI1_CLK),
++	UPBOARD_UP2_PIN_ANON(1, 4),
++	UPBOARD_UP2_PIN_ANON(1, 5),
++	UPBOARD_UP2_PIN_ANON(1, 6),
++	UPBOARD_UP2_PIN_ANON(1, 7),
++	UPBOARD_UP2_PIN_NAME(1, PWM1),
++	UPBOARD_UP2_PIN_NAME(1, PWM0),
++	UPBOARD_UP2_PIN_NAME(1, EXHAT_LVDS0n),
++	UPBOARD_UP2_PIN_NAME(1, EXHAT_LVDS0p),
++	UPBOARD_UP2_PIN_FUNC(1, I2C0_SCL, &upboard_i2c0_reg),
++	UPBOARD_UP2_PIN_FUNC(1, I2C0_SDA, &upboard_i2c0_reg),
++	UPBOARD_UP2_PIN_FUNC(1, I2C1_SCL, &upboard_i2c1_reg),
++	UPBOARD_UP2_PIN_FUNC(1, I2C1_SDA, &upboard_i2c1_reg),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS3n),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS3p),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS4n),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS4p),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS5n),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS5p),
++	UPBOARD_UP2_PIN_NAME(2, I2S_SDO),
++	UPBOARD_UP2_PIN_NAME(2, I2S_SDI),
++	UPBOARD_UP2_PIN_NAME(2, I2S_WS_SYNC),
++	UPBOARD_UP2_PIN_NAME(2, I2S_BCLK),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS6n),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS6p),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS7n),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS7p),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS2n),
++	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS2p),
++};
++
++static const unsigned int upboard_up2_rpi_mapping[] = {
++	UPBOARD_UP2_BIT_TO_PIN(1, I2C0_SDA),
++	UPBOARD_UP2_BIT_TO_PIN(1, I2C0_SCL),
++	UPBOARD_UP2_BIT_TO_PIN(1, I2C1_SDA),
++	UPBOARD_UP2_BIT_TO_PIN(1, I2C1_SCL),
++	UPBOARD_UP2_BIT_TO_PIN(0, GPIO3),
++	UPBOARD_UP2_BIT_TO_PIN(0, GPIO11),
++	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_CLK),
++	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_FS1),
++	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_FS0),
++	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_RXD),
++	UPBOARD_UP2_BIT_TO_PIN(0, SPI1_TXD),
++	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_CLK),
++	UPBOARD_UP2_BIT_TO_PIN(1, PWM0),
++	UPBOARD_UP2_BIT_TO_PIN(1, PWM1),
++	UPBOARD_UP2_BIT_TO_PIN(0, UART1_TXD),
++	UPBOARD_UP2_BIT_TO_PIN(0, UART1_RXD),
++	UPBOARD_UP2_BIT_TO_PIN(0, UART1_CTS),
++	UPBOARD_UP2_BIT_TO_PIN(0, UART1_RTS),
++	UPBOARD_UP2_BIT_TO_PIN(2, I2S_BCLK),
++	UPBOARD_UP2_BIT_TO_PIN(2, I2S_WS_SYNC),
++	UPBOARD_UP2_BIT_TO_PIN(2, I2S_SDI),
++	UPBOARD_UP2_BIT_TO_PIN(2, I2S_SDO),
++	UPBOARD_UP2_BIT_TO_PIN(0, GPIO6),
++	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_FS1),
++	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_RXD),
++	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_TXD),
++	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_FS0),
++	UPBOARD_UP2_BIT_TO_PIN(0, GPIO5),
++};
++
++/*
++ * Init patches applied to the registers until the BIOS sets proper defaults
++ */
++static const struct reg_sequence upboard_up2_reg_patches[] __initconst = {
++	// enable I2C voltage-level shifters
++	{ UPFPGA_REG_FUNC_EN0,
++		BIT(UPFPGA_I2C0_EN) |
++		BIT(UPFPGA_I2C1_EN)
++	},
++	// HAT function pins initially set as inputs
++	{ UPFPGA_REG_GPIO_DIR0,
++		BIT(UPFPGA_UP2_UART1_RXD) |
++		BIT(UPFPGA_UP2_UART1_CTS)
++	},
++	{ UPFPGA_REG_GPIO_DIR1,
++		BIT(UPFPGA_UP2_SPI1_RXD)
++	},
++	// HAT function pins initially enabled (i.e. not hi-Z)
++	{ UPFPGA_REG_GPIO_EN0,
++		BIT(UPFPGA_UP2_UART1_TXD) |
++		BIT(UPFPGA_UP2_UART1_RXD) |
++		BIT(UPFPGA_UP2_UART1_RTS) |
++		BIT(UPFPGA_UP2_UART1_CTS) |
++		BIT(UPFPGA_UP2_SPI1_TXD)
++	},
++	{ UPFPGA_REG_GPIO_EN1,
++		BIT(UPFPGA_UP2_SPI1_RXD) |
++		BIT(UPFPGA_UP2_SPI1_FS1) |
++		BIT(UPFPGA_UP2_SPI1_FS0) |
++		BIT(UPFPGA_UP2_SPI1_CLK) |
++		BIT(UPFPGA_UP2_PWM1) |
++		BIT(UPFPGA_UP2_PWM0)
++	},
++};
++
++static const struct upboard_bios upboard_up2_bios_info_v0_3 __initconst = {
++	.patches = upboard_up2_reg_patches,
++	.npatches = ARRAY_SIZE(upboard_up2_reg_patches),
++};
++
++static int upboard_set_mux(struct pinctrl_dev *pctldev, unsigned int function,
++			   unsigned int group)
++{
++	return 0;
++};
++
++static int upboard_gpio_request_enable(struct pinctrl_dev *pctldev,
++				       struct pinctrl_gpio_range *range,
++				       unsigned int pin)
++{
++	const struct pin_desc * const pd = pin_desc_get(pctldev, pin);
++	const struct upboard_pin *p;
++	int ret;
++
++	if (!pd)
++		return -EINVAL;
++	p = pd->drv_data;
++
++	if (p->funcbit) {
++		ret = regmap_field_write(p->funcbit, 0);
++		if (ret)
++			return ret;
++	}
++
++	if (p->enbit) {
++		ret = regmap_field_write(p->enbit, 1);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++};
++
++static int upboard_gpio_set_direction(struct pinctrl_dev *pctldev,
++				      struct pinctrl_gpio_range *range,
++				      unsigned int pin, bool input)
++{
++	const struct pin_desc * const pd = pin_desc_get(pctldev, pin);
++	const struct upboard_pin *p;
++
++	if (!pd)
++		return -EINVAL;
++	p = pd->drv_data;
++
++	return regmap_field_write(p->dirbit, input);
++};
++
++static int upboard_get_functions_count(struct pinctrl_dev *pctldev)
++{
++	return 0;
++}
++
++static const char *upboard_get_function_name(struct pinctrl_dev *pctldev,
++				     unsigned int selector)
++{
++	return NULL;
++}
++
++static int upboard_get_function_groups(struct pinctrl_dev *pctldev,
++			       unsigned int selector,
++			       const char * const **groups,
++			       unsigned int *num_groups)
++{
++	*groups = NULL;
++	*num_groups = 0;
++	return 0;
++}
++
++static const struct pinmux_ops upboard_pinmux_ops = {
++	.get_functions_count = upboard_get_functions_count,
++	.get_function_groups = upboard_get_function_groups,
++	.get_function_name = upboard_get_function_name,
++	.set_mux = upboard_set_mux,
++	.gpio_request_enable = upboard_gpio_request_enable,
++	.gpio_set_direction = upboard_gpio_set_direction,
++};
++
++static int upboard_get_groups_count(struct pinctrl_dev *pctldev)
++{
++	return 0;
++}
++
++static const char *upboard_get_group_name(struct pinctrl_dev *pctldev,
++					  unsigned int selector)
++{
++	return NULL;
++}
++
++static const struct pinctrl_ops upboard_pinctrl_ops = {
++	.get_groups_count = upboard_get_groups_count,
++	.get_group_name = upboard_get_group_name,
++};
++
++static struct pinctrl_desc upboard_up_pinctrl_desc = {
++	.pins = upboard_up_pins,
++	.npins = ARRAY_SIZE(upboard_up_pins),
++	.pctlops = &upboard_pinctrl_ops,
++	.pmxops = &upboard_pinmux_ops,
++	.owner = THIS_MODULE,
++};
++
++static struct pinctrl_desc upboard_up2_pinctrl_desc = {
++	.pins = upboard_up2_pins,
++	.npins = ARRAY_SIZE(upboard_up2_pins),
++	.pctlops = &upboard_pinctrl_ops,
++	.pmxops = &upboard_pinmux_ops,
++	.owner = THIS_MODULE,
++};
++
++static int upboard_rpi_to_native_gpio(struct gpio_chip *gc, unsigned int gpio)
++{
++	struct upboard_pinctrl *pctrl =
++		container_of(gc, struct upboard_pinctrl, chip);
++	unsigned int pin = pctrl->rpi_mapping[gpio];
++	struct pinctrl_gpio_range *range =
++		pinctrl_find_gpio_range_from_pin(pctrl->pctldev, pin);
++
++	if (!range)
++		return -ENODEV;
++
++	return range->base;
++}
++
++static int upboard_gpio_request(struct gpio_chip *gc, unsigned int offset)
++{
++	int gpio = upboard_rpi_to_native_gpio(gc, offset);
++
++	if (gpio < 0)
++		return gpio;
++
++	return gpio_request(gpio, module_name(THIS_MODULE));
++}
++
++static void upboard_gpio_free(struct gpio_chip *gc, unsigned int offset)
++{
++	int gpio = upboard_rpi_to_native_gpio(gc, offset);
++
++	if (gpio < 0)
++		return;
++
++	gpio_free(gpio);
++}
++
++static int upboard_gpio_get(struct gpio_chip *gc, unsigned int offset)
++{
++	int gpio = upboard_rpi_to_native_gpio(gc, offset);
++
++	if (gpio < 0)
++		return gpio;
++
++	return gpio_get_value(gpio);
++}
++
++static void upboard_gpio_set(struct gpio_chip *gc, unsigned int offset, int
++			     value)
++{
++	int gpio = upboard_rpi_to_native_gpio(gc, offset);
++
++	if (gpio < 0)
++		return;
++
++	gpio_set_value(gpio, value);
++}
++
++static int upboard_gpio_direction_input(struct gpio_chip *gc,
++					unsigned int offset)
++{
++	int gpio = upboard_rpi_to_native_gpio(gc, offset);
++
++	if (gpio < 0)
++		return gpio;
++
++	return gpio_direction_input(gpio);
++}
++
++static int upboard_gpio_direction_output(struct gpio_chip *gc,
++					 unsigned int offset, int value)
++{
++	int gpio = upboard_rpi_to_native_gpio(gc, offset);
++
++	if (gpio < 0)
++		return gpio;
++
++	return gpio_direction_output(gpio, value);
++}
++
++static struct gpio_chip upboard_gpio_chip = {
++	.label = "Raspberry Pi compatible UP GPIO",
++	.base = 0,
++	.ngpio = ARRAY_SIZE(upboard_up_rpi_mapping),
++	.request = upboard_gpio_request,
++	.free = upboard_gpio_free,
++	.get = upboard_gpio_get,
++	.set = upboard_gpio_set,
++	.direction_input = upboard_gpio_direction_input,
++	.direction_output = upboard_gpio_direction_output,
++	.owner = THIS_MODULE,
++};
++
++/* DMI Matches for older bios without fpga initialization */
++static const struct dmi_system_id upboard_dmi_table[] __initconst = {
++	{
++		.matches = { /* UP */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
++		},
++		.driver_data = (void *)&upboard_up_bios_info_dvt,
++	},
++	{
++		.matches = { /* UP2 */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-APL01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.3"),
++		},
++		.driver_data = (void *)&upboard_up2_bios_info_v0_3,
++	},
++	{ },
++};
++
++static int __init upboard_pinctrl_probe(struct platform_device *pdev)
++{
++	struct upboard_fpga * const fpga = dev_get_drvdata(pdev->dev.parent);
++	struct acpi_device * const adev = ACPI_COMPANION(&pdev->dev);
++	struct pinctrl_desc *pctldesc;
++	const struct upboard_bios *bios_info = NULL;
++	struct upboard_pinctrl *pctrl;
++	struct upboard_pin *pins;
++	const struct dmi_system_id *system_id;
++	const char *hid;
++	const unsigned int *rpi_mapping;
++	int ret;
++	int i;
++
++	if (!fpga)
++		return -EINVAL;
++
++	if (!adev)
++		return -ENODEV;
++
++	hid = acpi_device_hid(adev);
++	if (!strcmp(hid, "AANT0F00")) {
++		pctldesc = &upboard_up_pinctrl_desc;
++		rpi_mapping = upboard_up_rpi_mapping;
++	} else if (!strcmp(hid, "AANT0F01")) {
++		pctldesc = &upboard_up2_pinctrl_desc;
++		rpi_mapping = upboard_up2_rpi_mapping;
++	} else
++		return -ENODEV;
++
++	pctldesc->name = dev_name(&pdev->dev);
++
++	pins = devm_kzalloc(&pdev->dev,
++			    sizeof(*pins) * pctldesc->npins,
++			    GFP_KERNEL);
++	if (!pins)
++		return -ENOMEM;
++
++	/* initialise pins */
++	for (i = 0; i < pctldesc->npins; i++) {
++		struct upboard_pin *pin = &pins[i];
++		struct pinctrl_pin_desc *pd = (struct pinctrl_pin_desc *)
++			&pctldesc->pins[i];
++		struct reg_field fldconf = {0};
++		unsigned int regoff = (pd->number / UPFPGA_REGISTER_SIZE);
++		unsigned int lsb = pd->number % UPFPGA_REGISTER_SIZE;
++
++		pin->funcbit = NULL;
++		if (pd->drv_data) {
++			fldconf = *(struct reg_field *)pd->drv_data;
++			if (!regmap_writeable(fpga->regmap, fldconf.reg))
++				return -EINVAL;
++
++			pin->funcbit = devm_regmap_field_alloc(&pdev->dev,
++							       fpga->regmap,
++							       fldconf);
++			if (IS_ERR(pin->funcbit))
++				return PTR_ERR(pin->funcbit);
++		}
++
++		pin->enbit = NULL;
++		fldconf.reg = UPFPGA_REG_GPIO_EN0 + regoff;
++		fldconf.lsb = lsb;
++		fldconf.msb = lsb;
++
++		/* some platform don't have enable bit, ignore if not present */
++		if (regmap_writeable(fpga->regmap, fldconf.reg)) {
++			pin->enbit = devm_regmap_field_alloc(&pdev->dev,
++							     fpga->regmap,
++							     fldconf);
++			if (IS_ERR(pin->enbit))
++				return PTR_ERR(pin->enbit);
++		}
++
++		fldconf.reg = UPFPGA_REG_GPIO_DIR0 + regoff;
++		fldconf.lsb = lsb;
++		fldconf.msb = lsb;
++
++		if (!regmap_writeable(fpga->regmap, fldconf.reg))
++			return -EINVAL;
++
++		pin->dirbit = devm_regmap_field_alloc(&pdev->dev,
++						      fpga->regmap,
++						      fldconf);
++		if (IS_ERR(pin->dirbit))
++			return PTR_ERR(pin->dirbit);
++
++		pd->drv_data = pin;
++	}
++
++	/* create a new pinctrl device and register it */
++	pctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);
++	if (!pctrl)
++		return -ENOMEM;
++
++	pctrl->regmap = fpga->regmap;
++	pctrl->rpi_mapping = rpi_mapping;
++	pctrl->chip = upboard_gpio_chip;
++	pctrl->chip.parent = &pdev->dev;
++
++	ret = devm_gpiochip_add_data(&pdev->dev, &pctrl->chip, &pctrl->chip);
++	if (ret)
++		return ret;
++
++	pctrl->pctldev = devm_pinctrl_register(&pdev->dev, pctldesc, pctrl);
++	if (IS_ERR(pctrl->pctldev))
++		return PTR_ERR(pctrl->pctldev);
++
++	/* add acpi pin mapping according to external-gpios key */
++	ret = acpi_node_add_pin_mapping(acpi_fwnode_handle(adev),
++					"external-gpios",
++					dev_name(&pdev->dev),
++					0, UINT_MAX);
++	if (ret)
++		return ret;
++
++	/* check for special board versions that require register patches */
++	system_id = dmi_first_match(upboard_dmi_table);
++	if (system_id)
++		bios_info = system_id->driver_data;
++
++	if (bios_info && bios_info->patches) {
++		ret = regmap_register_patch(pctrl->regmap,
++					    bios_info->patches,
++					    bios_info->npatches);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++static struct platform_driver upboard_pinctrl_driver = {
++	.driver = {
++		.name = "upboard-pinctrl",
++	},
++};
++
++module_platform_driver_probe(upboard_pinctrl_driver, upboard_pinctrl_probe);
++
++MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
++MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
++MODULE_DESCRIPTION("UP Board HAT pin controller driver");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:upboard-pinctrl");
+\ No newline at end of file
+diff --git a/include/linux/mfd/upboard-fpga.h b/include/linux/mfd/upboard-fpga.h
+new file mode 100644
+index 000000000000..cd7fb812d3b2
+--- /dev/null
++++ b/include/linux/mfd/upboard-fpga.h
+@@ -0,0 +1,52 @@
++/*
++ * UP Board FPGA MFD driver interface
++ *
++ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
++ *
++ * Author: Javier Arteaga <javier@emutex.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef __LINUX_MFD_UPBOARD_FPGA_H
++#define __LINUX_MFD_UPBOARD_FPGA_H
++
++#define UPFPGA_ADDRESS_SIZE  7
++#define UPFPGA_REGISTER_SIZE 16
++
++#define UPFPGA_READ_FLAG     (1 << UPFPGA_ADDRESS_SIZE)
++
++enum upboard_fpgareg {
++	UPFPGA_REG_PLATFORM_ID   = 0x10,
++	UPFPGA_REG_FIRMWARE_ID   = 0x11,
++	UPFPGA_REG_FUNC_EN0      = 0x20,
++	UPFPGA_REG_FUNC_EN1      = 0x21,
++	UPFPGA_REG_GPIO_EN0      = 0x30,
++	UPFPGA_REG_GPIO_EN1      = 0x31,
++	UPFPGA_REG_GPIO_EN2      = 0x32,
++	UPFPGA_REG_GPIO_DIR0     = 0x40,
++	UPFPGA_REG_GPIO_DIR1     = 0x41,
++	UPFPGA_REG_GPIO_DIR2     = 0x42,
++	UPFPGA_REG_MAX,
++};
++
++struct upboard_fpga {
++	struct device *dev;
++	struct regmap *regmap;
++	struct gpio_desc *enable_gpio;
++	struct gpio_desc *reset_gpio;
++	struct gpio_desc *clear_gpio;
++	struct gpio_desc *strobe_gpio;
++	struct gpio_desc *datain_gpio;
++	struct gpio_desc *dataout_gpio;
++	bool uninitialised;
++};
++
++struct upboard_led_data {
++	unsigned int bit;
++	const char *colour;
++};
++
++#endif /*  __LINUX_MFD_UPBOARD_FPGA_H */
+\ No newline at end of file
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0006-mfd-Add-support-for-UP-board-CPLD-FPGA.patch b/recipes-kernel/linux/files/0006-mfd-Add-support-for-UP-board-CPLD-FPGA.patch
deleted file mode 100644
index dff4080..0000000
--- a/recipes-kernel/linux/files/0006-mfd-Add-support-for-UP-board-CPLD-FPGA.patch
+++ /dev/null
@@ -1,1514 +0,0 @@
-From bf2af81a5a93050a2b0b3feffac521c3ed177578 Mon Sep 17 00:00:00 2001
-From: Carlos Calderon <carlos@emutex.com>
-Date: Thu, 4 Oct 2018 10:40:49 +0100
-Subject: [PATCH 07/19] mfd: Add support for UP board CPLD/FPGA
-
-The UP Squared board <http://www.upboard.com> implements certain
-features (pin control, onboard LEDs or CEC) through an on-board FPGA.
-
-This mfd driver implements the line protocol to read and write registers
-from the FPGA through regmap. The register address map is also included.
-
-The UP boards come with a few FPGA-controlled onboard LEDs:
-* UP Board: yellow, green, red
-* UP Squared: blue, yellow, green, red
-
-The UP Boards provide a few I/O pin headers (for both GPIO and
-functions), including a 40-pin Raspberry Pi compatible header.
-
-This patch implements support for the FPGA-based pin controller that
-manages direction and enable state for those header pins.
-
-Signed-off-by: Javier Arteaga <javier@emutex.com>
-[merge various fixes]
-Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
----
- drivers/leds/Kconfig              |   7 +
- drivers/leds/Makefile             |   1 +
- drivers/leds/leds-upboard.c       |  88 +++++
- drivers/mfd/Kconfig               |   6 +
- drivers/mfd/Makefile              |   1 +
- drivers/mfd/upboard-fpga.c        | 411 ++++++++++++++++++++
- drivers/pinctrl/Kconfig           |  12 +
- drivers/pinctrl/Makefile          |   1 +
- drivers/pinctrl/pinctrl-upboard.c | 797 ++++++++++++++++++++++++++++++++++++++
- include/linux/mfd/upboard-fpga.h  |  52 +++
- 10 files changed, 1376 insertions(+)
- create mode 100644 drivers/leds/leds-upboard.c
- create mode 100644 drivers/mfd/upboard-fpga.c
- create mode 100644 drivers/pinctrl/pinctrl-upboard.c
- create mode 100644 include/linux/mfd/upboard-fpga.h
-
-diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
-index 44097a3..554a2d9 100644
---- a/drivers/leds/Kconfig
-+++ b/drivers/leds/Kconfig
-@@ -756,6 +756,13 @@ config LEDS_NIC78BX
- 	  To compile this driver as a module, choose M here: the module
- 	  will be called leds-nic78bx.
- 
-+config LEDS_UPBOARD
-+	tristate "LED support for the UP board"
-+	depends on LEDS_CLASS
-+	depends on MFD_UPBOARD_FPGA
-+	help
-+	  This option enables support for the UP board LEDs.
-+
- comment "LED Triggers"
- source "drivers/leds/trigger/Kconfig"
- 
-diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
-index 420b5d2..fe79d1e 100644
---- a/drivers/leds/Makefile
-+++ b/drivers/leds/Makefile
-@@ -75,6 +75,7 @@ obj-$(CONFIG_LEDS_MLXCPLD)		+= leds-mlxcpld.o
- obj-$(CONFIG_LEDS_MLXREG)		+= leds-mlxreg.o
- obj-$(CONFIG_LEDS_NIC78BX)		+= leds-nic78bx.o
- obj-$(CONFIG_LEDS_MT6323)		+= leds-mt6323.o
-+obj-$(CONFIG_LEDS_UPBOARD)		+= leds-upboard.o
- obj-$(CONFIG_LEDS_LM3692X)		+= leds-lm3692x.o
- obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
- obj-$(CONFIG_LEDS_LM3601X)		+= leds-lm3601x.o
-diff --git a/drivers/leds/leds-upboard.c b/drivers/leds/leds-upboard.c
-new file mode 100644
-index 0000000..16bd1b7
---- /dev/null
-+++ b/drivers/leds/leds-upboard.c
-@@ -0,0 +1,88 @@
-+/*
-+ * UP Board FPGA-based LED driver
-+ *
-+ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
-+ *
-+ * Author: Javier Arteaga <javier@emutex.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/leds.h>
-+#include <linux/mfd/upboard-fpga.h>
-+#include <linux/module.h>
-+#include <linux/platform_device.h>
-+#include <linux/regmap.h>
-+
-+struct upboard_led {
-+	struct regmap_field *field;
-+	struct led_classdev cdev;
-+};
-+
-+static enum led_brightness upboard_led_brightness_get(struct led_classdev
-+						      *cdev)
-+{
-+	struct upboard_led *led = container_of(cdev, struct upboard_led, cdev);
-+	int brightness = 0;
-+
-+	regmap_field_read(led->field, &brightness);
-+
-+	return brightness;
-+};
-+
-+static void upboard_led_brightness_set(struct led_classdev *cdev,
-+				       enum led_brightness brightness)
-+{
-+	struct upboard_led *led = container_of(cdev, struct upboard_led, cdev);
-+
-+	regmap_field_write(led->field, brightness != LED_OFF);
-+};
-+
-+static int __init upboard_led_probe(struct platform_device *pdev)
-+{
-+	struct upboard_fpga * const fpga = dev_get_drvdata(pdev->dev.parent);
-+	struct reg_field fldconf = {
-+		.reg = UPFPGA_REG_FUNC_EN0,
-+	};
-+	struct upboard_led_data * const pdata = pdev->dev.platform_data;
-+	struct upboard_led *led;
-+
-+	if (!fpga || !pdata)
-+		return -EINVAL;
-+
-+	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	fldconf.lsb = pdata->bit;
-+	fldconf.msb = pdata->bit;
-+	led->field = devm_regmap_field_alloc(&pdev->dev, fpga->regmap, fldconf);
-+	if (IS_ERR(led->field))
-+		return PTR_ERR(led->field);
-+
-+	led->cdev.brightness_get = upboard_led_brightness_get;
-+	led->cdev.brightness_set = upboard_led_brightness_set;
-+	led->cdev.name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "upboard:%s:",
-+					pdata->colour);
-+
-+	if (!led->cdev.name)
-+		return -ENOMEM;
-+
-+	return devm_led_classdev_register(&pdev->dev, &led->cdev);
-+};
-+
-+static struct platform_driver upboard_led_driver = {
-+	.driver = {
-+		.name = "upboard-led",
-+	},
-+};
-+
-+module_platform_driver_probe(upboard_led_driver, upboard_led_probe);
-+
-+MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
-+MODULE_DESCRIPTION("UP Board LED driver");
-+MODULE_LICENSE("GPL v2");
-+MODULE_ALIAS("platform:upboard-led");
-\ No newline at end of file
-diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
-index 11841f4..7164934 100644
---- a/drivers/mfd/Kconfig
-+++ b/drivers/mfd/Kconfig
-@@ -1855,6 +1855,12 @@ config MFD_STM32_TIMERS
- 	  for PWM and IIO Timer. This driver allow to share the
- 	  registers between the others drivers.
- 
-+config MFD_UPBOARD_FPGA
-+	tristate "Support for the UP board FPGA"
-+	select MFD_CORE
-+	help
-+	  Select this option to enable the UP and UP^2 on-board FPGA.
-+
- menu "Multimedia Capabilities Port drivers"
- 	depends on ARCH_SA1100
- 
-diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
-index 5856a94..22553f6 100644
---- a/drivers/mfd/Makefile
-+++ b/drivers/mfd/Makefile
-@@ -233,6 +233,7 @@ obj-$(CONFIG_MFD_MT6397)	+= mt6397-core.o
- 
- obj-$(CONFIG_MFD_ALTERA_A10SR)	+= altera-a10sr.o
- obj-$(CONFIG_MFD_SUN4I_GPADC)	+= sun4i-gpadc.o
-+obj-$(CONFIG_MFD_UPBOARD_FPGA)  += upboard-fpga.o
- 
- obj-$(CONFIG_MFD_STM32_LPTIMER)	+= stm32-lptimer.o
- obj-$(CONFIG_MFD_STM32_TIMERS) 	+= stm32-timers.o
-diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
-new file mode 100644
-index 0000000..9f444f8
---- /dev/null
-+++ b/drivers/mfd/upboard-fpga.c
-@@ -0,0 +1,411 @@
-+/*
-+ * UP Board main platform driver and FPGA configuration support
-+ *
-+ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
-+ *
-+ * Author: Javier Arteaga <javier@emutex.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/acpi.h>
-+#include <linux/dmi.h>
-+#include <linux/gpio.h>
-+#include <linux/kernel.h>
-+#include <linux/mfd/core.h>
-+#include <linux/mfd/upboard-fpga.h>
-+#include <linux/module.h>
-+#include <linux/platform_device.h>
-+#include <linux/regmap.h>
-+
-+static int upboard_fpga_read(void *, unsigned int, unsigned int *);
-+static int upboard_fpga_write(void *, unsigned int, unsigned int);
-+
-+struct upboard_fpga_data {
-+	const struct regmap_config *regmapconf;
-+	const struct mfd_cell *cells;
-+	size_t ncells;
-+};
-+
-+#define UPBOARD_LED_CELL(led_data, n)                   \
-+	{                                               \
-+		.name = "upboard-led",                  \
-+		.id = (n),                              \
-+		.platform_data = &led_data[(n)],        \
-+		.pdata_size = sizeof(*(led_data)),      \
-+	}
-+
-+/* UP board */
-+
-+static const struct regmap_range upboard_up_readable_ranges[] = {
-+	regmap_reg_range(UPFPGA_REG_PLATFORM_ID, UPFPGA_REG_FIRMWARE_ID),
-+	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN0),
-+	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR1),
-+};
-+
-+static const struct regmap_range upboard_up_writable_ranges[] = {
-+	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN0),
-+	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR1),
-+};
-+
-+static const struct regmap_access_table upboard_up_readable_table = {
-+	.yes_ranges = upboard_up_readable_ranges,
-+	.n_yes_ranges = ARRAY_SIZE(upboard_up_readable_ranges),
-+};
-+
-+static const struct regmap_access_table upboard_up_writable_table = {
-+	.yes_ranges = upboard_up_writable_ranges,
-+	.n_yes_ranges = ARRAY_SIZE(upboard_up_writable_ranges),
-+};
-+
-+static const struct regmap_config upboard_up_regmap_config = {
-+	.reg_bits = UPFPGA_ADDRESS_SIZE,
-+	.val_bits = UPFPGA_REGISTER_SIZE,
-+	.max_register = UPFPGA_REG_MAX,
-+	.reg_read = upboard_fpga_read,
-+	.reg_write = upboard_fpga_write,
-+	.fast_io = false,
-+	.cache_type = REGCACHE_RBTREE,
-+	.rd_table = &upboard_up_readable_table,
-+	.wr_table = &upboard_up_writable_table,
-+};
-+
-+static struct upboard_led_data upboard_up_led_data[] = {
-+	{ .bit = 0, .colour = "yellow" },
-+	{ .bit = 1, .colour = "green" },
-+	{ .bit = 2, .colour = "red" },
-+};
-+
-+static const struct mfd_cell upboard_up_mfd_cells[] = {
-+	{ .name = "upboard-pinctrl" },
-+	UPBOARD_LED_CELL(upboard_up_led_data, 0),
-+	UPBOARD_LED_CELL(upboard_up_led_data, 1),
-+	UPBOARD_LED_CELL(upboard_up_led_data, 2),
-+};
-+
-+static const struct upboard_fpga_data upboard_up_fpga_data = {
-+	.regmapconf = &upboard_up_regmap_config,
-+	.cells = upboard_up_mfd_cells,
-+	.ncells = ARRAY_SIZE(upboard_up_mfd_cells),
-+};
-+
-+/* UP^2 board */
-+
-+static const struct regmap_range upboard_up2_readable_ranges[] = {
-+	regmap_reg_range(UPFPGA_REG_PLATFORM_ID, UPFPGA_REG_FIRMWARE_ID),
-+	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN1),
-+	regmap_reg_range(UPFPGA_REG_GPIO_EN0, UPFPGA_REG_GPIO_EN2),
-+	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR2),
-+};
-+
-+static const struct regmap_range upboard_up2_writable_ranges[] = {
-+	regmap_reg_range(UPFPGA_REG_FUNC_EN0, UPFPGA_REG_FUNC_EN1),
-+	regmap_reg_range(UPFPGA_REG_GPIO_EN0, UPFPGA_REG_GPIO_EN2),
-+	regmap_reg_range(UPFPGA_REG_GPIO_DIR0, UPFPGA_REG_GPIO_DIR2),
-+};
-+
-+static const struct regmap_access_table upboard_up2_readable_table = {
-+	.yes_ranges = upboard_up2_readable_ranges,
-+	.n_yes_ranges = ARRAY_SIZE(upboard_up2_readable_ranges),
-+};
-+
-+static const struct regmap_access_table upboard_up2_writable_table = {
-+	.yes_ranges = upboard_up2_writable_ranges,
-+	.n_yes_ranges = ARRAY_SIZE(upboard_up2_writable_ranges),
-+};
-+
-+static const struct regmap_config upboard_up2_regmap_config = {
-+	.reg_bits = UPFPGA_ADDRESS_SIZE,
-+	.val_bits = UPFPGA_REGISTER_SIZE,
-+	.max_register = UPFPGA_REG_MAX,
-+	.reg_read = upboard_fpga_read,
-+	.reg_write = upboard_fpga_write,
-+	.fast_io = false,
-+	.cache_type = REGCACHE_RBTREE,
-+	.rd_table = &upboard_up2_readable_table,
-+	.wr_table = &upboard_up2_writable_table,
-+};
-+
-+static struct upboard_led_data upboard_up2_led_data[] = {
-+	{ .bit = 0, .colour = "blue" },
-+	{ .bit = 1, .colour = "yellow" },
-+	{ .bit = 2, .colour = "green" },
-+	{ .bit = 3, .colour = "red" },
-+};
-+
-+static const struct mfd_cell upboard_up2_mfd_cells[] = {
-+	{ .name = "upboard-pinctrl" },
-+	UPBOARD_LED_CELL(upboard_up2_led_data, 0),
-+	UPBOARD_LED_CELL(upboard_up2_led_data, 1),
-+	UPBOARD_LED_CELL(upboard_up2_led_data, 2),
-+	UPBOARD_LED_CELL(upboard_up2_led_data, 3),
-+};
-+
-+static const struct upboard_fpga_data upboard_up2_fpga_data = {
-+	.regmapconf = &upboard_up2_regmap_config,
-+	.cells = upboard_up2_mfd_cells,
-+	.ncells = ARRAY_SIZE(upboard_up2_mfd_cells),
-+};
-+
-+static int upboard_fpga_read(void *context, unsigned int reg, unsigned int *val)
-+{
-+	struct upboard_fpga * const fpga = context;
-+	int i;
-+
-+	gpiod_set_value(fpga->clear_gpio, 0);
-+	gpiod_set_value(fpga->clear_gpio, 1);
-+
-+	reg |= UPFPGA_READ_FLAG;
-+
-+	for (i = UPFPGA_ADDRESS_SIZE; i >= 0; i--) {
-+		gpiod_set_value(fpga->strobe_gpio, 0);
-+		gpiod_set_value(fpga->datain_gpio, (reg >> i) & 0x1);
-+		gpiod_set_value(fpga->strobe_gpio, 1);
-+	}
-+
-+	gpiod_set_value(fpga->strobe_gpio, 0);
-+	*val = 0;
-+
-+	for (i = UPFPGA_REGISTER_SIZE - 1; i >= 0; i--) {
-+		gpiod_set_value(fpga->strobe_gpio, 1);
-+		gpiod_set_value(fpga->strobe_gpio, 0);
-+		*val |= gpiod_get_value(fpga->dataout_gpio) << i;
-+	}
-+
-+	gpiod_set_value(fpga->strobe_gpio, 1);
-+
-+	return 0;
-+};
-+
-+static int upboard_fpga_write(void *context, unsigned int reg, unsigned int val)
-+{
-+	struct upboard_fpga * const fpga = context;
-+	int i;
-+
-+	gpiod_set_value(fpga->clear_gpio, 0);
-+	gpiod_set_value(fpga->clear_gpio, 1);
-+
-+	for (i = UPFPGA_ADDRESS_SIZE; i >= 0; i--) {
-+		gpiod_set_value(fpga->strobe_gpio, 0);
-+		gpiod_set_value(fpga->datain_gpio, (reg >> i) & 0x1);
-+		gpiod_set_value(fpga->strobe_gpio, 1);
-+	}
-+
-+	gpiod_set_value(fpga->strobe_gpio, 0);
-+
-+	for (i = UPFPGA_REGISTER_SIZE - 1; i >= 0; i--) {
-+		gpiod_set_value(fpga->datain_gpio, (val >> i) & 0x1);
-+		gpiod_set_value(fpga->strobe_gpio, 1);
-+		gpiod_set_value(fpga->strobe_gpio, 0);
-+	}
-+
-+	gpiod_set_value(fpga->strobe_gpio, 1);
-+
-+	return 0;
-+};
-+
-+static int __init upboard_fpga_gpio_init(struct upboard_fpga *fpga)
-+{
-+	enum gpiod_flags flags;
-+
-+	flags = fpga->uninitialised ? GPIOD_OUT_LOW : GPIOD_ASIS;
-+	fpga->enable_gpio = devm_gpiod_get(fpga->dev, "enable", flags);
-+	if (IS_ERR(fpga->enable_gpio))
-+		return PTR_ERR(fpga->enable_gpio);
-+
-+	fpga->clear_gpio = devm_gpiod_get(fpga->dev, "clear", GPIOD_OUT_LOW);
-+	if (IS_ERR(fpga->clear_gpio))
-+		return PTR_ERR(fpga->clear_gpio);
-+
-+	fpga->strobe_gpio = devm_gpiod_get(fpga->dev, "strobe", GPIOD_OUT_LOW);
-+	if (IS_ERR(fpga->strobe_gpio))
-+		return PTR_ERR(fpga->strobe_gpio);
-+
-+	fpga->datain_gpio = devm_gpiod_get(fpga->dev, "datain", GPIOD_OUT_LOW);
-+	if (IS_ERR(fpga->datain_gpio))
-+		return PTR_ERR(fpga->datain_gpio);
-+
-+	fpga->dataout_gpio = devm_gpiod_get(fpga->dev, "dataout", GPIOD_IN);
-+	if (IS_ERR(fpga->dataout_gpio))
-+		return PTR_ERR(fpga->dataout_gpio);
-+
-+	/* The SoC pinctrl driver may not support reserving the GPIO line for
-+	 * FPGA reset without causing an undesired reset pulse. This will clear
-+	 * any settings on the FPGA, so only do it if we must.
-+	 */
-+	if (fpga->uninitialised) {
-+		fpga->reset_gpio = devm_gpiod_get(fpga->dev, "reset",
-+						  GPIOD_OUT_LOW);
-+		if (IS_ERR(fpga->reset_gpio))
-+			return PTR_ERR(fpga->reset_gpio);
-+
-+		gpiod_set_value(fpga->reset_gpio, 1);
-+	}
-+
-+	gpiod_set_value(fpga->enable_gpio, 1);
-+	fpga->uninitialised = false;
-+
-+	return 0;
-+}
-+
-+static int __init upboard_fpga_detect_firmware(struct upboard_fpga *fpga)
-+{
-+	const unsigned int AAEON_MANUFACTURER_ID = 0x01;
-+	const unsigned int SUPPORTED_FW_MAJOR = 0x0;
-+	unsigned int platform_id, manufacturer_id;
-+	unsigned int firmware_id, build, major, minor, patch;
-+	int ret;
-+
-+	ret = regmap_read(fpga->regmap, UPFPGA_REG_PLATFORM_ID, &platform_id);
-+	if (ret)
-+		return ret;
-+
-+	manufacturer_id = platform_id & 0xff;
-+	if (manufacturer_id != AAEON_MANUFACTURER_ID) {
-+		dev_dbg(fpga->dev,
-+			"driver not compatible with custom FPGA FW from manufacturer id 0x%02x. Exiting",
-+			manufacturer_id);
-+		return -ENODEV;
-+	}
-+
-+	ret = regmap_read(fpga->regmap, UPFPGA_REG_FIRMWARE_ID, &firmware_id);
-+	if (ret)
-+		return ret;
-+
-+	build = (firmware_id >> 12) & 0xf;
-+	major = (firmware_id >> 8) & 0xf;
-+	minor = (firmware_id >> 4) & 0xf;
-+	patch = firmware_id & 0xf;
-+	if (major != SUPPORTED_FW_MAJOR) {
-+		dev_dbg(fpga->dev, "unsupported FPGA FW v%u.%u.%u build 0x%02x",
-+			major, minor, patch, build);
-+		return -ENODEV;
-+	}
-+
-+	dev_info(fpga->dev, "compatible FPGA FW v%u.%u.%u build 0x%02x",
-+		 major, minor, patch, build);
-+	return 0;
-+}
-+
-+static const struct acpi_device_id upboard_fpga_acpi_match[] = {
-+	{ "AANT0F00", (kernel_ulong_t) &upboard_up_fpga_data },
-+	{ "AANT0F01", (kernel_ulong_t) &upboard_up2_fpga_data },
-+	{ },
-+};
-+MODULE_DEVICE_TABLE(acpi, upboard_fpga_acpi_match);
-+
-+#define UPFPGA_QUIRK_UNINITIALISED  BIT(0)
-+#define UPFPGA_QUIRK_HRV1_IS_PROTO2 BIT(1)
-+
-+static const struct dmi_system_id upboard_dmi_table[] __initconst = {
-+	{
-+		.matches = { /* UP */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
-+		},
-+		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
-+	},
-+	{
-+		.matches = { /* UP2 */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-APL01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.3"),
-+		},
-+		.driver_data = (void *)(UPFPGA_QUIRK_UNINITIALISED |
-+			UPFPGA_QUIRK_HRV1_IS_PROTO2),
-+	},
-+	{
-+		.matches = { /* UP2 */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-APL01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
-+		},
-+		.driver_data = (void *)UPFPGA_QUIRK_HRV1_IS_PROTO2,
-+	},
-+	{ },
-+};
-+
-+#define UPFPGA_PROTOCOL_V2_HRV 2
-+
-+static int __init upboard_fpga_probe(struct platform_device *pdev)
-+{
-+	struct upboard_fpga *fpga;
-+	const struct acpi_device_id *id;
-+	const struct upboard_fpga_data *fpga_data;
-+	const struct dmi_system_id *system_id;
-+	acpi_handle handle;
-+	acpi_status status;
-+	unsigned long long hrv;
-+	unsigned long quirks = 0;
-+	int ret;
-+
-+	id = acpi_match_device(upboard_fpga_acpi_match, &pdev->dev);
-+	if (!id)
-+		return -ENODEV;
-+
-+	handle = ACPI_HANDLE(&pdev->dev);
-+	status = acpi_evaluate_integer(handle, "_HRV", NULL, &hrv);
-+	if (ACPI_FAILURE(status)) {
-+		dev_err(&pdev->dev, "failed to get PCTL revision");
-+		return -ENODEV;
-+	}
-+
-+	system_id = dmi_first_match(upboard_dmi_table);
-+	if (system_id)
-+		quirks = (unsigned long)system_id->driver_data;
-+
-+	if (hrv == 1 && (quirks & UPFPGA_QUIRK_HRV1_IS_PROTO2))
-+		hrv = UPFPGA_PROTOCOL_V2_HRV;
-+
-+	if (hrv != UPFPGA_PROTOCOL_V2_HRV) {
-+		dev_dbg(&pdev->dev, "unsupported PCTL revision: %llu", hrv);
-+		return -ENODEV;
-+	}
-+
-+	fpga_data = (const struct upboard_fpga_data *) id->driver_data;
-+
-+	fpga = devm_kzalloc(&pdev->dev, sizeof(*fpga), GFP_KERNEL);
-+	if (!fpga)
-+		return -ENOMEM;
-+
-+	if (quirks & UPFPGA_QUIRK_UNINITIALISED) {
-+		dev_info(&pdev->dev, "FPGA not initialised by this BIOS");
-+		fpga->uninitialised = true;
-+	}
-+
-+	dev_set_drvdata(&pdev->dev, fpga);
-+	fpga->dev = &pdev->dev;
-+	fpga->regmap = devm_regmap_init(&pdev->dev, NULL, fpga,
-+					fpga_data->regmapconf);
-+	if (IS_ERR(fpga->regmap))
-+		return PTR_ERR(fpga->regmap);
-+
-+	ret = upboard_fpga_gpio_init(fpga);
-+	if (ret) {
-+		dev_err(&pdev->dev, "failed to init FPGA comm GPIOs: %d", ret);
-+		return ret;
-+	}
-+
-+	ret = upboard_fpga_detect_firmware(fpga);
-+	if (ret)
-+		return ret;
-+
-+	return devm_mfd_add_devices(&pdev->dev, 0, fpga_data->cells,
-+				    fpga_data->ncells, NULL, 0, NULL);
-+}
-+
-+static struct platform_driver upboard_fpga_driver = {
-+	.driver = {
-+		.name = "upboard-fpga",
-+		.acpi_match_table = upboard_fpga_acpi_match,
-+	},
-+};
-+
-+module_platform_driver_probe(upboard_fpga_driver, upboard_fpga_probe);
-+
-+MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
-+MODULE_DESCRIPTION("UP Board FPGA driver");
-+MODULE_LICENSE("GPL v2");
-\ No newline at end of file
-diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
-index e86752b..d68d3c7 100644
---- a/drivers/pinctrl/Kconfig
-+++ b/drivers/pinctrl/Kconfig
-@@ -326,6 +326,18 @@ config PINCTRL_RK805
- 	help
- 	  This selects the pinctrl driver for RK805.
- 
-+config PINCTRL_UPBOARD
-+	tristate "UP board FPGA pin controller"
-+	depends on ACPI
-+	depends on MFD_UPBOARD_FPGA
-+	select GENERIC_PINCONF
-+	select PINMUX
-+	select PINCONF
-+	help
-+	  Pin controller for the FPGA GPIO lines on UP boards. Due to the
-+	  hardware layout, these are meant to be controlled in tandem with their
-+	  corresponding Intel SoC GPIOs.
-+
- config PINCTRL_OCELOT
- 	bool "Pinctrl driver for the Microsemi Ocelot SoCs"
- 	default y
-diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
-index 46ef9bd..828a6e9 100644
---- a/drivers/pinctrl/Makefile
-+++ b/drivers/pinctrl/Makefile
-@@ -41,6 +41,7 @@ obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
- obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
- obj-$(CONFIG_PINCTRL_INGENIC)	+= pinctrl-ingenic.o
- obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
-+obj-$(CONFIG_PINCTRL_UPBOARD)	+= pinctrl-upboard.o
- obj-$(CONFIG_PINCTRL_OCELOT)	+= pinctrl-ocelot.o
- 
- obj-y				+= actions/
-diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-new file mode 100644
-index 0000000..64899e9
---- /dev/null
-+++ b/drivers/pinctrl/pinctrl-upboard.c
-@@ -0,0 +1,797 @@
-+/*
-+ * UP Board FPGA-based pin controller driver
-+ *
-+ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
-+ *
-+ * Authors: Javier Arteaga <javier@emutex.com>
-+ *          Dan O'Donovan <dan@emutex.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/acpi.h>
-+#include <linux/dmi.h>
-+#include <linux/gpio.h>
-+#include <linux/gpio/consumer.h>
-+#include <linux/gpio/driver.h>
-+#include <linux/kernel.h>
-+#include <linux/mfd/upboard-fpga.h>
-+#include <linux/module.h>
-+#include <linux/pinctrl/pinctrl.h>
-+#include <linux/pinctrl/pinmux.h>
-+#include <linux/platform_device.h>
-+#include <linux/regmap.h>
-+#include <linux/string.h>
-+
-+#include "core.h"
-+
-+struct upboard_pin {
-+	struct regmap_field *funcbit;
-+	struct regmap_field *enbit;
-+	struct regmap_field *dirbit;
-+};
-+
-+struct upboard_bios {
-+	const struct reg_sequence *patches;
-+	size_t npatches;
-+};
-+
-+struct upboard_pinctrl {
-+	struct device *dev;
-+	struct pinctrl_dev *pctldev;
-+	struct regmap *regmap;
-+	struct gpio_chip chip;
-+	const unsigned int *rpi_mapping;
-+};
-+
-+enum upboard_func0_fpgabit {
-+	UPFPGA_I2C0_EN = 8,
-+	UPFPGA_I2C1_EN = 9,
-+	UPFPGA_CEC0_EN = 12,
-+	UPFPGA_ADC0_EN = 14,
-+};
-+
-+static const struct reg_field upboard_i2c0_reg =
-+	REG_FIELD(UPFPGA_REG_FUNC_EN0, UPFPGA_I2C0_EN, UPFPGA_I2C0_EN);
-+
-+static const struct reg_field upboard_i2c1_reg =
-+	REG_FIELD(UPFPGA_REG_FUNC_EN0, UPFPGA_I2C1_EN, UPFPGA_I2C1_EN);
-+
-+static const struct reg_field upboard_adc0_reg =
-+	REG_FIELD(UPFPGA_REG_FUNC_EN0, UPFPGA_ADC0_EN, UPFPGA_ADC0_EN);
-+
-+#define UPBOARD_BIT_TO_PIN(r, bit) \
-+	((r) * UPFPGA_REGISTER_SIZE + (bit))
-+
-+/*
-+ * UP board data
-+ */
-+
-+#define UPBOARD_UP_BIT_TO_PIN(r, id) (UPBOARD_BIT_TO_PIN(r, UPFPGA_UP_##id))
-+
-+#define UPBOARD_UP_PIN_ANON(r, bit)					\
-+	{								\
-+		.number = UPBOARD_BIT_TO_PIN(r, bit),			\
-+	}
-+
-+#define UPBOARD_UP_PIN_NAME(r, id)					\
-+	{								\
-+		.number = UPBOARD_UP_BIT_TO_PIN(r, id),			\
-+		.name = #id,						\
-+	}
-+
-+#define UPBOARD_UP_PIN_FUNC(r, id, data)				\
-+	{								\
-+		.number = UPBOARD_UP_BIT_TO_PIN(r, id),			\
-+		.name = #id,						\
-+		.drv_data = (void *)(data),				\
-+	}
-+
-+enum upboard_up_reg1_fpgabit {
-+	UPFPGA_UP_I2C1_SDA,
-+	UPFPGA_UP_I2C1_SCL,
-+	UPFPGA_UP_ADC0,
-+	UPFPGA_UP_GPIO17,
-+	UPFPGA_UP_GPIO27,
-+	UPFPGA_UP_GPIO22,
-+	UPFPGA_UP_SPI_MOSI,
-+	UPFPGA_UP_SPI_MISO,
-+	UPFPGA_UP_SPI_CLK,
-+	UPFPGA_UP_I2C0_SDA,
-+	UPFPGA_UP_GPIO5,
-+	UPFPGA_UP_GPIO6,
-+	UPFPGA_UP_PWM1,
-+	UPFPGA_UP_I2S_FRM,
-+	UPFPGA_UP_GPIO26,
-+	UPFPGA_UP_UART1_TX,
-+};
-+
-+enum upboard_up_reg2_fpgabit {
-+	UPFPGA_UP_UART1_RX,
-+	UPFPGA_UP_I2S_CLK,
-+	UPFPGA_UP_GPIO23,
-+	UPFPGA_UP_GPIO24,
-+	UPFPGA_UP_GPIO25,
-+	UPFPGA_UP_SPI_CS0,
-+	UPFPGA_UP_SPI_CS1,
-+	UPFPGA_UP_I2C0_SCL,
-+	UPFPGA_UP_PWM0,
-+	UPFPGA_UP_GPIO16,
-+	UPFPGA_UP_I2S_DIN,
-+	UPFPGA_UP_I2S_DOUT,
-+};
-+
-+static struct pinctrl_pin_desc upboard_up_pins[] = {
-+	UPBOARD_UP_PIN_FUNC(0, I2C1_SDA, &upboard_i2c1_reg),
-+	UPBOARD_UP_PIN_FUNC(0, I2C1_SCL, &upboard_i2c1_reg),
-+	UPBOARD_UP_PIN_FUNC(0, ADC0, &upboard_adc0_reg),
-+	UPBOARD_UP_PIN_NAME(0, GPIO17),
-+	UPBOARD_UP_PIN_NAME(0, GPIO27),
-+	UPBOARD_UP_PIN_NAME(0, GPIO22),
-+	UPBOARD_UP_PIN_NAME(0, SPI_MOSI),
-+	UPBOARD_UP_PIN_NAME(0, SPI_MISO),
-+	UPBOARD_UP_PIN_NAME(0, SPI_CLK),
-+	UPBOARD_UP_PIN_FUNC(0, I2C0_SDA, &upboard_i2c0_reg),
-+	UPBOARD_UP_PIN_NAME(0, GPIO5),
-+	UPBOARD_UP_PIN_NAME(0, GPIO6),
-+	UPBOARD_UP_PIN_NAME(0, PWM1),
-+	UPBOARD_UP_PIN_NAME(0, I2S_FRM),
-+	UPBOARD_UP_PIN_NAME(0, GPIO26),
-+	UPBOARD_UP_PIN_NAME(0, UART1_TX),
-+	/* register 1 */
-+	UPBOARD_UP_PIN_NAME(1, UART1_RX),
-+	UPBOARD_UP_PIN_NAME(1, I2S_CLK),
-+	UPBOARD_UP_PIN_NAME(1, GPIO23),
-+	UPBOARD_UP_PIN_NAME(1, GPIO24),
-+	UPBOARD_UP_PIN_NAME(1, GPIO25),
-+	UPBOARD_UP_PIN_NAME(1, SPI_CS0),
-+	UPBOARD_UP_PIN_NAME(1, SPI_CS1),
-+	UPBOARD_UP_PIN_FUNC(1, I2C0_SCL, &upboard_i2c0_reg),
-+	UPBOARD_UP_PIN_NAME(1, PWM0),
-+	UPBOARD_UP_PIN_NAME(1, GPIO16),
-+	UPBOARD_UP_PIN_NAME(1, I2S_DIN),
-+	UPBOARD_UP_PIN_NAME(1, I2S_DOUT),
-+};
-+
-+static const unsigned int upboard_up_rpi_mapping[] = {
-+	UPBOARD_UP_BIT_TO_PIN(0, I2C0_SDA),
-+	UPBOARD_UP_BIT_TO_PIN(1, I2C0_SCL),
-+	UPBOARD_UP_BIT_TO_PIN(0, I2C1_SDA),
-+	UPBOARD_UP_BIT_TO_PIN(0, I2C1_SCL),
-+	UPBOARD_UP_BIT_TO_PIN(0, ADC0),
-+	UPBOARD_UP_BIT_TO_PIN(0, GPIO5),
-+	UPBOARD_UP_BIT_TO_PIN(0, GPIO6),
-+	UPBOARD_UP_BIT_TO_PIN(1, SPI_CS1),
-+	UPBOARD_UP_BIT_TO_PIN(1, SPI_CS0),
-+	UPBOARD_UP_BIT_TO_PIN(0, SPI_MISO),
-+	UPBOARD_UP_BIT_TO_PIN(0, SPI_MOSI),
-+	UPBOARD_UP_BIT_TO_PIN(0, SPI_CLK),
-+	UPBOARD_UP_BIT_TO_PIN(1, PWM0),
-+	UPBOARD_UP_BIT_TO_PIN(0, PWM1),
-+	UPBOARD_UP_BIT_TO_PIN(0, UART1_TX),
-+	UPBOARD_UP_BIT_TO_PIN(1, UART1_RX),
-+	UPBOARD_UP_BIT_TO_PIN(1, GPIO16),
-+	UPBOARD_UP_BIT_TO_PIN(0, GPIO17),
-+	UPBOARD_UP_BIT_TO_PIN(1, I2S_CLK),
-+	UPBOARD_UP_BIT_TO_PIN(0, I2S_FRM),
-+	UPBOARD_UP_BIT_TO_PIN(1, I2S_DIN),
-+	UPBOARD_UP_BIT_TO_PIN(1, I2S_DOUT),
-+	UPBOARD_UP_BIT_TO_PIN(0, GPIO22),
-+	UPBOARD_UP_BIT_TO_PIN(1, GPIO23),
-+	UPBOARD_UP_BIT_TO_PIN(1, GPIO24),
-+	UPBOARD_UP_BIT_TO_PIN(1, GPIO25),
-+	UPBOARD_UP_BIT_TO_PIN(0, GPIO26),
-+	UPBOARD_UP_BIT_TO_PIN(0, GPIO27),
-+};
-+
-+/*
-+ * Init patches applied to the registers until the BIOS sets proper defaults
-+ */
-+static const struct reg_sequence upboard_up_reg_patches[] __initconst = {
-+	{ UPFPGA_REG_FUNC_EN0,
-+		// enable I2C voltage-level shifters
-+		BIT(UPFPGA_I2C0_EN) |
-+		BIT(UPFPGA_I2C1_EN) |
-+		// enable adc
-+		BIT(UPFPGA_ADC0_EN)
-+	},
-+	/* HAT function pins initially set as inputs */
-+	{ UPFPGA_REG_GPIO_DIR0,
-+		BIT(UPFPGA_UP_I2C1_SDA)	    |
-+		BIT(UPFPGA_UP_I2C1_SCL)	    |
-+		BIT(UPFPGA_UP_ADC0)	    |
-+		BIT(UPFPGA_UP_GPIO17)	    |
-+		BIT(UPFPGA_UP_GPIO27)	    |
-+		BIT(UPFPGA_UP_GPIO22)	    |
-+		BIT(UPFPGA_UP_SPI_MISO)	    |
-+		BIT(UPFPGA_UP_I2C0_SDA)	    |
-+		BIT(UPFPGA_UP_GPIO5)	    |
-+		BIT(UPFPGA_UP_GPIO6)	    |
-+		BIT(UPFPGA_UP_GPIO26)
-+	},
-+	{ UPFPGA_REG_GPIO_DIR1,
-+		BIT(UPFPGA_UP_UART1_RX)	|
-+		BIT(UPFPGA_UP_GPIO23)	|
-+		BIT(UPFPGA_UP_GPIO24)	|
-+		BIT(UPFPGA_UP_GPIO25)	|
-+		BIT(UPFPGA_UP_I2C0_SCL)	|
-+		BIT(UPFPGA_UP_GPIO16)	|
-+		BIT(UPFPGA_UP_I2S_DIN)
-+	},
-+};
-+
-+static const struct upboard_bios upboard_up_bios_info_dvt __initconst = {
-+	.patches = upboard_up_reg_patches,
-+	.npatches = ARRAY_SIZE(upboard_up_reg_patches),
-+};
-+
-+/*
-+ * UP^2 board data
-+ */
-+
-+#define UPBOARD_UP2_BIT_TO_PIN(r, id) (UPBOARD_BIT_TO_PIN(r, UPFPGA_UP2_##id))
-+
-+#define UPBOARD_UP2_PIN_ANON(r, bit)					\
-+	{								\
-+		.number = UPBOARD_BIT_TO_PIN(r, bit),			\
-+	}
-+
-+#define UPBOARD_UP2_PIN_NAME(r, id)					\
-+	{								\
-+		.number = UPBOARD_UP2_BIT_TO_PIN(r, id),		\
-+		.name = #id,						\
-+	}
-+
-+#define UPBOARD_UP2_PIN_FUNC(r, id, data)				\
-+	{								\
-+		.number = UPBOARD_UP2_BIT_TO_PIN(r, id),		\
-+		.name = #id,						\
-+		.drv_data = (void *)(data),				\
-+	}
-+
-+enum upboard_up2_reg0_fpgabit {
-+	UPFPGA_UP2_UART1_TXD,
-+	UPFPGA_UP2_UART1_RXD,
-+	UPFPGA_UP2_UART1_RTS,
-+	UPFPGA_UP2_UART1_CTS,
-+	UPFPGA_UP2_GPIO3,
-+	UPFPGA_UP2_GPIO5,
-+	UPFPGA_UP2_GPIO6,
-+	UPFPGA_UP2_GPIO11,
-+	UPFPGA_UP2_EXHAT_LVDS1n,
-+	UPFPGA_UP2_EXHAT_LVDS1p,
-+	UPFPGA_UP2_SPI2_TXD,
-+	UPFPGA_UP2_SPI2_RXD,
-+	UPFPGA_UP2_SPI2_FS1,
-+	UPFPGA_UP2_SPI2_FS0,
-+	UPFPGA_UP2_SPI2_CLK,
-+	UPFPGA_UP2_SPI1_TXD,
-+};
-+
-+enum upboard_up2_reg1_fpgabit {
-+	UPFPGA_UP2_SPI1_RXD,
-+	UPFPGA_UP2_SPI1_FS1,
-+	UPFPGA_UP2_SPI1_FS0,
-+	UPFPGA_UP2_SPI1_CLK,
-+	UPFPGA_UP2_BIT20,
-+	UPFPGA_UP2_BIT21,
-+	UPFPGA_UP2_BIT22,
-+	UPFPGA_UP2_BIT23,
-+	UPFPGA_UP2_PWM1,
-+	UPFPGA_UP2_PWM0,
-+	UPFPGA_UP2_EXHAT_LVDS0n,
-+	UPFPGA_UP2_EXHAT_LVDS0p,
-+	UPFPGA_UP2_I2C0_SCL,
-+	UPFPGA_UP2_I2C0_SDA,
-+	UPFPGA_UP2_I2C1_SCL,
-+	UPFPGA_UP2_I2C1_SDA,
-+};
-+
-+enum upboard_up2_reg2_fpgabit {
-+	UPFPGA_UP2_EXHAT_LVDS3n,
-+	UPFPGA_UP2_EXHAT_LVDS3p,
-+	UPFPGA_UP2_EXHAT_LVDS4n,
-+	UPFPGA_UP2_EXHAT_LVDS4p,
-+	UPFPGA_UP2_EXHAT_LVDS5n,
-+	UPFPGA_UP2_EXHAT_LVDS5p,
-+	UPFPGA_UP2_I2S_SDO,
-+	UPFPGA_UP2_I2S_SDI,
-+	UPFPGA_UP2_I2S_WS_SYNC,
-+	UPFPGA_UP2_I2S_BCLK,
-+	UPFPGA_UP2_EXHAT_LVDS6n,
-+	UPFPGA_UP2_EXHAT_LVDS6p,
-+	UPFPGA_UP2_EXHAT_LVDS7n,
-+	UPFPGA_UP2_EXHAT_LVDS7p,
-+	UPFPGA_UP2_EXHAT_LVDS2n,
-+	UPFPGA_UP2_EXHAT_LVDS2p,
-+};
-+
-+static struct pinctrl_pin_desc upboard_up2_pins[] = {
-+	UPBOARD_UP2_PIN_NAME(0, UART1_TXD),
-+	UPBOARD_UP2_PIN_NAME(0, UART1_RXD),
-+	UPBOARD_UP2_PIN_NAME(0, UART1_RTS),
-+	UPBOARD_UP2_PIN_NAME(0, UART1_CTS),
-+	UPBOARD_UP2_PIN_NAME(0, GPIO3),
-+	UPBOARD_UP2_PIN_NAME(0, GPIO5),
-+	UPBOARD_UP2_PIN_NAME(0, GPIO6),
-+	UPBOARD_UP2_PIN_NAME(0, GPIO11),
-+	UPBOARD_UP2_PIN_NAME(0, EXHAT_LVDS1n),
-+	UPBOARD_UP2_PIN_NAME(0, EXHAT_LVDS1p),
-+	UPBOARD_UP2_PIN_NAME(0, SPI2_TXD),
-+	UPBOARD_UP2_PIN_NAME(0, SPI2_RXD),
-+	UPBOARD_UP2_PIN_NAME(0, SPI2_FS1),
-+	UPBOARD_UP2_PIN_NAME(0, SPI2_FS0),
-+	UPBOARD_UP2_PIN_NAME(0, SPI2_CLK),
-+	UPBOARD_UP2_PIN_NAME(0, SPI1_TXD),
-+	UPBOARD_UP2_PIN_NAME(1, SPI1_RXD),
-+	UPBOARD_UP2_PIN_NAME(1, SPI1_FS1),
-+	UPBOARD_UP2_PIN_NAME(1, SPI1_FS0),
-+	UPBOARD_UP2_PIN_NAME(1, SPI1_CLK),
-+	UPBOARD_UP2_PIN_ANON(1, 4),
-+	UPBOARD_UP2_PIN_ANON(1, 5),
-+	UPBOARD_UP2_PIN_ANON(1, 6),
-+	UPBOARD_UP2_PIN_ANON(1, 7),
-+	UPBOARD_UP2_PIN_NAME(1, PWM1),
-+	UPBOARD_UP2_PIN_NAME(1, PWM0),
-+	UPBOARD_UP2_PIN_NAME(1, EXHAT_LVDS0n),
-+	UPBOARD_UP2_PIN_NAME(1, EXHAT_LVDS0p),
-+	UPBOARD_UP2_PIN_FUNC(1, I2C0_SCL, &upboard_i2c0_reg),
-+	UPBOARD_UP2_PIN_FUNC(1, I2C0_SDA, &upboard_i2c0_reg),
-+	UPBOARD_UP2_PIN_FUNC(1, I2C1_SCL, &upboard_i2c1_reg),
-+	UPBOARD_UP2_PIN_FUNC(1, I2C1_SDA, &upboard_i2c1_reg),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS3n),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS3p),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS4n),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS4p),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS5n),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS5p),
-+	UPBOARD_UP2_PIN_NAME(2, I2S_SDO),
-+	UPBOARD_UP2_PIN_NAME(2, I2S_SDI),
-+	UPBOARD_UP2_PIN_NAME(2, I2S_WS_SYNC),
-+	UPBOARD_UP2_PIN_NAME(2, I2S_BCLK),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS6n),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS6p),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS7n),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS7p),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS2n),
-+	UPBOARD_UP2_PIN_NAME(2, EXHAT_LVDS2p),
-+};
-+
-+static const unsigned int upboard_up2_rpi_mapping[] = {
-+	UPBOARD_UP2_BIT_TO_PIN(1, I2C0_SDA),
-+	UPBOARD_UP2_BIT_TO_PIN(1, I2C0_SCL),
-+	UPBOARD_UP2_BIT_TO_PIN(1, I2C1_SDA),
-+	UPBOARD_UP2_BIT_TO_PIN(1, I2C1_SCL),
-+	UPBOARD_UP2_BIT_TO_PIN(0, GPIO3),
-+	UPBOARD_UP2_BIT_TO_PIN(0, GPIO11),
-+	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_CLK),
-+	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_FS1),
-+	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_FS0),
-+	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_RXD),
-+	UPBOARD_UP2_BIT_TO_PIN(0, SPI1_TXD),
-+	UPBOARD_UP2_BIT_TO_PIN(1, SPI1_CLK),
-+	UPBOARD_UP2_BIT_TO_PIN(1, PWM0),
-+	UPBOARD_UP2_BIT_TO_PIN(1, PWM1),
-+	UPBOARD_UP2_BIT_TO_PIN(0, UART1_TXD),
-+	UPBOARD_UP2_BIT_TO_PIN(0, UART1_RXD),
-+	UPBOARD_UP2_BIT_TO_PIN(0, UART1_CTS),
-+	UPBOARD_UP2_BIT_TO_PIN(0, UART1_RTS),
-+	UPBOARD_UP2_BIT_TO_PIN(2, I2S_BCLK),
-+	UPBOARD_UP2_BIT_TO_PIN(2, I2S_WS_SYNC),
-+	UPBOARD_UP2_BIT_TO_PIN(2, I2S_SDI),
-+	UPBOARD_UP2_BIT_TO_PIN(2, I2S_SDO),
-+	UPBOARD_UP2_BIT_TO_PIN(0, GPIO6),
-+	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_FS1),
-+	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_RXD),
-+	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_TXD),
-+	UPBOARD_UP2_BIT_TO_PIN(0, SPI2_FS0),
-+	UPBOARD_UP2_BIT_TO_PIN(0, GPIO5),
-+};
-+
-+/*
-+ * Init patches applied to the registers until the BIOS sets proper defaults
-+ */
-+static const struct reg_sequence upboard_up2_reg_patches[] __initconst = {
-+	// enable I2C voltage-level shifters
-+	{ UPFPGA_REG_FUNC_EN0,
-+		BIT(UPFPGA_I2C0_EN) |
-+		BIT(UPFPGA_I2C1_EN)
-+	},
-+	// HAT function pins initially set as inputs
-+	{ UPFPGA_REG_GPIO_DIR0,
-+		BIT(UPFPGA_UP2_UART1_RXD) |
-+		BIT(UPFPGA_UP2_UART1_CTS)
-+	},
-+	{ UPFPGA_REG_GPIO_DIR1,
-+		BIT(UPFPGA_UP2_SPI1_RXD)
-+	},
-+	// HAT function pins initially enabled (i.e. not hi-Z)
-+	{ UPFPGA_REG_GPIO_EN0,
-+		BIT(UPFPGA_UP2_UART1_TXD) |
-+		BIT(UPFPGA_UP2_UART1_RXD) |
-+		BIT(UPFPGA_UP2_UART1_RTS) |
-+		BIT(UPFPGA_UP2_UART1_CTS) |
-+		BIT(UPFPGA_UP2_SPI1_TXD)
-+	},
-+	{ UPFPGA_REG_GPIO_EN1,
-+		BIT(UPFPGA_UP2_SPI1_RXD) |
-+		BIT(UPFPGA_UP2_SPI1_FS1) |
-+		BIT(UPFPGA_UP2_SPI1_FS0) |
-+		BIT(UPFPGA_UP2_SPI1_CLK) |
-+		BIT(UPFPGA_UP2_PWM1) |
-+		BIT(UPFPGA_UP2_PWM0)
-+	},
-+};
-+
-+static const struct upboard_bios upboard_up2_bios_info_v0_3 __initconst = {
-+	.patches = upboard_up2_reg_patches,
-+	.npatches = ARRAY_SIZE(upboard_up2_reg_patches),
-+};
-+
-+static int upboard_set_mux(struct pinctrl_dev *pctldev, unsigned int function,
-+			   unsigned int group)
-+{
-+	return 0;
-+};
-+
-+static int upboard_gpio_request_enable(struct pinctrl_dev *pctldev,
-+				       struct pinctrl_gpio_range *range,
-+				       unsigned int pin)
-+{
-+	const struct pin_desc * const pd = pin_desc_get(pctldev, pin);
-+	const struct upboard_pin *p;
-+	int ret;
-+
-+	if (!pd)
-+		return -EINVAL;
-+	p = pd->drv_data;
-+
-+	if (p->funcbit) {
-+		ret = regmap_field_write(p->funcbit, 0);
-+		if (ret)
-+			return ret;
-+	}
-+
-+	if (p->enbit) {
-+		ret = regmap_field_write(p->enbit, 1);
-+		if (ret)
-+			return ret;
-+	}
-+
-+	return 0;
-+};
-+
-+static int upboard_gpio_set_direction(struct pinctrl_dev *pctldev,
-+				      struct pinctrl_gpio_range *range,
-+				      unsigned int pin, bool input)
-+{
-+	const struct pin_desc * const pd = pin_desc_get(pctldev, pin);
-+	const struct upboard_pin *p;
-+
-+	if (!pd)
-+		return -EINVAL;
-+	p = pd->drv_data;
-+
-+	return regmap_field_write(p->dirbit, input);
-+};
-+
-+static int upboard_get_functions_count(struct pinctrl_dev *pctldev)
-+{
-+	return 0;
-+}
-+
-+static const char *upboard_get_function_name(struct pinctrl_dev *pctldev,
-+				     unsigned int selector)
-+{
-+	return NULL;
-+}
-+
-+static int upboard_get_function_groups(struct pinctrl_dev *pctldev,
-+			       unsigned int selector,
-+			       const char * const **groups,
-+			       unsigned int *num_groups)
-+{
-+	*groups = NULL;
-+	*num_groups = 0;
-+	return 0;
-+}
-+
-+static const struct pinmux_ops upboard_pinmux_ops = {
-+	.get_functions_count = upboard_get_functions_count,
-+	.get_function_groups = upboard_get_function_groups,
-+	.get_function_name = upboard_get_function_name,
-+	.set_mux = upboard_set_mux,
-+	.gpio_request_enable = upboard_gpio_request_enable,
-+	.gpio_set_direction = upboard_gpio_set_direction,
-+};
-+
-+static int upboard_get_groups_count(struct pinctrl_dev *pctldev)
-+{
-+	return 0;
-+}
-+
-+static const char *upboard_get_group_name(struct pinctrl_dev *pctldev,
-+					  unsigned int selector)
-+{
-+	return NULL;
-+}
-+
-+static const struct pinctrl_ops upboard_pinctrl_ops = {
-+	.get_groups_count = upboard_get_groups_count,
-+	.get_group_name = upboard_get_group_name,
-+};
-+
-+static struct pinctrl_desc upboard_up_pinctrl_desc = {
-+	.pins = upboard_up_pins,
-+	.npins = ARRAY_SIZE(upboard_up_pins),
-+	.pctlops = &upboard_pinctrl_ops,
-+	.pmxops = &upboard_pinmux_ops,
-+	.owner = THIS_MODULE,
-+};
-+
-+static struct pinctrl_desc upboard_up2_pinctrl_desc = {
-+	.pins = upboard_up2_pins,
-+	.npins = ARRAY_SIZE(upboard_up2_pins),
-+	.pctlops = &upboard_pinctrl_ops,
-+	.pmxops = &upboard_pinmux_ops,
-+	.owner = THIS_MODULE,
-+};
-+
-+static int upboard_rpi_to_native_gpio(struct gpio_chip *gc, unsigned int gpio)
-+{
-+	struct upboard_pinctrl *pctrl =
-+		container_of(gc, struct upboard_pinctrl, chip);
-+	unsigned int pin = pctrl->rpi_mapping[gpio];
-+	struct pinctrl_gpio_range *range =
-+		pinctrl_find_gpio_range_from_pin(pctrl->pctldev, pin);
-+
-+	if (!range)
-+		return -ENODEV;
-+
-+	return range->base;
-+}
-+
-+static int upboard_gpio_request(struct gpio_chip *gc, unsigned int offset)
-+{
-+	int gpio = upboard_rpi_to_native_gpio(gc, offset);
-+
-+	if (gpio < 0)
-+		return gpio;
-+
-+	return gpio_request(gpio, module_name(THIS_MODULE));
-+}
-+
-+static void upboard_gpio_free(struct gpio_chip *gc, unsigned int offset)
-+{
-+	int gpio = upboard_rpi_to_native_gpio(gc, offset);
-+
-+	if (gpio < 0)
-+		return;
-+
-+	gpio_free(gpio);
-+}
-+
-+static int upboard_gpio_get(struct gpio_chip *gc, unsigned int offset)
-+{
-+	int gpio = upboard_rpi_to_native_gpio(gc, offset);
-+
-+	if (gpio < 0)
-+		return gpio;
-+
-+	return gpio_get_value(gpio);
-+}
-+
-+static void upboard_gpio_set(struct gpio_chip *gc, unsigned int offset, int
-+			     value)
-+{
-+	int gpio = upboard_rpi_to_native_gpio(gc, offset);
-+
-+	if (gpio < 0)
-+		return;
-+
-+	gpio_set_value(gpio, value);
-+}
-+
-+static int upboard_gpio_direction_input(struct gpio_chip *gc,
-+					unsigned int offset)
-+{
-+	int gpio = upboard_rpi_to_native_gpio(gc, offset);
-+
-+	if (gpio < 0)
-+		return gpio;
-+
-+	return gpio_direction_input(gpio);
-+}
-+
-+static int upboard_gpio_direction_output(struct gpio_chip *gc,
-+					 unsigned int offset, int value)
-+{
-+	int gpio = upboard_rpi_to_native_gpio(gc, offset);
-+
-+	if (gpio < 0)
-+		return gpio;
-+
-+	return gpio_direction_output(gpio, value);
-+}
-+
-+static struct gpio_chip upboard_gpio_chip = {
-+	.label = "Raspberry Pi compatible UP GPIO",
-+	.base = 0,
-+	.ngpio = ARRAY_SIZE(upboard_up_rpi_mapping),
-+	.request = upboard_gpio_request,
-+	.free = upboard_gpio_free,
-+	.get = upboard_gpio_get,
-+	.set = upboard_gpio_set,
-+	.direction_input = upboard_gpio_direction_input,
-+	.direction_output = upboard_gpio_direction_output,
-+	.owner = THIS_MODULE,
-+};
-+
-+/* DMI Matches for older bios without fpga initialization */
-+static const struct dmi_system_id upboard_dmi_table[] __initconst = {
-+	{
-+		.matches = { /* UP */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
-+		},
-+		.driver_data = (void *)&upboard_up_bios_info_dvt,
-+	},
-+	{
-+		.matches = { /* UP2 */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-APL01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.3"),
-+		},
-+		.driver_data = (void *)&upboard_up2_bios_info_v0_3,
-+	},
-+	{ },
-+};
-+
-+static int __init upboard_pinctrl_probe(struct platform_device *pdev)
-+{
-+	struct upboard_fpga * const fpga = dev_get_drvdata(pdev->dev.parent);
-+	struct acpi_device * const adev = ACPI_COMPANION(&pdev->dev);
-+	struct pinctrl_desc *pctldesc;
-+	const struct upboard_bios *bios_info = NULL;
-+	struct upboard_pinctrl *pctrl;
-+	struct upboard_pin *pins;
-+	const struct dmi_system_id *system_id;
-+	const char *hid;
-+	const unsigned int *rpi_mapping;
-+	int ret;
-+	int i;
-+
-+	if (!fpga)
-+		return -EINVAL;
-+
-+	if (!adev)
-+		return -ENODEV;
-+
-+	hid = acpi_device_hid(adev);
-+	if (!strcmp(hid, "AANT0F00")) {
-+		pctldesc = &upboard_up_pinctrl_desc;
-+		rpi_mapping = upboard_up_rpi_mapping;
-+	} else if (!strcmp(hid, "AANT0F01")) {
-+		pctldesc = &upboard_up2_pinctrl_desc;
-+		rpi_mapping = upboard_up2_rpi_mapping;
-+	} else
-+		return -ENODEV;
-+
-+	pctldesc->name = dev_name(&pdev->dev);
-+
-+	pins = devm_kzalloc(&pdev->dev,
-+			    sizeof(*pins) * pctldesc->npins,
-+			    GFP_KERNEL);
-+	if (!pins)
-+		return -ENOMEM;
-+
-+	/* initialise pins */
-+	for (i = 0; i < pctldesc->npins; i++) {
-+		struct upboard_pin *pin = &pins[i];
-+		struct pinctrl_pin_desc *pd = (struct pinctrl_pin_desc *)
-+			&pctldesc->pins[i];
-+		struct reg_field fldconf = {0};
-+		unsigned int regoff = (pd->number / UPFPGA_REGISTER_SIZE);
-+		unsigned int lsb = pd->number % UPFPGA_REGISTER_SIZE;
-+
-+		pin->funcbit = NULL;
-+		if (pd->drv_data) {
-+			fldconf = *(struct reg_field *)pd->drv_data;
-+			if (!regmap_writeable(fpga->regmap, fldconf.reg))
-+				return -EINVAL;
-+
-+			pin->funcbit = devm_regmap_field_alloc(&pdev->dev,
-+							       fpga->regmap,
-+							       fldconf);
-+			if (IS_ERR(pin->funcbit))
-+				return PTR_ERR(pin->funcbit);
-+		}
-+
-+		pin->enbit = NULL;
-+		fldconf.reg = UPFPGA_REG_GPIO_EN0 + regoff;
-+		fldconf.lsb = lsb;
-+		fldconf.msb = lsb;
-+
-+		/* some platform don't have enable bit, ignore if not present */
-+		if (regmap_writeable(fpga->regmap, fldconf.reg)) {
-+			pin->enbit = devm_regmap_field_alloc(&pdev->dev,
-+							     fpga->regmap,
-+							     fldconf);
-+			if (IS_ERR(pin->enbit))
-+				return PTR_ERR(pin->enbit);
-+		}
-+
-+		fldconf.reg = UPFPGA_REG_GPIO_DIR0 + regoff;
-+		fldconf.lsb = lsb;
-+		fldconf.msb = lsb;
-+
-+		if (!regmap_writeable(fpga->regmap, fldconf.reg))
-+			return -EINVAL;
-+
-+		pin->dirbit = devm_regmap_field_alloc(&pdev->dev,
-+						      fpga->regmap,
-+						      fldconf);
-+		if (IS_ERR(pin->dirbit))
-+			return PTR_ERR(pin->dirbit);
-+
-+		pd->drv_data = pin;
-+	}
-+
-+	/* create a new pinctrl device and register it */
-+	pctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);
-+	if (!pctrl)
-+		return -ENOMEM;
-+
-+	pctrl->regmap = fpga->regmap;
-+	pctrl->rpi_mapping = rpi_mapping;
-+	pctrl->chip = upboard_gpio_chip;
-+	pctrl->chip.parent = &pdev->dev;
-+
-+	ret = devm_gpiochip_add_data(&pdev->dev, &pctrl->chip, &pctrl->chip);
-+	if (ret)
-+		return ret;
-+
-+	pctrl->pctldev = devm_pinctrl_register(&pdev->dev, pctldesc, pctrl);
-+	if (IS_ERR(pctrl->pctldev))
-+		return PTR_ERR(pctrl->pctldev);
-+
-+	/* add acpi pin mapping according to external-gpios key */
-+	ret = acpi_node_add_pin_mapping(acpi_fwnode_handle(adev),
-+					"external-gpios",
-+					dev_name(&pdev->dev),
-+					0, UINT_MAX);
-+	if (ret)
-+		return ret;
-+
-+	/* check for special board versions that require register patches */
-+	system_id = dmi_first_match(upboard_dmi_table);
-+	if (system_id)
-+		bios_info = system_id->driver_data;
-+
-+	if (bios_info && bios_info->patches) {
-+		ret = regmap_register_patch(pctrl->regmap,
-+					    bios_info->patches,
-+					    bios_info->npatches);
-+		if (ret)
-+			return ret;
-+	}
-+
-+	return 0;
-+}
-+
-+static struct platform_driver upboard_pinctrl_driver = {
-+	.driver = {
-+		.name = "upboard-pinctrl",
-+	},
-+};
-+
-+module_platform_driver_probe(upboard_pinctrl_driver, upboard_pinctrl_probe);
-+
-+MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
-+MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
-+MODULE_DESCRIPTION("UP Board HAT pin controller driver");
-+MODULE_LICENSE("GPL v2");
-+MODULE_ALIAS("platform:upboard-pinctrl");
-\ No newline at end of file
-diff --git a/include/linux/mfd/upboard-fpga.h b/include/linux/mfd/upboard-fpga.h
-new file mode 100644
-index 0000000..cd7fb81
---- /dev/null
-+++ b/include/linux/mfd/upboard-fpga.h
-@@ -0,0 +1,52 @@
-+/*
-+ * UP Board FPGA MFD driver interface
-+ *
-+ * Copyright (c) 2017, Emutex Ltd. All rights reserved.
-+ *
-+ * Author: Javier Arteaga <javier@emutex.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#ifndef __LINUX_MFD_UPBOARD_FPGA_H
-+#define __LINUX_MFD_UPBOARD_FPGA_H
-+
-+#define UPFPGA_ADDRESS_SIZE  7
-+#define UPFPGA_REGISTER_SIZE 16
-+
-+#define UPFPGA_READ_FLAG     (1 << UPFPGA_ADDRESS_SIZE)
-+
-+enum upboard_fpgareg {
-+	UPFPGA_REG_PLATFORM_ID   = 0x10,
-+	UPFPGA_REG_FIRMWARE_ID   = 0x11,
-+	UPFPGA_REG_FUNC_EN0      = 0x20,
-+	UPFPGA_REG_FUNC_EN1      = 0x21,
-+	UPFPGA_REG_GPIO_EN0      = 0x30,
-+	UPFPGA_REG_GPIO_EN1      = 0x31,
-+	UPFPGA_REG_GPIO_EN2      = 0x32,
-+	UPFPGA_REG_GPIO_DIR0     = 0x40,
-+	UPFPGA_REG_GPIO_DIR1     = 0x41,
-+	UPFPGA_REG_GPIO_DIR2     = 0x42,
-+	UPFPGA_REG_MAX,
-+};
-+
-+struct upboard_fpga {
-+	struct device *dev;
-+	struct regmap *regmap;
-+	struct gpio_desc *enable_gpio;
-+	struct gpio_desc *reset_gpio;
-+	struct gpio_desc *clear_gpio;
-+	struct gpio_desc *strobe_gpio;
-+	struct gpio_desc *datain_gpio;
-+	struct gpio_desc *dataout_gpio;
-+	bool uninitialised;
-+};
-+
-+struct upboard_led_data {
-+	unsigned int bit;
-+	const char *colour;
-+};
-+
-+#endif /*  __LINUX_MFD_UPBOARD_FPGA_H */
-\ No newline at end of file
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0006-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch b/recipes-kernel/linux/files/0006-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch
new file mode 100755
index 0000000..f69263f
--- /dev/null
+++ b/recipes-kernel/linux/files/0006-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch
@@ -0,0 +1,1312 @@
+From ae0495f7eeab27c30e1e8cdc13dab2bcc9a30db5 Mon Sep 17 00:00:00 2001
+From: Carlos Calderon <carlos@emutex.com>
+Date: Thu, 4 Oct 2018 10:44:53 +0100
+Subject: [PATCH 06/30] up: pinctrl: Bring in legacy fpga and pinctrl driver
+
+This commits just copies the legacy UP board platform driver and the
+pinctrl/fpga one from ubilinux-3 branch.
+The only change made was to obey to the following commit:
+    58383c7 gpio: change member .dev to .parent
+
+Kernel config option to built-in UP support added in Kconfig&Makefile.
+
+UP1 board with FPGA1 protocol and old BIOS doesn't provide the necessary
+information via ACPI to the kernel, therefore the new MFD FPGA driver
+will not be loaded; instead this legacy platform driver will always be
+loaded and based on the platform detected will load or not the pinctrl
+one.
+---
+ drivers/platform/x86/Kconfig            |  15 +
+ drivers/platform/x86/Makefile           |   1 +
+ drivers/platform/x86/up_board.c         | 242 ++++++
+ drivers/platform/x86/up_board_pinctrl.c | 989 ++++++++++++++++++++++++
+ 4 files changed, 1247 insertions(+)
+ create mode 100644 drivers/platform/x86/up_board.c
+ create mode 100644 drivers/platform/x86/up_board_pinctrl.c
+
+diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
+index 0659ef82446f..eb99cf3cb45c 100644
+--- a/drivers/platform/x86/Kconfig
++++ b/drivers/platform/x86/Kconfig
+@@ -1365,6 +1365,21 @@ config INTEL_SAFETY_ISLAND
+ 
+ source "drivers/platform/x86/intel_speed_select_if/Kconfig"
+ 
++config UPBOARD_LEGACY
++	bool "UP Board platform extras"
++	depends on ACPI && PINCTRL_CHERRYVIEW
++	select GPIOLIB_IRQCHIP
++	---help---
++	This driver initialises the platform devices on the UP board.
++	It supports UP Board with FPGA protocol V1. For UP2/UPCore or UP with
++	updated BIOS and FPGA firmware, please have a look at MFD_UPBOARD_FPGA
++	config option and the driver(s) behind.
++	It includes a Pin Control driver, which creates a "virtual" GPIO chip,
++	to transparently manage the buffers and mux switches between the SoC
++	GPIO pins and the external pin header.  The GPIOs presented by the
++	platform driver are numbered to emulate the Raspberry Pi 2 pin header
++	layout to aid application portability.
++
+ endif # X86_PLATFORM_DEVICES
+ 
+ config PMC_ATOM
+diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
+index 882582fd43d0..bd86f7a7859b 100644
+--- a/drivers/platform/x86/Makefile
++++ b/drivers/platform/x86/Makefile
+@@ -96,6 +96,7 @@ obj-$(CONFIG_INTEL_PMC_CORE)    += intel_pmc_core.o intel_pmc_core_pltdrv.o
+ obj-$(CONFIG_PMC_ATOM)		+= pmc_atom.o
+ obj-$(CONFIG_MLX_PLATFORM)	+= mlx-platform.o
+ obj-$(CONFIG_INTEL_TURBO_MAX_3) += intel_turbo_max_3.o
++obj-$(CONFIG_UPBOARD_LEGACY)	+= up_board.o up_board_pinctrl.o
+ obj-$(CONFIG_INTEL_CHTDC_TI_PWRBTN)	+= intel_chtdc_ti_pwrbtn.o
+ obj-$(CONFIG_INTEL_MRFLD_PWRBTN)	+= intel_mrfld_pwrbtn.o
+ obj-$(CONFIG_I2C_MULTI_INSTANTIATE)	+= i2c-multi-instantiate.o
+diff --git a/drivers/platform/x86/up_board.c b/drivers/platform/x86/up_board.c
+new file mode 100644
+index 000000000000..3acbed72dbf6
+--- /dev/null
++++ b/drivers/platform/x86/up_board.c
+@@ -0,0 +1,242 @@
++/*
++ * UP Board header pin GPIO driver.
++ *
++ * Copyright (c) 2016, Emutex Ltd.  All rights reserved.
++ *
++ * Author: Dan O'Donovan <dan@emutex.com>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms and conditions of the GNU General Public License,
++ * version 2, as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++#include <linux/module.h>
++#include <linux/dmi.h>
++#include <linux/platform_device.h>
++#include <linux/pinctrl/machine.h>
++#include <linux/pinctrl/pinconf-generic.h>
++#include <linux/i2c.h>
++#include <linux/spi/spi.h>
++#include <linux/platform_data/pca953x.h>
++#include <linux/regulator/fixed.h>
++#include <linux/regulator/machine.h>
++#include <linux/acpi.h>
++
++#define UP_BOARD_SPIDEV_BUS_NUM 2
++#define UP_BOARD_SPIDEV_MAX_CLK 25000000
++
++struct up_board_info {
++	struct pinctrl_map *pinmux_maps;
++	unsigned num_pinmux_maps;
++	int (*init_devices)(void);
++};
++
++static bool spidev0 = true;
++module_param(spidev0, bool, S_IRUGO);
++MODULE_PARM_DESC(spidev0, "register a spidev device on SPI bus 2-0");
++
++static bool spidev1 = false;
++module_param(spidev1, bool, S_IRUGO);
++MODULE_PARM_DESC(spidev1, "register a spidev device on SPI bus 2-1");
++
++/* On the UP board, if the ODEn bit is set on the pad configuration
++ * it seems to impair some functions on the I/O header such as UART, SPI
++ * and even I2C.  So we disable it for all header pins by default.
++ */
++static unsigned long oden_disable_conf[] = {
++	PIN_CONF_PACKED(PIN_CONFIG_DRIVE_PUSH_PULL, 0),
++};
++
++#define UP_PIN_MAP_MUX_GROUP(d, p, f) \
++	PIN_MAP_MUX_GROUP_DEFAULT(d, p, f "_grp", f)
++
++#define UP_PIN_MAP_CONF_ODEN(d, p, f) \
++	PIN_MAP_CONFIGS_GROUP_DEFAULT(d, p, f "_grp", oden_disable_conf)
++
++/* Maps pin functions on UP Board I/O pin header to specific CHT SoC devices */
++static struct pinctrl_map up_pinmux_maps[] __initdata = {
++	UP_PIN_MAP_MUX_GROUP("8086228A:00", "up-pinctrl", "uart1"),
++	UP_PIN_MAP_MUX_GROUP("808622C1:00", "up-pinctrl", "i2c0"),
++	UP_PIN_MAP_MUX_GROUP("808622C1:01", "up-pinctrl", "i2c1"),
++	UP_PIN_MAP_MUX_GROUP("808622A8:00", "up-pinctrl", "i2s0"),
++	UP_PIN_MAP_MUX_GROUP("80862288:00", "up-pinctrl", "pwm0"),
++	UP_PIN_MAP_MUX_GROUP("80862288:01", "up-pinctrl", "pwm1"),
++	UP_PIN_MAP_MUX_GROUP("8086228E:01", "up-pinctrl", "spi2"),
++	UP_PIN_MAP_MUX_GROUP("i2c-ADC081C:00", "up-pinctrl", "adc0"),
++
++	UP_PIN_MAP_MUX_GROUP("8086228A:00", "INT33FF:00", "uart1"),
++	UP_PIN_MAP_MUX_GROUP("808622C1:00", "INT33FF:00", "i2c0"),
++	UP_PIN_MAP_MUX_GROUP("808622C1:01", "INT33FF:00", "i2c1"),
++	UP_PIN_MAP_MUX_GROUP("808622C1:02", "INT33FF:00", "i2c2"),
++	UP_PIN_MAP_MUX_GROUP("808622A8:00", "INT33FF:00", "lpe"),
++	UP_PIN_MAP_MUX_GROUP("80862288:00", "INT33FF:03", "pwm0"),
++	UP_PIN_MAP_MUX_GROUP("80862288:01", "INT33FF:03", "pwm1"),
++	UP_PIN_MAP_MUX_GROUP("8086228E:01", "INT33FF:03", "spi2"),
++
++	UP_PIN_MAP_CONF_ODEN("8086228A:00", "INT33FF:00", "uart1"),
++	UP_PIN_MAP_CONF_ODEN("808622C1:00", "INT33FF:00", "i2c0"),
++	UP_PIN_MAP_CONF_ODEN("808622C1:01", "INT33FF:00", "i2c1"),
++	UP_PIN_MAP_CONF_ODEN("808622A8:00", "INT33FF:00", "lpe"),
++	UP_PIN_MAP_CONF_ODEN("80862288:00", "INT33FF:03", "pwm0"),
++	UP_PIN_MAP_CONF_ODEN("80862288:01", "INT33FF:03", "pwm1"),
++	UP_PIN_MAP_CONF_ODEN("8086228E:01", "INT33FF:03", "spi2"),
++};
++
++static struct platform_device *up_pinctrl_dev;
++
++static struct regulator_consumer_supply vref3v3_consumers[] = {
++	REGULATOR_SUPPLY("vref", "i2c-ADC081C:00"),
++};
++
++static struct spi_board_info up_spidev_info __initdata = {
++	.modalias	= "spidev",
++	.bus_num	= UP_BOARD_SPIDEV_BUS_NUM,
++	.max_speed_hz   = UP_BOARD_SPIDEV_MAX_CLK,
++};
++
++static int __init
++up_board_init_devices(void)
++{
++#if IS_ENABLED(CONFIG_REGULATOR)
++	struct platform_device *vreg;
++
++	vreg = regulator_register_always_on(0, "fixed-3.3V",
++					    vref3v3_consumers,
++					    ARRAY_SIZE(vref3v3_consumers),
++					    3300000);
++	if (!vreg) {
++		pr_err("Failed to register UP Board ADC vref regulator");
++		return -ENODEV;
++	}
++#else
++	pr_dbg("Voltage and Current Regulator Support NOT enabled!");
++#endif
++
++	return 0;
++}
++
++static struct up_board_info up_board_info __initdata = {
++	.pinmux_maps = up_pinmux_maps,
++	.num_pinmux_maps = ARRAY_SIZE(up_pinmux_maps),
++	.init_devices = up_board_init_devices,
++};
++
++static const struct dmi_system_id up_board_id_table[] = {
++	{
++		.matches = {
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
++		},
++		.driver_data = (void *)&up_board_info
++	},
++	{
++		.matches = {
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.5"),
++		},
++		.driver_data = (void *)&up_board_info
++	},
++	{ }
++};
++
++#define UPFPGA_PROTOCOL_V1_HRV 1
++
++static int __init
++up_board_init(void) {
++	const struct dmi_system_id *system_id;
++	struct up_board_info *board_info;
++	acpi_status status;
++	unsigned long long hrv;
++	int ret;
++
++	system_id = dmi_first_match(up_board_id_table);
++	if (!system_id)
++		return -ENXIO;
++
++	status = acpi_evaluate_integer(NULL, "\\_SB.PCTL._HRV", NULL, &hrv);
++	if (ACPI_SUCCESS(status) && (hrv != UPFPGA_PROTOCOL_V1_HRV)) {
++		pr_debug("Unsupported PCTL revision: %llu", hrv);
++		return -ENODEV;
++	}
++
++	board_info = system_id->driver_data;
++
++	/* Register pin control mappings specific to board version */
++	if (board_info->pinmux_maps) {
++		ret = pinctrl_register_mappings(board_info->pinmux_maps,
++						board_info->num_pinmux_maps);
++		if (ret) {
++			pr_err("Failed to register UP Board pinctrl mapping");
++			return ret;
++		}
++	}
++
++	/* Register devices specific to board version */
++	if (board_info->init_devices) {
++		ret = board_info->init_devices();
++		if (ret) {
++			pr_err("Failed to register UP Board devices");
++			return ret;
++		}
++	}
++
++	/* Register devices common to all board versions */
++	if (spidev0) {
++		up_spidev_info.chip_select = 0;
++		ret = spi_register_board_info(&up_spidev_info, 1);
++		if (ret) {
++			pr_err("Failed to register UP Board spidev0 device");
++			return -ENODEV;
++		}
++	}
++	if (spidev1) {
++		up_spidev_info.chip_select = 1;
++		ret = spi_register_board_info(&up_spidev_info, 1);
++		if (ret) {
++			pr_err("Failed to register UP Board spidev1 device");
++			return -ENODEV;
++		}
++	}
++
++	/* Create a virtual device to manage the UP Board GPIO pin header */
++	up_pinctrl_dev = platform_device_alloc("up-pinctrl", -1);
++	if (!up_pinctrl_dev) {
++		pr_err("Failed to allocate UP pinctrl platform device");
++		return -ENOMEM;
++	}
++
++	ret = platform_device_add(up_pinctrl_dev);
++	if (ret) {
++		pr_err("Failed to allocate UP pinctrl platform device");
++		platform_device_put(up_pinctrl_dev);
++		return ret;
++	}
++
++	return 0;
++}
++
++static void __exit
++up_board_exit(void)
++{
++	platform_device_unregister(up_pinctrl_dev);
++}
++
++/* Using arch_initcall to ensure that i2c devices are registered
++ * before the I2C adapters are enumerated
++ */
++arch_initcall(up_board_init);
++module_exit(up_board_exit);
++
++MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
++MODULE_DESCRIPTION("Platform driver for UP Board");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("dmi:*:svnAAEON*:rnUP-CHT01:*");
+\ No newline at end of file
+diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
+new file mode 100644
+index 000000000000..e6c9de4bcfbc
+--- /dev/null
++++ b/drivers/platform/x86/up_board_pinctrl.c
+@@ -0,0 +1,989 @@
++/*
++ * UP Board header pin GPIO driver.
++ *
++ * Copyright (c) 2016, Emutex Ltd.  All rights reserved.
++ *
++ * Author: Dan O'Donovan <dan@emutex.com>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms and conditions of the GNU General Public License,
++ * version 2, as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++#include <linux/gpio.h>
++#include <linux/kernel.h>
++#include <linux/leds.h>
++#include <linux/module.h>
++#include <linux/dmi.h>
++#include <linux/pinctrl/pinctrl.h>
++#include <linux/pinctrl/pinmux.h>
++#include <linux/pinctrl/pinconf.h>
++#include <linux/pinctrl/pinconf-generic.h>
++#include <linux/platform_device.h>
++#include <linux/interrupt.h>
++
++/*
++ * The UP Board features an external 40-pin header for I/O functions including
++ * GPIO, I2C, UART, SPI, PWM and I2S, similar in layout to the Raspberry Pi 2.
++ * At the heart of the UP Board is an Intel X5-Z8350 "Cherry Trail" SoC, which
++ * provides the I/O functions for these pins at 1.8V logic levels.
++ *
++ * Additional buffers and mux switches are used between the SoC and the I/O pin
++ * header to convert between the 1.8V SoC I/O and the 3.3V levels required at
++ * the pin header, with sufficient current source/sink capability for
++ * LV-TTL/LV-CMOS compatibility.  These buffers and mux switches require
++ * run-time configuration based on the pin function or GPIO direction selected
++ * by the user.
++ *
++ * The purpose of this driver is to manage the complexity of the buffer
++ * configuration so that application code can transparently access the I/O
++ * functions on the external pins through standard kernel interfaces.  It
++ * instantiates a gpio and pinctrl device, and effectively acts as a "shim"
++ * between application code and the underlying Cherry Trail GPIO driver.
++ */
++
++/* References to Cherry Trail GPIO chip driver */
++struct up_soc_gpiochip_info {
++	char *name;
++	struct gpio_chip *chip;
++};
++
++/* References to Cherry Trail GPIO pins */
++struct up_soc_gpio_info {
++	struct up_soc_gpiochip_info *ci;
++	struct gpio_desc *desc;
++	unsigned offset;
++	int gpio;
++	int irq;
++	int flags;
++};
++
++/* Information for a single I/O pin on the UP board */
++struct up_pin_info {
++	struct up_soc_gpio_info soc_gpio;
++	int irq;
++	int dir_ctrl_pin;
++	int dir_in;
++	int dir_out;
++	int func_dir;
++	int mux_ctrl_pin;
++	int mux_gpio;
++	int mux_func;
++	bool func_enabled;
++};
++
++struct up_cpld_led_info {
++	unsigned offset;
++	const char *name;
++	struct up_cpld_info *cpld;
++	struct led_classdev cdev;
++};
++
++/* Information for the CPLD featured on later UP board revisions */
++struct up_cpld_info {
++	struct up_soc_gpio_info strobe_gpio;
++	struct up_soc_gpio_info reset_gpio;
++	struct up_soc_gpio_info data_in_gpio;
++	struct up_soc_gpio_info data_out_gpio;
++	struct up_soc_gpio_info oe_gpio;
++	u64 dir_reg;
++	bool do_verify;
++	bool do_strobe_after_write;
++	unsigned dir_reg_size;
++	struct up_cpld_led_info *leds;
++	unsigned num_leds;
++	spinlock_t lock;
++};
++
++struct up_board_info {
++	struct up_pin_info *pins;
++	struct up_cpld_info *cpld;
++};
++
++/* Context variables for this driver */
++struct up_pctrl {
++	struct up_board_info *board;
++	struct gpio_chip chip;
++	struct pinctrl_desc pctldesc;
++	struct pinctrl_dev *pctldev;
++};
++
++/* Pin group information */
++struct up_pingroup {
++	const char *name;
++	const unsigned *pins;
++	size_t npins;
++};
++
++/* Pin function information */
++struct up_function {
++	const char *name;
++	const char * const *groups;
++	size_t ngroups;
++};
++
++/* The Cherry Trail SoC has 4 independent GPIO controllers */
++static struct up_soc_gpiochip_info chip_cht_SW = { .name = "INT33FF:00" };
++static struct up_soc_gpiochip_info chip_cht_N  = { .name = "INT33FF:01" };
++static struct up_soc_gpiochip_info chip_cht_E  = { .name = "INT33FF:02" };
++static struct up_soc_gpiochip_info chip_cht_SE = { .name = "INT33FF:03" };
++
++#define SOC_GPIO(c, o, f)		\
++	{				\
++		.ci	= (c),		\
++		.offset	= (o),		\
++		.flags	= (f),		\
++	}
++#define SOC_GPIO_INPUT(c, o) SOC_GPIO(c, o, GPIOF_IN)
++#define SOC_GPIO_OUTPUT(c, o) SOC_GPIO(c, o, GPIOF_OUT_INIT_LOW)
++#define GPIO_PIN(c, o, dpin, din, dout, dfunc, mpin, mgpio, mfunc) \
++	{						\
++		.soc_gpio.ci		= (c),		\
++		.soc_gpio.offset	= (o),		\
++		.dir_ctrl_pin		= (dpin),	\
++		.dir_in			= (din),	\
++		.dir_out		= (dout),	\
++		.func_dir		= (dfunc),	\
++		.mux_ctrl_pin		= (mpin),	\
++		.mux_gpio		= (mgpio),	\
++		.mux_func		= (mfunc),	\
++		.func_enabled		= false,	\
++	}
++
++#define FDIR_NONE -1
++#define FDIR_OUT  1
++#define FDIR_IN   0
++
++#define NONE -1
++
++#define PIN_GROUP(n, p)				\
++	{					\
++		.name = (n),			\
++		.pins = (p),			\
++		.npins = ARRAY_SIZE((p)),	\
++	}
++
++#define FUNCTION(n, g)				\
++	{					\
++		.name = (n),			\
++		.groups = (g),			\
++		.ngroups = ARRAY_SIZE((g)),	\
++	}
++
++#define GPIO_PINRANGE(start, end)		\
++	{					\
++		.base = (start),		\
++		.npins = (end) - (start) $ 1,	\
++	}
++
++#define N_GPIO 28
++
++/* Initial configuration assumes all pins as GPIO inputs */
++#define CPLD_DIR_REG_INIT	(0x00FFFFFFFULL)
++
++/* Convenience macros to populate the pin info tables below */
++#define GPIO_PIN_UP(c, o, dpin, dfunc, mpin, mgpio, mfunc)	\
++	GPIO_PIN(c, o, dpin, 1, 0, dfunc, mpin, mgpio, mfunc)
++#define GPIO_PIN_UP_NO_MUX(c, o, dpin, dfunc)			\
++	GPIO_PIN_UP(c, o, dpin, dfunc, NONE, -1, -1)
++
++/*
++ * Table of I/O pins on the 40-pin header of the UP Board (version-specific)
++ */
++/* UP Board uses a CPLD to provide I/O signal buffers and mux switching */
++static struct up_pin_info up_pins[N_GPIO] = {
++	GPIO_PIN_UP(&chip_cht_SW, 33,  9, FDIR_OUT, 28, 0, 1),	/*  0 */
++	GPIO_PIN_UP(&chip_cht_SW, 37, 23, FDIR_OUT, 28, 0, 1),	/*  1 */
++	GPIO_PIN_UP(&chip_cht_SW, 32,  0, FDIR_OUT, 29, 0, 1),	/*  2 */
++	GPIO_PIN_UP(&chip_cht_SW, 35,  1, FDIR_OUT, 29, 0, 1),	/*  3 */
++	GPIO_PIN_UP(&chip_cht_E,  18,  2, FDIR_IN,  30, 0, 1),	/*  4 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  21, 10, FDIR_NONE),		/*  5 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  12, 11, FDIR_NONE),		/*  6 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 48, 22, FDIR_NONE),		/*  7 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  7, 21, FDIR_OUT),		/*  8 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  3,  7, FDIR_IN),		/*  9 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  6,  6, FDIR_OUT),		/* 10 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  4,  8, FDIR_OUT),		/* 11 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  5, 24, FDIR_OUT),		/* 12 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  1, 12, FDIR_OUT),		/* 13 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 13, 15, FDIR_OUT),		/* 14 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  9, 16, FDIR_IN),		/* 15 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 11, 25, FDIR_IN),		/* 16 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  8,  3, FDIR_OUT),		/* 17 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 50, 17, FDIR_OUT),		/* 18 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 54, 13, FDIR_OUT),		/* 19 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 52, 26, FDIR_IN),		/* 20 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 55, 27, FDIR_OUT),		/* 21 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 12,  5, FDIR_OUT),		/* 22 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 15, 18, FDIR_OUT),		/* 23 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 18, 19, FDIR_OUT),		/* 24 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 11, 20, FDIR_OUT),		/* 25 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 14, 14, FDIR_OUT),		/* 26 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  8,  4, FDIR_OUT),		/* 27 */
++};
++
++static struct up_cpld_led_info up_cpld_leds[] = {
++	{ .offset = 31, .name = "yellow", },
++	{ .offset = 32, .name = "green", },
++	{ .offset = 33, .name = "red", },
++};
++
++static struct up_cpld_info up_cpld = {
++	.strobe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_N, 21),
++	.reset_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 15),
++	.data_in_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 13),
++	.data_out_gpio		= SOC_GPIO_INPUT(&chip_cht_E, 23),
++	.oe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_SW, 43),
++	.dir_reg		= CPLD_DIR_REG_INIT,
++	.do_verify		= true,
++	.do_strobe_after_write	= false,
++	.dir_reg_size		= 34,
++	.leds			= up_cpld_leds,
++	.num_leds		= ARRAY_SIZE(up_cpld_leds),
++};
++
++static struct up_board_info up_board = {
++	.pins = up_pins,
++	.cpld = &up_cpld,
++};
++
++/* The layout and numbering is designed to emulate the Raspberry Pi 2 */
++static const struct pinctrl_pin_desc up_pins_pi[] = {
++	PINCTRL_PIN(0,  "I2C0_SDA"),
++	PINCTRL_PIN(1,  "I2C0_SCL"),
++	PINCTRL_PIN(2,  "I2C1_SDA"),
++	PINCTRL_PIN(3,  "I2C1_SCL"),
++	PINCTRL_PIN(4,  "GPIO4"),
++	PINCTRL_PIN(5,  "GPIO5"),
++	PINCTRL_PIN(6,  "GPIO6"),
++	PINCTRL_PIN(7,  "SPI_CS1"),
++	PINCTRL_PIN(8,  "SPI_CS0"),
++	PINCTRL_PIN(9,  "SPI_MISO"),
++	PINCTRL_PIN(10, "SPI_MOSI"),
++	PINCTRL_PIN(11, "SPI_CLK"),
++	PINCTRL_PIN(12, "PWM0"),
++	PINCTRL_PIN(13, "PWM1"),
++	PINCTRL_PIN(14, "UART1_TX"),
++	PINCTRL_PIN(15, "UART1_RX"),
++	PINCTRL_PIN(16, "GPIO16"),
++	PINCTRL_PIN(17, "GPIO17"),
++	PINCTRL_PIN(18, "I2S_CLK"),
++	PINCTRL_PIN(19, "I2S_FRM"),
++	PINCTRL_PIN(20, "I2S_DIN"),
++	PINCTRL_PIN(21, "I2S_DOUT"),
++	PINCTRL_PIN(22, "GPIO22"),
++	PINCTRL_PIN(23, "GPIO23"),
++	PINCTRL_PIN(24, "GPIO24"),
++	PINCTRL_PIN(25, "GPIO25"),
++	PINCTRL_PIN(26, "GPIO26"),
++	PINCTRL_PIN(27, "GPIO27"),
++};
++
++static const unsigned uart1_pins[] = { 14, 15, 16, 17 };
++static const unsigned uart2_pins[] = { 25, 27 };
++static const unsigned i2c0_pins[]  = { 0, 1 };
++static const unsigned i2c1_pins[]  = { 2, 3 };
++static const unsigned spi2_pins[]  = { 8, 9, 10, 11 };
++static const unsigned i2s0_pins[]  = { 18, 19, 20, 21 };
++static const unsigned pwm0_pins[]  = { 12 };
++static const unsigned pwm1_pins[]  = { 13 };
++static const unsigned adc0_pins[]  = { 4 };
++
++static const struct up_pingroup pin_groups[] = {
++	PIN_GROUP("uart1_grp", uart1_pins),
++	PIN_GROUP("uart2_grp", uart2_pins),
++	PIN_GROUP("i2c0_grp", i2c0_pins),
++	PIN_GROUP("i2c1_grp", i2c1_pins),
++	PIN_GROUP("spi2_grp", spi2_pins),
++	PIN_GROUP("i2s0_grp", i2s0_pins),
++	PIN_GROUP("pwm0_grp", pwm0_pins),
++	PIN_GROUP("pwm1_grp", pwm1_pins),
++	PIN_GROUP("adc0_grp", adc0_pins),
++};
++
++static const char * const uart1_groups[] = { "uart1_grp" };
++static const char * const uart2_groups[] = { "uart2_grp" };
++static const char * const i2c0_groups[]  = { "i2c0_grp" };
++static const char * const i2c1_groups[]  = { "i2c1_grp" };
++static const char * const spi2_groups[]  = { "spi2_grp" };
++static const char * const i2s0_groups[]  = { "i2s0_grp" };
++static const char * const pwm0_groups[]  = { "pwm0_grp" };
++static const char * const pwm1_groups[]  = { "pwm1_grp" };
++static const char * const adc0_groups[]  = { "adc0_grp" };
++
++static const struct up_function pin_functions[] = {
++	FUNCTION("uart1", uart1_groups),
++	FUNCTION("uart2", uart2_groups),
++	FUNCTION("i2c0",  i2c0_groups),
++	FUNCTION("i2c1",  i2c1_groups),
++	FUNCTION("spi2",  spi2_groups),
++	FUNCTION("i2s0",  i2s0_groups),
++	FUNCTION("pwm0",  pwm0_groups),
++	FUNCTION("pwm1",  pwm1_groups),
++	FUNCTION("adc0",  adc0_groups),
++};
++
++/* On the UP board, the header pin level shifting and mux switching is
++ * controlled by a dedicated CPLD with proprietary firmware
++ *
++ * The CPLD is responsible for connecting and translating 1.8V GPIO signals from
++ * the SoC to the 28 GPIO header pins at 3.3V, and for this it needs to be
++ * configured with direction (input/output) for each GPIO.  In addition, it
++ * manages 3 mux switches (2 for I2C bus pins, 1 for ADC pin) which need to be
++ * configured on/off, and 3 LEDs.
++ *
++ * A register value is loaded into the CPLD at run-time to configure the
++ * 28 GPIO level shifters, 3 mux switches and 3 LEDs.  This register value is
++ * loaded via a 2-wire data interface consisting of a strobe and data line.  The
++ * data line is sampled on each rising edge that appears on the strobe line.  A
++ * reset signal (active low) is used to reset internal counters and state prior
++ * to loading a new register value.  An output-enable signal is provided,
++ * initially disabled which puts all header pins in a HiZ state until a valid
++ * pin configuration is loaded by this driver.
++ *
++ * The register value is clocked into the CPLD bit-by-bit, and then read back.
++ * A total of 69 rising edges on the strobe signal are required, following the
++ * reset pulse, before the new register value is "latched" by the CPLD.
++ */
++static int cpld_configure(struct up_cpld_info *cpld)
++{
++	u64 dir_reg_verify = 0;
++	int i;
++
++	/* Reset the CPLD internal counters */
++	gpiod_set_value(cpld->reset_gpio.desc, 0);
++	gpiod_set_value(cpld->reset_gpio.desc, 1);
++
++	/* Update the CPLD dir register */
++	for (i = cpld->dir_reg_size - 1; i >= 0; i--) {
++		/* Bring STB low initially */
++		gpiod_set_value(cpld->strobe_gpio.desc, 0);
++		/* Load the next bit value, MSb first */
++		gpiod_set_value(cpld->data_in_gpio.desc,
++				(cpld->dir_reg >> i) & 0x1);
++		/* Bring STB high to latch the bit value */
++		gpiod_set_value(cpld->strobe_gpio.desc, 1);
++	}
++
++	if (cpld->do_strobe_after_write) {
++		/* Issue a dummy STB cycle after writing the register value */
++		gpiod_set_value(cpld->strobe_gpio.desc, 0);
++		gpiod_set_value(cpld->strobe_gpio.desc, 1);
++	}
++
++	/* Read back the value */
++	for (i = cpld->dir_reg_size - 1; i >= 0; i--) {
++		/* Cycle the strobe and read the data pin */
++		gpiod_set_value(cpld->strobe_gpio.desc, 0);
++		gpiod_set_value(cpld->strobe_gpio.desc, 1);
++		dir_reg_verify |=
++			(u64)gpiod_get_value(cpld->data_out_gpio.desc) << i;
++	}
++
++	/* Verify that the CPLD dir register was written successfully
++	 * In some hardware revisions, data_out_gpio isn't actually
++	 * connected so we skip this step if do_verify is not set
++	 */
++	if (cpld->do_verify && (dir_reg_verify != cpld->dir_reg)) {
++		pr_err("CPLD verify error (expected: %llX, actual: %llX)\n",
++		       cpld->dir_reg, dir_reg_verify);
++		return -EIO;
++	}
++
++	/* Issue a dummy STB cycle to latch the dir register updates */
++	gpiod_set_value(cpld->strobe_gpio.desc, 0);
++	gpiod_set_value(cpld->strobe_gpio.desc, 1);
++
++	return 0;
++}
++
++static int cpld_set_value(struct up_cpld_info *cpld, unsigned int offset,
++			  int value)
++{
++	u64 old_regval;
++	int ret = 0;
++
++	spin_lock(&cpld->lock);
++
++	old_regval = cpld->dir_reg;
++
++	if (value)
++		cpld->dir_reg |= 1ULL << offset;
++	else
++		cpld->dir_reg &= ~(1ULL << offset);
++
++	/* Only update the CPLD register if it has changed */
++	if (cpld->dir_reg != old_regval)
++		ret = cpld_configure(cpld);
++
++	spin_unlock(&cpld->lock);
++
++	return ret;
++}
++
++static int up_pincfg_set(struct up_board_info *board, int offset, int value)
++{
++	if (board->cpld)
++		return cpld_set_value(board->cpld, offset, value);
++
++	gpio_set_value_cansleep(offset, value);
++	return 0;
++}
++
++static inline struct up_pctrl *gc_to_up_pctrl(struct gpio_chip *gc)
++{
++	return container_of(gc, struct up_pctrl, chip);
++}
++
++static int up_gpiochip_match(struct gpio_chip *chip, void *data)
++{
++	return !strcmp(chip->label, data);
++}
++
++static int up_soc_gpio_resolve(struct platform_device *pdev,
++			       struct up_soc_gpio_info *gpio_info)
++{
++	struct up_soc_gpiochip_info *ci = gpio_info->ci;
++
++	if (!ci->chip) {
++		ci->chip = gpiochip_find(ci->name, up_gpiochip_match);
++		if (!ci->chip)
++			return -EPROBE_DEFER;
++	}
++	gpio_info->gpio = ci->chip->base + gpio_info->offset;
++	gpio_info->desc = gpio_to_desc(gpio_info->gpio);
++	if (!gpio_info->desc) {
++		dev_err(&pdev->dev, "Failed to get descriptor for gpio %d\n",
++			gpio_info->gpio);
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static int up_gpio_pincfg_cpld(struct platform_device *pdev,
++			       struct up_board_info *board)
++{
++	struct up_cpld_info *cpld = board->cpld;
++	struct up_soc_gpio_info *cpld_gpios[] = {
++		&cpld->strobe_gpio,
++		&cpld->reset_gpio,
++		&cpld->data_in_gpio,
++		&cpld->data_out_gpio,
++		&cpld->oe_gpio,
++	};
++	int i, ret;
++
++	spin_lock_init(&cpld->lock);
++
++	/* Initialise the CPLD config input GPIOs as outputs, initially low */
++	for (i = 0; i < ARRAY_SIZE(cpld_gpios); i++) {
++		struct up_soc_gpio_info *gpio_info = cpld_gpios[i];
++
++		ret = up_soc_gpio_resolve(pdev, gpio_info);
++		if (ret)
++			return ret;
++
++		ret = devm_gpio_request_one(&pdev->dev, gpio_info->gpio,
++					    gpio_info->flags,
++					    dev_name(&pdev->dev));
++		if (ret)
++			return ret;
++	}
++
++	/* Load initial CPLD configuration (all pins set for GPIO input) */
++	ret = cpld_configure(board->cpld);
++	if (ret) {
++		dev_err(&pdev->dev, "CPLD initialisation failed\n");
++		return ret;
++	}
++
++	/* Enable the CPLD outputs after a valid configuration has been set */
++	gpiod_set_value(cpld->oe_gpio.desc, 1);
++
++	return 0;
++}
++
++static int up_gpio_pincfg_init(struct platform_device *pdev,
++			       struct up_board_info *board)
++{
++	unsigned i;
++	int ret;
++
++	/* Find the Cherry Trail GPIO descriptors corresponding
++	 * with each GPIO pin on the UP Board I/O header
++	 */
++	for (i = 0; i < N_GPIO; i++) {
++		struct up_pin_info *pin = &board->pins[i];
++
++		ret = up_soc_gpio_resolve(pdev, &pin->soc_gpio);
++		if (ret)
++			return ret;
++
++		/* Ensure the GPIO pins are configured as inputs initially */
++		ret = gpiod_direction_input(pin->soc_gpio.desc);
++		if (ret) {
++			dev_err(&pdev->dev, "GPIO direction init failed\n");
++			return ret;
++		}
++	}
++
++	return up_gpio_pincfg_cpld(pdev, board);
++}
++
++static irqreturn_t up_gpio_irq_handler(int irq, void *data)
++{
++	struct up_pin_info *pin = (struct up_pin_info *)data;
++
++	generic_handle_irq(pin->irq);
++	return IRQ_HANDLED;
++}
++
++static unsigned int up_gpio_irq_startup(struct irq_data *data)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	unsigned offset = irqd_to_hwirq(data);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++	return request_irq(pin->soc_gpio.irq, up_gpio_irq_handler,
++			   IRQF_ONESHOT, dev_name(gc->parent), pin);
++}
++
++static void up_gpio_irq_shutdown(struct irq_data *data)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	unsigned offset = irqd_to_hwirq(data);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++	free_irq(pin->soc_gpio.irq, pin);
++}
++
++static struct irq_chip up_gpio_irqchip = {
++	.name = "up-gpio",
++	.irq_startup = up_gpio_irq_startup,
++	.irq_shutdown = up_gpio_irq_shutdown,
++	.irq_enable = irq_chip_enable_parent,
++	.irq_disable = irq_chip_disable_parent,
++	.irq_mask = irq_chip_mask_parent,
++	.irq_unmask = irq_chip_unmask_parent,
++	.irq_ack = irq_chip_ack_parent,
++	.irq_set_type = irq_chip_set_type_parent,
++};
++
++static int up_gpio_dir_in(struct gpio_chip *gc, unsigned offset)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++	int ret;
++
++	ret = gpiod_direction_input(desc);
++	if (ret)
++		return ret;
++
++	return pinctrl_gpio_direction_input(gc->base + offset);
++}
++
++static int up_gpio_dir_out(struct gpio_chip *gc, unsigned offset, int value)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++	int ret;
++
++	ret = pinctrl_gpio_direction_output(gc->base + offset);
++	if (ret)
++		return ret;
++
++	return gpiod_direction_output(desc, value);
++}
++
++static int up_gpio_get_dir(struct gpio_chip *gc, unsigned offset)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++
++	return gpiod_get_direction(desc);
++}
++
++static int up_gpio_request(struct gpio_chip *gc, unsigned offset)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++
++	pinctrl_request_gpio(gc->base + offset);
++	return gpio_request(desc_to_gpio(desc), gc->label);
++}
++
++static void up_gpio_free(struct gpio_chip *gc, unsigned offset)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++
++	pinctrl_free_gpio(gc->base + offset);
++	gpio_free(desc_to_gpio(desc));
++}
++
++static int up_gpio_get(struct gpio_chip *gc, unsigned offset)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++
++	return gpiod_get_value(desc);
++}
++
++static void up_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
++{
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++	struct gpio_desc *desc = pin->soc_gpio.desc;
++
++	gpiod_set_value(desc, value);
++}
++
++static struct gpio_chip up_gpio_chip = {
++	.owner			= THIS_MODULE,
++	.ngpio			= N_GPIO,
++	.request		= up_gpio_request,
++	.free			= up_gpio_free,
++	.get_direction		= up_gpio_get_dir,
++	.direction_input	= up_gpio_dir_in,
++	.direction_output	= up_gpio_dir_out,
++	.get			= up_gpio_get,
++	.set			= up_gpio_set,
++};
++
++static int up_get_groups_count(struct pinctrl_dev *pctldev)
++{
++	return ARRAY_SIZE(pin_groups);
++}
++
++static const char *up_get_group_name(struct pinctrl_dev *pctldev,
++				     unsigned group)
++{
++	return pin_groups[group].name;
++}
++
++static int up_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,
++			     const unsigned **pins, unsigned *npins)
++{
++	*pins = pin_groups[group].pins;
++	*npins = pin_groups[group].npins;
++	return 0;
++}
++
++static const struct pinctrl_ops up_pinctrl_ops = {
++	.get_groups_count = up_get_groups_count,
++	.get_group_name = up_get_group_name,
++	.get_group_pins = up_get_group_pins,
++};
++
++static int up_get_functions_count(struct pinctrl_dev *pctldev)
++{
++	return ARRAY_SIZE(pin_functions);
++}
++
++static const char *up_get_function_name(struct pinctrl_dev *pctldev,
++					unsigned function)
++{
++	return pin_functions[function].name;
++}
++
++static int up_get_function_groups(struct pinctrl_dev *pctldev,
++				  unsigned function,
++				  const char * const **groups,
++				  unsigned * const ngroups)
++{
++	*groups = pin_functions[function].groups;
++	*ngroups = pin_functions[function].ngroups;
++	return 0;
++}
++
++static int up_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,
++			     unsigned group)
++{
++	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
++	const struct up_pingroup *grp = &pin_groups[group];
++	int i;
++
++	for (i = 0; i < grp->npins; i++) {
++		int offset = grp->pins[i];
++		struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++		if ((pin->dir_ctrl_pin != NONE) && (pin->func_dir != FDIR_NONE))
++			up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
++				      pin->func_dir == FDIR_IN ?
++				      pin->dir_in : pin->dir_out);
++		if (pin->mux_ctrl_pin != NONE)
++			up_pincfg_set(up_pctrl->board, pin->mux_ctrl_pin,
++				      pin->mux_func);
++		pin->func_enabled = true;
++	}
++
++	return 0;
++}
++
++static int up_gpio_set_direction(struct pinctrl_dev *pctldev,
++				 struct pinctrl_gpio_range *range,
++				 unsigned offset, bool input)
++{
++	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++	if (pin->dir_ctrl_pin != NONE)
++		up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
++			      input ? pin->dir_in : pin->dir_out);
++
++	return 0;
++}
++
++static int up_gpio_request_enable(struct pinctrl_dev *pctldev,
++				  struct pinctrl_gpio_range *range,
++				  unsigned offset)
++{
++	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++	if (pin->mux_ctrl_pin != NONE)
++		up_pincfg_set(up_pctrl->board, pin->mux_ctrl_pin,
++			      pin->mux_gpio);
++	if (pin->dir_ctrl_pin != NONE)
++		up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
++			      gpiod_get_direction(pin->soc_gpio.desc)
++			      ? pin->dir_in : pin->dir_out);
++
++	return 0;
++}
++
++static void up_gpio_disable_free(struct pinctrl_dev *pctldev,
++				 struct pinctrl_gpio_range *range,
++				 unsigned offset)
++{
++	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++	if (pin->func_enabled) {
++		if ((pin->dir_ctrl_pin != NONE) && (pin->func_dir != FDIR_NONE))
++			up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
++				      pin->func_dir == FDIR_IN ?
++				      pin->dir_in : pin->dir_out);
++		if (pin->mux_ctrl_pin != NONE)
++			up_pincfg_set(up_pctrl->board, pin->mux_ctrl_pin,
++				      pin->mux_func);
++	}
++}
++
++static const struct pinmux_ops up_pinmux_ops = {
++	.get_functions_count = up_get_functions_count,
++	.get_function_name = up_get_function_name,
++	.get_function_groups = up_get_function_groups,
++	.set_mux = up_pinmux_set_mux,
++	.gpio_request_enable = up_gpio_request_enable,
++	.gpio_disable_free = up_gpio_disable_free,
++	.gpio_set_direction = up_gpio_set_direction,
++};
++
++static int up_config_get(struct pinctrl_dev *pctldev, unsigned pin,
++			 unsigned long *config)
++{
++	return -ENOTSUPP;
++}
++
++static int up_config_set(struct pinctrl_dev *pctldev, unsigned pin,
++			 unsigned long *configs, unsigned nconfigs)
++{
++	return 0;
++}
++
++static const struct pinconf_ops up_pinconf_ops = {
++	.is_generic = true,
++	.pin_config_set = up_config_set,
++	.pin_config_get = up_config_get,
++};
++
++static struct pinctrl_desc up_pinctrl_desc = {
++	.pins = up_pins_pi,
++	.npins = ARRAY_SIZE(up_pins_pi),
++	.pctlops = &up_pinctrl_ops,
++	.pmxops = &up_pinmux_ops,
++	.confops = &up_pinconf_ops,
++	.owner = THIS_MODULE,
++};
++
++static void up_led_brightness_set(struct led_classdev *cdev,
++				  enum led_brightness value)
++{
++	struct up_cpld_led_info *led = container_of(cdev,
++						    struct up_cpld_led_info,
++						    cdev);
++
++	cpld_set_value(led->cpld, led->offset, value != LED_OFF);
++}
++
++static const struct dmi_system_id up_board_id_table[] = {
++	{
++		.matches = {
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
++		},
++		.driver_data = (void *)&up_board
++	},
++	{}
++};
++
++static int up_pinctrl_probe(struct platform_device *pdev)
++{
++	struct up_pctrl *up_pctrl;
++	struct up_board_info *board;
++	const struct dmi_system_id *system_id;
++	unsigned offset;
++	int ret;
++
++	system_id = dmi_first_match(up_board_id_table);
++	if (!system_id)
++		return -ENXIO;
++
++	board = system_id->driver_data;
++
++	ret = up_gpio_pincfg_init(pdev, board);
++	if (ret)
++		return ret;
++
++	up_pctrl = devm_kzalloc(&pdev->dev, sizeof(*up_pctrl), GFP_KERNEL);
++	if (!up_pctrl)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, up_pctrl);
++
++	up_pctrl->pctldesc = up_pinctrl_desc;
++	up_pctrl->pctldesc.name = dev_name(&pdev->dev);
++	up_pctrl->pctldev = pinctrl_register(&up_pctrl->pctldesc,
++					     &pdev->dev, up_pctrl);
++	if (IS_ERR(up_pctrl->pctldev)) {
++		dev_err(&pdev->dev, "failed to register pinctrl driver\n");
++		return PTR_ERR(up_pctrl->pctldev);
++	}
++
++	up_pctrl->board = board;
++	up_pctrl->chip = up_gpio_chip;
++	up_pctrl->chip.label = dev_name(&pdev->dev);
++	up_pctrl->chip.parent = &pdev->dev;
++
++	ret = gpiochip_add(&up_pctrl->chip);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to add %s chip\n",
++			up_pctrl->chip.label);
++		return ret;
++	}
++
++	ret = gpiochip_add_pin_range(&up_pctrl->chip, dev_name(&pdev->dev),
++				     0, 0, N_GPIO);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to add GPIO pin range\n");
++		goto fail_add_pin_range;
++	}
++
++	ret = gpiochip_irqchip_add(&up_pctrl->chip, &up_gpio_irqchip, 0,
++				   handle_simple_irq, IRQ_TYPE_NONE);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to add IRQ chip\n");
++		goto fail_irqchip_add;
++	}
++
++	for (offset = 0; offset < up_pctrl->chip.ngpio; offset++) {
++		struct up_pin_info *pin = &board->pins[offset];
++		struct irq_data *irq_data;
++
++		pin->irq = irq_find_mapping(up_pctrl->chip.irqdomain, offset);
++		pin->soc_gpio.irq = gpiod_to_irq(pin->soc_gpio.desc);
++		irq_set_parent(pin->irq, pin->soc_gpio.irq);
++		irq_data = irq_get_irq_data(pin->irq);
++		irq_data->parent_data = irq_get_irq_data(pin->soc_gpio.irq);
++	}
++
++	/* Make sure the board has a CPLD */
++	if (board->cpld) {
++		struct up_cpld_info *cpld = board->cpld;
++		size_t i;
++
++		for (i = 0; i < cpld->num_leds; i++) {
++			struct up_cpld_led_info *led = &cpld->leds[i];
++
++			led->cpld = cpld;
++			led->cdev.brightness_set = up_led_brightness_set;
++			led->cdev.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,
++							"upboard:%s:",
++							led->name);
++			if (!led->cdev.name) {
++				ret = -ENOMEM;
++				goto fail_cpld_led;
++			}
++
++			ret = devm_led_classdev_register(&pdev->dev,
++							 &led->cdev);
++			if (ret)
++				goto fail_cpld_led;
++		}
++	}
++
++	return 0;
++
++fail_cpld_led:
++fail_irqchip_add:
++fail_add_pin_range:
++	gpiochip_remove(&up_pctrl->chip);
++
++	return ret;
++}
++
++static int up_pinctrl_remove(struct platform_device *pdev)
++{
++	struct up_pctrl *up_pctrl = platform_get_drvdata(pdev);
++
++	gpiochip_remove(&up_pctrl->chip);
++	pinctrl_unregister(up_pctrl->pctldev);
++
++	/* Disable the CPLD outputs */
++	if (up_pctrl->board->cpld)
++		gpiod_set_value(up_pctrl->board->cpld->oe_gpio.desc, 0);
++
++	return 0;
++}
++
++static struct platform_driver up_pinctrl_driver = {
++	.driver.name	= "up-pinctrl",
++	.driver.owner	= THIS_MODULE,
++	.probe		= up_pinctrl_probe,
++	.remove		= up_pinctrl_remove,
++};
++
++static int __init up_pinctrl_init(void)
++{
++	return platform_driver_register(&up_pinctrl_driver);
++}
++subsys_initcall(up_pinctrl_init);
++
++static void __exit up_pinctrl_exit(void)
++{
++	platform_driver_unregister(&up_pinctrl_driver);
++}
++module_exit(up_pinctrl_exit);
++
++MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
++MODULE_DESCRIPTION("Pin Control driver for UP Board I/O pin header");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:up-pinctrl");
+\ No newline at end of file
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0007-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch b/recipes-kernel/linux/files/0007-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch
new file mode 100755
index 0000000..448408d
--- /dev/null
+++ b/recipes-kernel/linux/files/0007-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch
@@ -0,0 +1,43 @@
+From 84946580cafe295cd41d2a4068fea24b8f13a431 Mon Sep 17 00:00:00 2001
+From: Carlos Calderon <carlos@emutex.com>
+Date: Mon, 8 Oct 2018 16:06:21 +0100
+Subject: [PATCH 07/30] acpi: acpi_node_add_pin_mapping added to header file.
+
+---
+ include/linux/acpi.h | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+diff --git a/include/linux/acpi.h b/include/linux/acpi.h
+index b9dbaa684f56..31b68b693418 100644
+--- a/include/linux/acpi.h
++++ b/include/linux/acpi.h
+@@ -1028,6 +1028,11 @@ void __acpi_handle_debug(struct _ddebug *descriptor, acpi_handle handle, const c
+ bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,
+ 				struct acpi_resource_gpio **agpio);
+ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index);
++int acpi_node_add_pin_mapping(struct fwnode_handle *fwnode,
++			      const char *propname,
++			      const char *pinctl_name,
++			      unsigned int pin_offset,
++			      unsigned int npins);
+ #else
+ static inline bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,
+ 					      struct acpi_resource_gpio **agpio)
+@@ -1038,6 +1043,14 @@ static inline int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
+ {
+ 	return -ENXIO;
+ }
++static inline int acpi_node_add_pin_mapping(struct fwnode_handle *fwnode,
++					    const char *propname,
++					    const char *pinctl_name,
++					    unsigned int pin_offset,
++					    unsigned int npins)
++{
++	return -ENXIO;
++}
+ #endif
+ 
+ /* Device properties */
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0007-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch b/recipes-kernel/linux/files/0007-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch
deleted file mode 100644
index 3c93fc6..0000000
--- a/recipes-kernel/linux/files/0007-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch
+++ /dev/null
@@ -1,1309 +0,0 @@
-From 438f9fdd3e41c9af362d81cba7542b51c7d8f1b0 Mon Sep 17 00:00:00 2001
-From: Carlos Calderon <carlos@emutex.com>
-Date: Thu, 4 Oct 2018 10:44:53 +0100
-Subject: [PATCH 10/19] up: pinctrl: Bring in legacy fpga and pinctrl driver
-
-This commits just copies the legacy UP board platform driver and the
-pinctrl/fpga one from ubilinux-3 branch.
-The only change made was to obey to the following commit:
-    58383c7 gpio: change member .dev to .parent
-
-Kernel config option to built-in UP support added in Kconfig&Makefile.
-
-UP1 board with FPGA1 protocol and old BIOS doesn't provide the necessary
-information via ACPI to the kernel, therefore the new MFD FPGA driver
-will not be loaded; instead this legacy platform driver will always be
-loaded and based on the platform detected will load or not the pinctrl
-one.
----
- drivers/platform/x86/Kconfig            |  15 +
- drivers/platform/x86/Makefile           |   1 +
- drivers/platform/x86/up_board.c         | 242 ++++++++
- drivers/platform/x86/up_board_pinctrl.c | 989 ++++++++++++++++++++++++++++++++
- 4 files changed, 1247 insertions(+)
- create mode 100644 drivers/platform/x86/up_board.c
- create mode 100644 drivers/platform/x86/up_board_pinctrl.c
-
-diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
-index 80b8795..0ca3c82 100644
---- a/drivers/platform/x86/Kconfig
-+++ b/drivers/platform/x86/Kconfig
-@@ -1139,6 +1139,21 @@ config SILEAD_DMI
- 	  with the OS-image for the device. This option supplies the missing
- 	  information. Enable this for x86 tablets with Silead touchscreens.
- 
-+config UPBOARD_LEGACY
-+	bool "UP Board platform extras"
-+	depends on ACPI && PINCTRL_CHERRYVIEW
-+	select GPIOLIB_IRQCHIP
-+	---help---
-+	This driver initialises the platform devices on the UP board.
-+	It supports UP Board with FPGA protocol V1. For UP2/UPCore or UP with
-+	updated BIOS and FPGA firmware, please have a look at MFD_UPBOARD_FPGA
-+	config option and the driver(s) behind.
-+	It includes a Pin Control driver, which creates a "virtual" GPIO chip,
-+	to transparently manage the buffers and mux switches between the SoC
-+	GPIO pins and the external pin header.  The GPIOs presented by the
-+	platform driver are numbered to emulate the Raspberry Pi 2 pin header
-+	layout to aid application portability.
-+
- endif # X86_PLATFORM_DEVICES
- 
- config PMC_ATOM
-diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
-index f9e3ae6..793a3c2 100644
---- a/drivers/platform/x86/Makefile
-+++ b/drivers/platform/x86/Makefile
-@@ -84,3 +84,4 @@ obj-$(CONFIG_PMC_ATOM)		+= pmc_atom.o
- obj-$(CONFIG_MLX_PLATFORM)	+= mlx-platform.o
- obj-$(CONFIG_MLX_CPLD_PLATFORM)	+= mlxcpld-hotplug.o
- obj-$(CONFIG_INTEL_TURBO_MAX_3) += intel_turbo_max_3.o
-+obj-$(CONFIG_UPBOARD_LEGACY)	+= up_board.o up_board_pinctrl.o
-diff --git a/drivers/platform/x86/up_board.c b/drivers/platform/x86/up_board.c
-new file mode 100644
-index 0000000..3acbed7
---- /dev/null
-+++ b/drivers/platform/x86/up_board.c
-@@ -0,0 +1,242 @@
-+/*
-+ * UP Board header pin GPIO driver.
-+ *
-+ * Copyright (c) 2016, Emutex Ltd.  All rights reserved.
-+ *
-+ * Author: Dan O'Donovan <dan@emutex.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms and conditions of the GNU General Public License,
-+ * version 2, as published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+#include <linux/module.h>
-+#include <linux/dmi.h>
-+#include <linux/platform_device.h>
-+#include <linux/pinctrl/machine.h>
-+#include <linux/pinctrl/pinconf-generic.h>
-+#include <linux/i2c.h>
-+#include <linux/spi/spi.h>
-+#include <linux/platform_data/pca953x.h>
-+#include <linux/regulator/fixed.h>
-+#include <linux/regulator/machine.h>
-+#include <linux/acpi.h>
-+
-+#define UP_BOARD_SPIDEV_BUS_NUM 2
-+#define UP_BOARD_SPIDEV_MAX_CLK 25000000
-+
-+struct up_board_info {
-+	struct pinctrl_map *pinmux_maps;
-+	unsigned num_pinmux_maps;
-+	int (*init_devices)(void);
-+};
-+
-+static bool spidev0 = true;
-+module_param(spidev0, bool, S_IRUGO);
-+MODULE_PARM_DESC(spidev0, "register a spidev device on SPI bus 2-0");
-+
-+static bool spidev1 = false;
-+module_param(spidev1, bool, S_IRUGO);
-+MODULE_PARM_DESC(spidev1, "register a spidev device on SPI bus 2-1");
-+
-+/* On the UP board, if the ODEn bit is set on the pad configuration
-+ * it seems to impair some functions on the I/O header such as UART, SPI
-+ * and even I2C.  So we disable it for all header pins by default.
-+ */
-+static unsigned long oden_disable_conf[] = {
-+	PIN_CONF_PACKED(PIN_CONFIG_DRIVE_PUSH_PULL, 0),
-+};
-+
-+#define UP_PIN_MAP_MUX_GROUP(d, p, f) \
-+	PIN_MAP_MUX_GROUP_DEFAULT(d, p, f "_grp", f)
-+
-+#define UP_PIN_MAP_CONF_ODEN(d, p, f) \
-+	PIN_MAP_CONFIGS_GROUP_DEFAULT(d, p, f "_grp", oden_disable_conf)
-+
-+/* Maps pin functions on UP Board I/O pin header to specific CHT SoC devices */
-+static struct pinctrl_map up_pinmux_maps[] __initdata = {
-+	UP_PIN_MAP_MUX_GROUP("8086228A:00", "up-pinctrl", "uart1"),
-+	UP_PIN_MAP_MUX_GROUP("808622C1:00", "up-pinctrl", "i2c0"),
-+	UP_PIN_MAP_MUX_GROUP("808622C1:01", "up-pinctrl", "i2c1"),
-+	UP_PIN_MAP_MUX_GROUP("808622A8:00", "up-pinctrl", "i2s0"),
-+	UP_PIN_MAP_MUX_GROUP("80862288:00", "up-pinctrl", "pwm0"),
-+	UP_PIN_MAP_MUX_GROUP("80862288:01", "up-pinctrl", "pwm1"),
-+	UP_PIN_MAP_MUX_GROUP("8086228E:01", "up-pinctrl", "spi2"),
-+	UP_PIN_MAP_MUX_GROUP("i2c-ADC081C:00", "up-pinctrl", "adc0"),
-+
-+	UP_PIN_MAP_MUX_GROUP("8086228A:00", "INT33FF:00", "uart1"),
-+	UP_PIN_MAP_MUX_GROUP("808622C1:00", "INT33FF:00", "i2c0"),
-+	UP_PIN_MAP_MUX_GROUP("808622C1:01", "INT33FF:00", "i2c1"),
-+	UP_PIN_MAP_MUX_GROUP("808622C1:02", "INT33FF:00", "i2c2"),
-+	UP_PIN_MAP_MUX_GROUP("808622A8:00", "INT33FF:00", "lpe"),
-+	UP_PIN_MAP_MUX_GROUP("80862288:00", "INT33FF:03", "pwm0"),
-+	UP_PIN_MAP_MUX_GROUP("80862288:01", "INT33FF:03", "pwm1"),
-+	UP_PIN_MAP_MUX_GROUP("8086228E:01", "INT33FF:03", "spi2"),
-+
-+	UP_PIN_MAP_CONF_ODEN("8086228A:00", "INT33FF:00", "uart1"),
-+	UP_PIN_MAP_CONF_ODEN("808622C1:00", "INT33FF:00", "i2c0"),
-+	UP_PIN_MAP_CONF_ODEN("808622C1:01", "INT33FF:00", "i2c1"),
-+	UP_PIN_MAP_CONF_ODEN("808622A8:00", "INT33FF:00", "lpe"),
-+	UP_PIN_MAP_CONF_ODEN("80862288:00", "INT33FF:03", "pwm0"),
-+	UP_PIN_MAP_CONF_ODEN("80862288:01", "INT33FF:03", "pwm1"),
-+	UP_PIN_MAP_CONF_ODEN("8086228E:01", "INT33FF:03", "spi2"),
-+};
-+
-+static struct platform_device *up_pinctrl_dev;
-+
-+static struct regulator_consumer_supply vref3v3_consumers[] = {
-+	REGULATOR_SUPPLY("vref", "i2c-ADC081C:00"),
-+};
-+
-+static struct spi_board_info up_spidev_info __initdata = {
-+	.modalias	= "spidev",
-+	.bus_num	= UP_BOARD_SPIDEV_BUS_NUM,
-+	.max_speed_hz   = UP_BOARD_SPIDEV_MAX_CLK,
-+};
-+
-+static int __init
-+up_board_init_devices(void)
-+{
-+#if IS_ENABLED(CONFIG_REGULATOR)
-+	struct platform_device *vreg;
-+
-+	vreg = regulator_register_always_on(0, "fixed-3.3V",
-+					    vref3v3_consumers,
-+					    ARRAY_SIZE(vref3v3_consumers),
-+					    3300000);
-+	if (!vreg) {
-+		pr_err("Failed to register UP Board ADC vref regulator");
-+		return -ENODEV;
-+	}
-+#else
-+	pr_dbg("Voltage and Current Regulator Support NOT enabled!");
-+#endif
-+
-+	return 0;
-+}
-+
-+static struct up_board_info up_board_info __initdata = {
-+	.pinmux_maps = up_pinmux_maps,
-+	.num_pinmux_maps = ARRAY_SIZE(up_pinmux_maps),
-+	.init_devices = up_board_init_devices,
-+};
-+
-+static const struct dmi_system_id up_board_id_table[] = {
-+	{
-+		.matches = {
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
-+		},
-+		.driver_data = (void *)&up_board_info
-+	},
-+	{
-+		.matches = {
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.5"),
-+		},
-+		.driver_data = (void *)&up_board_info
-+	},
-+	{ }
-+};
-+
-+#define UPFPGA_PROTOCOL_V1_HRV 1
-+
-+static int __init
-+up_board_init(void) {
-+	const struct dmi_system_id *system_id;
-+	struct up_board_info *board_info;
-+	acpi_status status;
-+	unsigned long long hrv;
-+	int ret;
-+
-+	system_id = dmi_first_match(up_board_id_table);
-+	if (!system_id)
-+		return -ENXIO;
-+
-+	status = acpi_evaluate_integer(NULL, "\\_SB.PCTL._HRV", NULL, &hrv);
-+	if (ACPI_SUCCESS(status) && (hrv != UPFPGA_PROTOCOL_V1_HRV)) {
-+		pr_debug("Unsupported PCTL revision: %llu", hrv);
-+		return -ENODEV;
-+	}
-+
-+	board_info = system_id->driver_data;
-+
-+	/* Register pin control mappings specific to board version */
-+	if (board_info->pinmux_maps) {
-+		ret = pinctrl_register_mappings(board_info->pinmux_maps,
-+						board_info->num_pinmux_maps);
-+		if (ret) {
-+			pr_err("Failed to register UP Board pinctrl mapping");
-+			return ret;
-+		}
-+	}
-+
-+	/* Register devices specific to board version */
-+	if (board_info->init_devices) {
-+		ret = board_info->init_devices();
-+		if (ret) {
-+			pr_err("Failed to register UP Board devices");
-+			return ret;
-+		}
-+	}
-+
-+	/* Register devices common to all board versions */
-+	if (spidev0) {
-+		up_spidev_info.chip_select = 0;
-+		ret = spi_register_board_info(&up_spidev_info, 1);
-+		if (ret) {
-+			pr_err("Failed to register UP Board spidev0 device");
-+			return -ENODEV;
-+		}
-+	}
-+	if (spidev1) {
-+		up_spidev_info.chip_select = 1;
-+		ret = spi_register_board_info(&up_spidev_info, 1);
-+		if (ret) {
-+			pr_err("Failed to register UP Board spidev1 device");
-+			return -ENODEV;
-+		}
-+	}
-+
-+	/* Create a virtual device to manage the UP Board GPIO pin header */
-+	up_pinctrl_dev = platform_device_alloc("up-pinctrl", -1);
-+	if (!up_pinctrl_dev) {
-+		pr_err("Failed to allocate UP pinctrl platform device");
-+		return -ENOMEM;
-+	}
-+
-+	ret = platform_device_add(up_pinctrl_dev);
-+	if (ret) {
-+		pr_err("Failed to allocate UP pinctrl platform device");
-+		platform_device_put(up_pinctrl_dev);
-+		return ret;
-+	}
-+
-+	return 0;
-+}
-+
-+static void __exit
-+up_board_exit(void)
-+{
-+	platform_device_unregister(up_pinctrl_dev);
-+}
-+
-+/* Using arch_initcall to ensure that i2c devices are registered
-+ * before the I2C adapters are enumerated
-+ */
-+arch_initcall(up_board_init);
-+module_exit(up_board_exit);
-+
-+MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
-+MODULE_DESCRIPTION("Platform driver for UP Board");
-+MODULE_LICENSE("GPL v2");
-+MODULE_ALIAS("dmi:*:svnAAEON*:rnUP-CHT01:*");
-\ No newline at end of file
-diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
-new file mode 100644
-index 0000000..e6c9de4
---- /dev/null
-+++ b/drivers/platform/x86/up_board_pinctrl.c
-@@ -0,0 +1,989 @@
-+/*
-+ * UP Board header pin GPIO driver.
-+ *
-+ * Copyright (c) 2016, Emutex Ltd.  All rights reserved.
-+ *
-+ * Author: Dan O'Donovan <dan@emutex.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms and conditions of the GNU General Public License,
-+ * version 2, as published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+#include <linux/gpio.h>
-+#include <linux/kernel.h>
-+#include <linux/leds.h>
-+#include <linux/module.h>
-+#include <linux/dmi.h>
-+#include <linux/pinctrl/pinctrl.h>
-+#include <linux/pinctrl/pinmux.h>
-+#include <linux/pinctrl/pinconf.h>
-+#include <linux/pinctrl/pinconf-generic.h>
-+#include <linux/platform_device.h>
-+#include <linux/interrupt.h>
-+
-+/*
-+ * The UP Board features an external 40-pin header for I/O functions including
-+ * GPIO, I2C, UART, SPI, PWM and I2S, similar in layout to the Raspberry Pi 2.
-+ * At the heart of the UP Board is an Intel X5-Z8350 "Cherry Trail" SoC, which
-+ * provides the I/O functions for these pins at 1.8V logic levels.
-+ *
-+ * Additional buffers and mux switches are used between the SoC and the I/O pin
-+ * header to convert between the 1.8V SoC I/O and the 3.3V levels required at
-+ * the pin header, with sufficient current source/sink capability for
-+ * LV-TTL/LV-CMOS compatibility.  These buffers and mux switches require
-+ * run-time configuration based on the pin function or GPIO direction selected
-+ * by the user.
-+ *
-+ * The purpose of this driver is to manage the complexity of the buffer
-+ * configuration so that application code can transparently access the I/O
-+ * functions on the external pins through standard kernel interfaces.  It
-+ * instantiates a gpio and pinctrl device, and effectively acts as a "shim"
-+ * between application code and the underlying Cherry Trail GPIO driver.
-+ */
-+
-+/* References to Cherry Trail GPIO chip driver */
-+struct up_soc_gpiochip_info {
-+	char *name;
-+	struct gpio_chip *chip;
-+};
-+
-+/* References to Cherry Trail GPIO pins */
-+struct up_soc_gpio_info {
-+	struct up_soc_gpiochip_info *ci;
-+	struct gpio_desc *desc;
-+	unsigned offset;
-+	int gpio;
-+	int irq;
-+	int flags;
-+};
-+
-+/* Information for a single I/O pin on the UP board */
-+struct up_pin_info {
-+	struct up_soc_gpio_info soc_gpio;
-+	int irq;
-+	int dir_ctrl_pin;
-+	int dir_in;
-+	int dir_out;
-+	int func_dir;
-+	int mux_ctrl_pin;
-+	int mux_gpio;
-+	int mux_func;
-+	bool func_enabled;
-+};
-+
-+struct up_cpld_led_info {
-+	unsigned offset;
-+	const char *name;
-+	struct up_cpld_info *cpld;
-+	struct led_classdev cdev;
-+};
-+
-+/* Information for the CPLD featured on later UP board revisions */
-+struct up_cpld_info {
-+	struct up_soc_gpio_info strobe_gpio;
-+	struct up_soc_gpio_info reset_gpio;
-+	struct up_soc_gpio_info data_in_gpio;
-+	struct up_soc_gpio_info data_out_gpio;
-+	struct up_soc_gpio_info oe_gpio;
-+	u64 dir_reg;
-+	bool do_verify;
-+	bool do_strobe_after_write;
-+	unsigned dir_reg_size;
-+	struct up_cpld_led_info *leds;
-+	unsigned num_leds;
-+	spinlock_t lock;
-+};
-+
-+struct up_board_info {
-+	struct up_pin_info *pins;
-+	struct up_cpld_info *cpld;
-+};
-+
-+/* Context variables for this driver */
-+struct up_pctrl {
-+	struct up_board_info *board;
-+	struct gpio_chip chip;
-+	struct pinctrl_desc pctldesc;
-+	struct pinctrl_dev *pctldev;
-+};
-+
-+/* Pin group information */
-+struct up_pingroup {
-+	const char *name;
-+	const unsigned *pins;
-+	size_t npins;
-+};
-+
-+/* Pin function information */
-+struct up_function {
-+	const char *name;
-+	const char * const *groups;
-+	size_t ngroups;
-+};
-+
-+/* The Cherry Trail SoC has 4 independent GPIO controllers */
-+static struct up_soc_gpiochip_info chip_cht_SW = { .name = "INT33FF:00" };
-+static struct up_soc_gpiochip_info chip_cht_N  = { .name = "INT33FF:01" };
-+static struct up_soc_gpiochip_info chip_cht_E  = { .name = "INT33FF:02" };
-+static struct up_soc_gpiochip_info chip_cht_SE = { .name = "INT33FF:03" };
-+
-+#define SOC_GPIO(c, o, f)		\
-+	{				\
-+		.ci	= (c),		\
-+		.offset	= (o),		\
-+		.flags	= (f),		\
-+	}
-+#define SOC_GPIO_INPUT(c, o) SOC_GPIO(c, o, GPIOF_IN)
-+#define SOC_GPIO_OUTPUT(c, o) SOC_GPIO(c, o, GPIOF_OUT_INIT_LOW)
-+#define GPIO_PIN(c, o, dpin, din, dout, dfunc, mpin, mgpio, mfunc) \
-+	{						\
-+		.soc_gpio.ci		= (c),		\
-+		.soc_gpio.offset	= (o),		\
-+		.dir_ctrl_pin		= (dpin),	\
-+		.dir_in			= (din),	\
-+		.dir_out		= (dout),	\
-+		.func_dir		= (dfunc),	\
-+		.mux_ctrl_pin		= (mpin),	\
-+		.mux_gpio		= (mgpio),	\
-+		.mux_func		= (mfunc),	\
-+		.func_enabled		= false,	\
-+	}
-+
-+#define FDIR_NONE -1
-+#define FDIR_OUT  1
-+#define FDIR_IN   0
-+
-+#define NONE -1
-+
-+#define PIN_GROUP(n, p)				\
-+	{					\
-+		.name = (n),			\
-+		.pins = (p),			\
-+		.npins = ARRAY_SIZE((p)),	\
-+	}
-+
-+#define FUNCTION(n, g)				\
-+	{					\
-+		.name = (n),			\
-+		.groups = (g),			\
-+		.ngroups = ARRAY_SIZE((g)),	\
-+	}
-+
-+#define GPIO_PINRANGE(start, end)		\
-+	{					\
-+		.base = (start),		\
-+		.npins = (end) - (start) $ 1,	\
-+	}
-+
-+#define N_GPIO 28
-+
-+/* Initial configuration assumes all pins as GPIO inputs */
-+#define CPLD_DIR_REG_INIT	(0x00FFFFFFFULL)
-+
-+/* Convenience macros to populate the pin info tables below */
-+#define GPIO_PIN_UP(c, o, dpin, dfunc, mpin, mgpio, mfunc)	\
-+	GPIO_PIN(c, o, dpin, 1, 0, dfunc, mpin, mgpio, mfunc)
-+#define GPIO_PIN_UP_NO_MUX(c, o, dpin, dfunc)			\
-+	GPIO_PIN_UP(c, o, dpin, dfunc, NONE, -1, -1)
-+
-+/*
-+ * Table of I/O pins on the 40-pin header of the UP Board (version-specific)
-+ */
-+/* UP Board uses a CPLD to provide I/O signal buffers and mux switching */
-+static struct up_pin_info up_pins[N_GPIO] = {
-+	GPIO_PIN_UP(&chip_cht_SW, 33,  9, FDIR_OUT, 28, 0, 1),	/*  0 */
-+	GPIO_PIN_UP(&chip_cht_SW, 37, 23, FDIR_OUT, 28, 0, 1),	/*  1 */
-+	GPIO_PIN_UP(&chip_cht_SW, 32,  0, FDIR_OUT, 29, 0, 1),	/*  2 */
-+	GPIO_PIN_UP(&chip_cht_SW, 35,  1, FDIR_OUT, 29, 0, 1),	/*  3 */
-+	GPIO_PIN_UP(&chip_cht_E,  18,  2, FDIR_IN,  30, 0, 1),	/*  4 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  21, 10, FDIR_NONE),		/*  5 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  12, 11, FDIR_NONE),		/*  6 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 48, 22, FDIR_NONE),		/*  7 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  7, 21, FDIR_OUT),		/*  8 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  3,  7, FDIR_IN),		/*  9 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  6,  6, FDIR_OUT),		/* 10 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  4,  8, FDIR_OUT),		/* 11 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  5, 24, FDIR_OUT),		/* 12 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  1, 12, FDIR_OUT),		/* 13 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 13, 15, FDIR_OUT),		/* 14 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  9, 16, FDIR_IN),		/* 15 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 11, 25, FDIR_IN),		/* 16 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  8,  3, FDIR_OUT),		/* 17 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 50, 17, FDIR_OUT),		/* 18 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 54, 13, FDIR_OUT),		/* 19 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 52, 26, FDIR_IN),		/* 20 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 55, 27, FDIR_OUT),		/* 21 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 12,  5, FDIR_OUT),		/* 22 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 15, 18, FDIR_OUT),		/* 23 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 18, 19, FDIR_OUT),		/* 24 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 11, 20, FDIR_OUT),		/* 25 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 14, 14, FDIR_OUT),		/* 26 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  8,  4, FDIR_OUT),		/* 27 */
-+};
-+
-+static struct up_cpld_led_info up_cpld_leds[] = {
-+	{ .offset = 31, .name = "yellow", },
-+	{ .offset = 32, .name = "green", },
-+	{ .offset = 33, .name = "red", },
-+};
-+
-+static struct up_cpld_info up_cpld = {
-+	.strobe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_N, 21),
-+	.reset_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 15),
-+	.data_in_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 13),
-+	.data_out_gpio		= SOC_GPIO_INPUT(&chip_cht_E, 23),
-+	.oe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_SW, 43),
-+	.dir_reg		= CPLD_DIR_REG_INIT,
-+	.do_verify		= true,
-+	.do_strobe_after_write	= false,
-+	.dir_reg_size		= 34,
-+	.leds			= up_cpld_leds,
-+	.num_leds		= ARRAY_SIZE(up_cpld_leds),
-+};
-+
-+static struct up_board_info up_board = {
-+	.pins = up_pins,
-+	.cpld = &up_cpld,
-+};
-+
-+/* The layout and numbering is designed to emulate the Raspberry Pi 2 */
-+static const struct pinctrl_pin_desc up_pins_pi[] = {
-+	PINCTRL_PIN(0,  "I2C0_SDA"),
-+	PINCTRL_PIN(1,  "I2C0_SCL"),
-+	PINCTRL_PIN(2,  "I2C1_SDA"),
-+	PINCTRL_PIN(3,  "I2C1_SCL"),
-+	PINCTRL_PIN(4,  "GPIO4"),
-+	PINCTRL_PIN(5,  "GPIO5"),
-+	PINCTRL_PIN(6,  "GPIO6"),
-+	PINCTRL_PIN(7,  "SPI_CS1"),
-+	PINCTRL_PIN(8,  "SPI_CS0"),
-+	PINCTRL_PIN(9,  "SPI_MISO"),
-+	PINCTRL_PIN(10, "SPI_MOSI"),
-+	PINCTRL_PIN(11, "SPI_CLK"),
-+	PINCTRL_PIN(12, "PWM0"),
-+	PINCTRL_PIN(13, "PWM1"),
-+	PINCTRL_PIN(14, "UART1_TX"),
-+	PINCTRL_PIN(15, "UART1_RX"),
-+	PINCTRL_PIN(16, "GPIO16"),
-+	PINCTRL_PIN(17, "GPIO17"),
-+	PINCTRL_PIN(18, "I2S_CLK"),
-+	PINCTRL_PIN(19, "I2S_FRM"),
-+	PINCTRL_PIN(20, "I2S_DIN"),
-+	PINCTRL_PIN(21, "I2S_DOUT"),
-+	PINCTRL_PIN(22, "GPIO22"),
-+	PINCTRL_PIN(23, "GPIO23"),
-+	PINCTRL_PIN(24, "GPIO24"),
-+	PINCTRL_PIN(25, "GPIO25"),
-+	PINCTRL_PIN(26, "GPIO26"),
-+	PINCTRL_PIN(27, "GPIO27"),
-+};
-+
-+static const unsigned uart1_pins[] = { 14, 15, 16, 17 };
-+static const unsigned uart2_pins[] = { 25, 27 };
-+static const unsigned i2c0_pins[]  = { 0, 1 };
-+static const unsigned i2c1_pins[]  = { 2, 3 };
-+static const unsigned spi2_pins[]  = { 8, 9, 10, 11 };
-+static const unsigned i2s0_pins[]  = { 18, 19, 20, 21 };
-+static const unsigned pwm0_pins[]  = { 12 };
-+static const unsigned pwm1_pins[]  = { 13 };
-+static const unsigned adc0_pins[]  = { 4 };
-+
-+static const struct up_pingroup pin_groups[] = {
-+	PIN_GROUP("uart1_grp", uart1_pins),
-+	PIN_GROUP("uart2_grp", uart2_pins),
-+	PIN_GROUP("i2c0_grp", i2c0_pins),
-+	PIN_GROUP("i2c1_grp", i2c1_pins),
-+	PIN_GROUP("spi2_grp", spi2_pins),
-+	PIN_GROUP("i2s0_grp", i2s0_pins),
-+	PIN_GROUP("pwm0_grp", pwm0_pins),
-+	PIN_GROUP("pwm1_grp", pwm1_pins),
-+	PIN_GROUP("adc0_grp", adc0_pins),
-+};
-+
-+static const char * const uart1_groups[] = { "uart1_grp" };
-+static const char * const uart2_groups[] = { "uart2_grp" };
-+static const char * const i2c0_groups[]  = { "i2c0_grp" };
-+static const char * const i2c1_groups[]  = { "i2c1_grp" };
-+static const char * const spi2_groups[]  = { "spi2_grp" };
-+static const char * const i2s0_groups[]  = { "i2s0_grp" };
-+static const char * const pwm0_groups[]  = { "pwm0_grp" };
-+static const char * const pwm1_groups[]  = { "pwm1_grp" };
-+static const char * const adc0_groups[]  = { "adc0_grp" };
-+
-+static const struct up_function pin_functions[] = {
-+	FUNCTION("uart1", uart1_groups),
-+	FUNCTION("uart2", uart2_groups),
-+	FUNCTION("i2c0",  i2c0_groups),
-+	FUNCTION("i2c1",  i2c1_groups),
-+	FUNCTION("spi2",  spi2_groups),
-+	FUNCTION("i2s0",  i2s0_groups),
-+	FUNCTION("pwm0",  pwm0_groups),
-+	FUNCTION("pwm1",  pwm1_groups),
-+	FUNCTION("adc0",  adc0_groups),
-+};
-+
-+/* On the UP board, the header pin level shifting and mux switching is
-+ * controlled by a dedicated CPLD with proprietary firmware
-+ *
-+ * The CPLD is responsible for connecting and translating 1.8V GPIO signals from
-+ * the SoC to the 28 GPIO header pins at 3.3V, and for this it needs to be
-+ * configured with direction (input/output) for each GPIO.  In addition, it
-+ * manages 3 mux switches (2 for I2C bus pins, 1 for ADC pin) which need to be
-+ * configured on/off, and 3 LEDs.
-+ *
-+ * A register value is loaded into the CPLD at run-time to configure the
-+ * 28 GPIO level shifters, 3 mux switches and 3 LEDs.  This register value is
-+ * loaded via a 2-wire data interface consisting of a strobe and data line.  The
-+ * data line is sampled on each rising edge that appears on the strobe line.  A
-+ * reset signal (active low) is used to reset internal counters and state prior
-+ * to loading a new register value.  An output-enable signal is provided,
-+ * initially disabled which puts all header pins in a HiZ state until a valid
-+ * pin configuration is loaded by this driver.
-+ *
-+ * The register value is clocked into the CPLD bit-by-bit, and then read back.
-+ * A total of 69 rising edges on the strobe signal are required, following the
-+ * reset pulse, before the new register value is "latched" by the CPLD.
-+ */
-+static int cpld_configure(struct up_cpld_info *cpld)
-+{
-+	u64 dir_reg_verify = 0;
-+	int i;
-+
-+	/* Reset the CPLD internal counters */
-+	gpiod_set_value(cpld->reset_gpio.desc, 0);
-+	gpiod_set_value(cpld->reset_gpio.desc, 1);
-+
-+	/* Update the CPLD dir register */
-+	for (i = cpld->dir_reg_size - 1; i >= 0; i--) {
-+		/* Bring STB low initially */
-+		gpiod_set_value(cpld->strobe_gpio.desc, 0);
-+		/* Load the next bit value, MSb first */
-+		gpiod_set_value(cpld->data_in_gpio.desc,
-+				(cpld->dir_reg >> i) & 0x1);
-+		/* Bring STB high to latch the bit value */
-+		gpiod_set_value(cpld->strobe_gpio.desc, 1);
-+	}
-+
-+	if (cpld->do_strobe_after_write) {
-+		/* Issue a dummy STB cycle after writing the register value */
-+		gpiod_set_value(cpld->strobe_gpio.desc, 0);
-+		gpiod_set_value(cpld->strobe_gpio.desc, 1);
-+	}
-+
-+	/* Read back the value */
-+	for (i = cpld->dir_reg_size - 1; i >= 0; i--) {
-+		/* Cycle the strobe and read the data pin */
-+		gpiod_set_value(cpld->strobe_gpio.desc, 0);
-+		gpiod_set_value(cpld->strobe_gpio.desc, 1);
-+		dir_reg_verify |=
-+			(u64)gpiod_get_value(cpld->data_out_gpio.desc) << i;
-+	}
-+
-+	/* Verify that the CPLD dir register was written successfully
-+	 * In some hardware revisions, data_out_gpio isn't actually
-+	 * connected so we skip this step if do_verify is not set
-+	 */
-+	if (cpld->do_verify && (dir_reg_verify != cpld->dir_reg)) {
-+		pr_err("CPLD verify error (expected: %llX, actual: %llX)\n",
-+		       cpld->dir_reg, dir_reg_verify);
-+		return -EIO;
-+	}
-+
-+	/* Issue a dummy STB cycle to latch the dir register updates */
-+	gpiod_set_value(cpld->strobe_gpio.desc, 0);
-+	gpiod_set_value(cpld->strobe_gpio.desc, 1);
-+
-+	return 0;
-+}
-+
-+static int cpld_set_value(struct up_cpld_info *cpld, unsigned int offset,
-+			  int value)
-+{
-+	u64 old_regval;
-+	int ret = 0;
-+
-+	spin_lock(&cpld->lock);
-+
-+	old_regval = cpld->dir_reg;
-+
-+	if (value)
-+		cpld->dir_reg |= 1ULL << offset;
-+	else
-+		cpld->dir_reg &= ~(1ULL << offset);
-+
-+	/* Only update the CPLD register if it has changed */
-+	if (cpld->dir_reg != old_regval)
-+		ret = cpld_configure(cpld);
-+
-+	spin_unlock(&cpld->lock);
-+
-+	return ret;
-+}
-+
-+static int up_pincfg_set(struct up_board_info *board, int offset, int value)
-+{
-+	if (board->cpld)
-+		return cpld_set_value(board->cpld, offset, value);
-+
-+	gpio_set_value_cansleep(offset, value);
-+	return 0;
-+}
-+
-+static inline struct up_pctrl *gc_to_up_pctrl(struct gpio_chip *gc)
-+{
-+	return container_of(gc, struct up_pctrl, chip);
-+}
-+
-+static int up_gpiochip_match(struct gpio_chip *chip, void *data)
-+{
-+	return !strcmp(chip->label, data);
-+}
-+
-+static int up_soc_gpio_resolve(struct platform_device *pdev,
-+			       struct up_soc_gpio_info *gpio_info)
-+{
-+	struct up_soc_gpiochip_info *ci = gpio_info->ci;
-+
-+	if (!ci->chip) {
-+		ci->chip = gpiochip_find(ci->name, up_gpiochip_match);
-+		if (!ci->chip)
-+			return -EPROBE_DEFER;
-+	}
-+	gpio_info->gpio = ci->chip->base + gpio_info->offset;
-+	gpio_info->desc = gpio_to_desc(gpio_info->gpio);
-+	if (!gpio_info->desc) {
-+		dev_err(&pdev->dev, "Failed to get descriptor for gpio %d\n",
-+			gpio_info->gpio);
-+		return -EINVAL;
-+	}
-+
-+	return 0;
-+}
-+
-+static int up_gpio_pincfg_cpld(struct platform_device *pdev,
-+			       struct up_board_info *board)
-+{
-+	struct up_cpld_info *cpld = board->cpld;
-+	struct up_soc_gpio_info *cpld_gpios[] = {
-+		&cpld->strobe_gpio,
-+		&cpld->reset_gpio,
-+		&cpld->data_in_gpio,
-+		&cpld->data_out_gpio,
-+		&cpld->oe_gpio,
-+	};
-+	int i, ret;
-+
-+	spin_lock_init(&cpld->lock);
-+
-+	/* Initialise the CPLD config input GPIOs as outputs, initially low */
-+	for (i = 0; i < ARRAY_SIZE(cpld_gpios); i++) {
-+		struct up_soc_gpio_info *gpio_info = cpld_gpios[i];
-+
-+		ret = up_soc_gpio_resolve(pdev, gpio_info);
-+		if (ret)
-+			return ret;
-+
-+		ret = devm_gpio_request_one(&pdev->dev, gpio_info->gpio,
-+					    gpio_info->flags,
-+					    dev_name(&pdev->dev));
-+		if (ret)
-+			return ret;
-+	}
-+
-+	/* Load initial CPLD configuration (all pins set for GPIO input) */
-+	ret = cpld_configure(board->cpld);
-+	if (ret) {
-+		dev_err(&pdev->dev, "CPLD initialisation failed\n");
-+		return ret;
-+	}
-+
-+	/* Enable the CPLD outputs after a valid configuration has been set */
-+	gpiod_set_value(cpld->oe_gpio.desc, 1);
-+
-+	return 0;
-+}
-+
-+static int up_gpio_pincfg_init(struct platform_device *pdev,
-+			       struct up_board_info *board)
-+{
-+	unsigned i;
-+	int ret;
-+
-+	/* Find the Cherry Trail GPIO descriptors corresponding
-+	 * with each GPIO pin on the UP Board I/O header
-+	 */
-+	for (i = 0; i < N_GPIO; i++) {
-+		struct up_pin_info *pin = &board->pins[i];
-+
-+		ret = up_soc_gpio_resolve(pdev, &pin->soc_gpio);
-+		if (ret)
-+			return ret;
-+
-+		/* Ensure the GPIO pins are configured as inputs initially */
-+		ret = gpiod_direction_input(pin->soc_gpio.desc);
-+		if (ret) {
-+			dev_err(&pdev->dev, "GPIO direction init failed\n");
-+			return ret;
-+		}
-+	}
-+
-+	return up_gpio_pincfg_cpld(pdev, board);
-+}
-+
-+static irqreturn_t up_gpio_irq_handler(int irq, void *data)
-+{
-+	struct up_pin_info *pin = (struct up_pin_info *)data;
-+
-+	generic_handle_irq(pin->irq);
-+	return IRQ_HANDLED;
-+}
-+
-+static unsigned int up_gpio_irq_startup(struct irq_data *data)
-+{
-+	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	unsigned offset = irqd_to_hwirq(data);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+
-+	return request_irq(pin->soc_gpio.irq, up_gpio_irq_handler,
-+			   IRQF_ONESHOT, dev_name(gc->parent), pin);
-+}
-+
-+static void up_gpio_irq_shutdown(struct irq_data *data)
-+{
-+	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	unsigned offset = irqd_to_hwirq(data);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+
-+	free_irq(pin->soc_gpio.irq, pin);
-+}
-+
-+static struct irq_chip up_gpio_irqchip = {
-+	.name = "up-gpio",
-+	.irq_startup = up_gpio_irq_startup,
-+	.irq_shutdown = up_gpio_irq_shutdown,
-+	.irq_enable = irq_chip_enable_parent,
-+	.irq_disable = irq_chip_disable_parent,
-+	.irq_mask = irq_chip_mask_parent,
-+	.irq_unmask = irq_chip_unmask_parent,
-+	.irq_ack = irq_chip_ack_parent,
-+	.irq_set_type = irq_chip_set_type_parent,
-+};
-+
-+static int up_gpio_dir_in(struct gpio_chip *gc, unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+	int ret;
-+
-+	ret = gpiod_direction_input(desc);
-+	if (ret)
-+		return ret;
-+
-+	return pinctrl_gpio_direction_input(gc->base + offset);
-+}
-+
-+static int up_gpio_dir_out(struct gpio_chip *gc, unsigned offset, int value)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+	int ret;
-+
-+	ret = pinctrl_gpio_direction_output(gc->base + offset);
-+	if (ret)
-+		return ret;
-+
-+	return gpiod_direction_output(desc, value);
-+}
-+
-+static int up_gpio_get_dir(struct gpio_chip *gc, unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+
-+	return gpiod_get_direction(desc);
-+}
-+
-+static int up_gpio_request(struct gpio_chip *gc, unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+
-+	pinctrl_request_gpio(gc->base + offset);
-+	return gpio_request(desc_to_gpio(desc), gc->label);
-+}
-+
-+static void up_gpio_free(struct gpio_chip *gc, unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+
-+	pinctrl_free_gpio(gc->base + offset);
-+	gpio_free(desc_to_gpio(desc));
-+}
-+
-+static int up_gpio_get(struct gpio_chip *gc, unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+
-+	return gpiod_get_value(desc);
-+}
-+
-+static void up_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
-+{
-+	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+	struct gpio_desc *desc = pin->soc_gpio.desc;
-+
-+	gpiod_set_value(desc, value);
-+}
-+
-+static struct gpio_chip up_gpio_chip = {
-+	.owner			= THIS_MODULE,
-+	.ngpio			= N_GPIO,
-+	.request		= up_gpio_request,
-+	.free			= up_gpio_free,
-+	.get_direction		= up_gpio_get_dir,
-+	.direction_input	= up_gpio_dir_in,
-+	.direction_output	= up_gpio_dir_out,
-+	.get			= up_gpio_get,
-+	.set			= up_gpio_set,
-+};
-+
-+static int up_get_groups_count(struct pinctrl_dev *pctldev)
-+{
-+	return ARRAY_SIZE(pin_groups);
-+}
-+
-+static const char *up_get_group_name(struct pinctrl_dev *pctldev,
-+				     unsigned group)
-+{
-+	return pin_groups[group].name;
-+}
-+
-+static int up_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,
-+			     const unsigned **pins, unsigned *npins)
-+{
-+	*pins = pin_groups[group].pins;
-+	*npins = pin_groups[group].npins;
-+	return 0;
-+}
-+
-+static const struct pinctrl_ops up_pinctrl_ops = {
-+	.get_groups_count = up_get_groups_count,
-+	.get_group_name = up_get_group_name,
-+	.get_group_pins = up_get_group_pins,
-+};
-+
-+static int up_get_functions_count(struct pinctrl_dev *pctldev)
-+{
-+	return ARRAY_SIZE(pin_functions);
-+}
-+
-+static const char *up_get_function_name(struct pinctrl_dev *pctldev,
-+					unsigned function)
-+{
-+	return pin_functions[function].name;
-+}
-+
-+static int up_get_function_groups(struct pinctrl_dev *pctldev,
-+				  unsigned function,
-+				  const char * const **groups,
-+				  unsigned * const ngroups)
-+{
-+	*groups = pin_functions[function].groups;
-+	*ngroups = pin_functions[function].ngroups;
-+	return 0;
-+}
-+
-+static int up_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,
-+			     unsigned group)
-+{
-+	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
-+	const struct up_pingroup *grp = &pin_groups[group];
-+	int i;
-+
-+	for (i = 0; i < grp->npins; i++) {
-+		int offset = grp->pins[i];
-+		struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+
-+		if ((pin->dir_ctrl_pin != NONE) && (pin->func_dir != FDIR_NONE))
-+			up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
-+				      pin->func_dir == FDIR_IN ?
-+				      pin->dir_in : pin->dir_out);
-+		if (pin->mux_ctrl_pin != NONE)
-+			up_pincfg_set(up_pctrl->board, pin->mux_ctrl_pin,
-+				      pin->mux_func);
-+		pin->func_enabled = true;
-+	}
-+
-+	return 0;
-+}
-+
-+static int up_gpio_set_direction(struct pinctrl_dev *pctldev,
-+				 struct pinctrl_gpio_range *range,
-+				 unsigned offset, bool input)
-+{
-+	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+
-+	if (pin->dir_ctrl_pin != NONE)
-+		up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
-+			      input ? pin->dir_in : pin->dir_out);
-+
-+	return 0;
-+}
-+
-+static int up_gpio_request_enable(struct pinctrl_dev *pctldev,
-+				  struct pinctrl_gpio_range *range,
-+				  unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+
-+	if (pin->mux_ctrl_pin != NONE)
-+		up_pincfg_set(up_pctrl->board, pin->mux_ctrl_pin,
-+			      pin->mux_gpio);
-+	if (pin->dir_ctrl_pin != NONE)
-+		up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
-+			      gpiod_get_direction(pin->soc_gpio.desc)
-+			      ? pin->dir_in : pin->dir_out);
-+
-+	return 0;
-+}
-+
-+static void up_gpio_disable_free(struct pinctrl_dev *pctldev,
-+				 struct pinctrl_gpio_range *range,
-+				 unsigned offset)
-+{
-+	struct up_pctrl *up_pctrl = pinctrl_dev_get_drvdata(pctldev);
-+	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
-+
-+	if (pin->func_enabled) {
-+		if ((pin->dir_ctrl_pin != NONE) && (pin->func_dir != FDIR_NONE))
-+			up_pincfg_set(up_pctrl->board, pin->dir_ctrl_pin,
-+				      pin->func_dir == FDIR_IN ?
-+				      pin->dir_in : pin->dir_out);
-+		if (pin->mux_ctrl_pin != NONE)
-+			up_pincfg_set(up_pctrl->board, pin->mux_ctrl_pin,
-+				      pin->mux_func);
-+	}
-+}
-+
-+static const struct pinmux_ops up_pinmux_ops = {
-+	.get_functions_count = up_get_functions_count,
-+	.get_function_name = up_get_function_name,
-+	.get_function_groups = up_get_function_groups,
-+	.set_mux = up_pinmux_set_mux,
-+	.gpio_request_enable = up_gpio_request_enable,
-+	.gpio_disable_free = up_gpio_disable_free,
-+	.gpio_set_direction = up_gpio_set_direction,
-+};
-+
-+static int up_config_get(struct pinctrl_dev *pctldev, unsigned pin,
-+			 unsigned long *config)
-+{
-+	return -ENOTSUPP;
-+}
-+
-+static int up_config_set(struct pinctrl_dev *pctldev, unsigned pin,
-+			 unsigned long *configs, unsigned nconfigs)
-+{
-+	return 0;
-+}
-+
-+static const struct pinconf_ops up_pinconf_ops = {
-+	.is_generic = true,
-+	.pin_config_set = up_config_set,
-+	.pin_config_get = up_config_get,
-+};
-+
-+static struct pinctrl_desc up_pinctrl_desc = {
-+	.pins = up_pins_pi,
-+	.npins = ARRAY_SIZE(up_pins_pi),
-+	.pctlops = &up_pinctrl_ops,
-+	.pmxops = &up_pinmux_ops,
-+	.confops = &up_pinconf_ops,
-+	.owner = THIS_MODULE,
-+};
-+
-+static void up_led_brightness_set(struct led_classdev *cdev,
-+				  enum led_brightness value)
-+{
-+	struct up_cpld_led_info *led = container_of(cdev,
-+						    struct up_cpld_led_info,
-+						    cdev);
-+
-+	cpld_set_value(led->cpld, led->offset, value != LED_OFF);
-+}
-+
-+static const struct dmi_system_id up_board_id_table[] = {
-+	{
-+		.matches = {
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-CHT01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.4"),
-+		},
-+		.driver_data = (void *)&up_board
-+	},
-+	{}
-+};
-+
-+static int up_pinctrl_probe(struct platform_device *pdev)
-+{
-+	struct up_pctrl *up_pctrl;
-+	struct up_board_info *board;
-+	const struct dmi_system_id *system_id;
-+	unsigned offset;
-+	int ret;
-+
-+	system_id = dmi_first_match(up_board_id_table);
-+	if (!system_id)
-+		return -ENXIO;
-+
-+	board = system_id->driver_data;
-+
-+	ret = up_gpio_pincfg_init(pdev, board);
-+	if (ret)
-+		return ret;
-+
-+	up_pctrl = devm_kzalloc(&pdev->dev, sizeof(*up_pctrl), GFP_KERNEL);
-+	if (!up_pctrl)
-+		return -ENOMEM;
-+
-+	platform_set_drvdata(pdev, up_pctrl);
-+
-+	up_pctrl->pctldesc = up_pinctrl_desc;
-+	up_pctrl->pctldesc.name = dev_name(&pdev->dev);
-+	up_pctrl->pctldev = pinctrl_register(&up_pctrl->pctldesc,
-+					     &pdev->dev, up_pctrl);
-+	if (IS_ERR(up_pctrl->pctldev)) {
-+		dev_err(&pdev->dev, "failed to register pinctrl driver\n");
-+		return PTR_ERR(up_pctrl->pctldev);
-+	}
-+
-+	up_pctrl->board = board;
-+	up_pctrl->chip = up_gpio_chip;
-+	up_pctrl->chip.label = dev_name(&pdev->dev);
-+	up_pctrl->chip.parent = &pdev->dev;
-+
-+	ret = gpiochip_add(&up_pctrl->chip);
-+	if (ret) {
-+		dev_err(&pdev->dev, "failed to add %s chip\n",
-+			up_pctrl->chip.label);
-+		return ret;
-+	}
-+
-+	ret = gpiochip_add_pin_range(&up_pctrl->chip, dev_name(&pdev->dev),
-+				     0, 0, N_GPIO);
-+	if (ret) {
-+		dev_err(&pdev->dev, "failed to add GPIO pin range\n");
-+		goto fail_add_pin_range;
-+	}
-+
-+	ret = gpiochip_irqchip_add(&up_pctrl->chip, &up_gpio_irqchip, 0,
-+				   handle_simple_irq, IRQ_TYPE_NONE);
-+	if (ret) {
-+		dev_err(&pdev->dev, "failed to add IRQ chip\n");
-+		goto fail_irqchip_add;
-+	}
-+
-+	for (offset = 0; offset < up_pctrl->chip.ngpio; offset++) {
-+		struct up_pin_info *pin = &board->pins[offset];
-+		struct irq_data *irq_data;
-+
-+		pin->irq = irq_find_mapping(up_pctrl->chip.irqdomain, offset);
-+		pin->soc_gpio.irq = gpiod_to_irq(pin->soc_gpio.desc);
-+		irq_set_parent(pin->irq, pin->soc_gpio.irq);
-+		irq_data = irq_get_irq_data(pin->irq);
-+		irq_data->parent_data = irq_get_irq_data(pin->soc_gpio.irq);
-+	}
-+
-+	/* Make sure the board has a CPLD */
-+	if (board->cpld) {
-+		struct up_cpld_info *cpld = board->cpld;
-+		size_t i;
-+
-+		for (i = 0; i < cpld->num_leds; i++) {
-+			struct up_cpld_led_info *led = &cpld->leds[i];
-+
-+			led->cpld = cpld;
-+			led->cdev.brightness_set = up_led_brightness_set;
-+			led->cdev.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,
-+							"upboard:%s:",
-+							led->name);
-+			if (!led->cdev.name) {
-+				ret = -ENOMEM;
-+				goto fail_cpld_led;
-+			}
-+
-+			ret = devm_led_classdev_register(&pdev->dev,
-+							 &led->cdev);
-+			if (ret)
-+				goto fail_cpld_led;
-+		}
-+	}
-+
-+	return 0;
-+
-+fail_cpld_led:
-+fail_irqchip_add:
-+fail_add_pin_range:
-+	gpiochip_remove(&up_pctrl->chip);
-+
-+	return ret;
-+}
-+
-+static int up_pinctrl_remove(struct platform_device *pdev)
-+{
-+	struct up_pctrl *up_pctrl = platform_get_drvdata(pdev);
-+
-+	gpiochip_remove(&up_pctrl->chip);
-+	pinctrl_unregister(up_pctrl->pctldev);
-+
-+	/* Disable the CPLD outputs */
-+	if (up_pctrl->board->cpld)
-+		gpiod_set_value(up_pctrl->board->cpld->oe_gpio.desc, 0);
-+
-+	return 0;
-+}
-+
-+static struct platform_driver up_pinctrl_driver = {
-+	.driver.name	= "up-pinctrl",
-+	.driver.owner	= THIS_MODULE,
-+	.probe		= up_pinctrl_probe,
-+	.remove		= up_pinctrl_remove,
-+};
-+
-+static int __init up_pinctrl_init(void)
-+{
-+	return platform_driver_register(&up_pinctrl_driver);
-+}
-+subsys_initcall(up_pinctrl_init);
-+
-+static void __exit up_pinctrl_exit(void)
-+{
-+	platform_driver_unregister(&up_pinctrl_driver);
-+}
-+module_exit(up_pinctrl_exit);
-+
-+MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
-+MODULE_DESCRIPTION("Pin Control driver for UP Board I/O pin header");
-+MODULE_LICENSE("GPL v2");
-+MODULE_ALIAS("platform:up-pinctrl");
-\ No newline at end of file
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0008-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch b/recipes-kernel/linux/files/0008-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch
deleted file mode 100644
index 105e375..0000000
--- a/recipes-kernel/linux/files/0008-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From 9bdaf721fd148b50439d9e1c4dbf5e5c45313944 Mon Sep 17 00:00:00 2001
-From: Carlos Calderon <carlos@emutex.com>
-Date: Mon, 8 Oct 2018 16:06:21 +0100
-Subject: [PATCH 12/19] acpi: acpi_node_add_pin_mapping added to header file.
-
----
- include/linux/acpi.h | 13 +++++++++++++
- 1 file changed, 13 insertions(+)
-
-diff --git a/include/linux/acpi.h b/include/linux/acpi.h
-index acd2b5f..20f7440 100644
---- a/include/linux/acpi.h
-+++ b/include/linux/acpi.h
-@@ -997,6 +997,11 @@ void devm_acpi_dev_remove_driver_gpios(struct device *dev);
- bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,
- 				struct acpi_resource_gpio **agpio);
- int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index);
-+int acpi_node_add_pin_mapping(struct fwnode_handle *fwnode,
-+			      const char *propname,
-+			      const char *pinctl_name,
-+			      unsigned int pin_offset,
-+			      unsigned int npins);
- #else
- static inline int acpi_dev_add_driver_gpios(struct acpi_device *adev,
- 			      const struct acpi_gpio_mapping *gpios)
-@@ -1021,6 +1026,14 @@ static inline int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
- {
- 	return -ENXIO;
- }
-+static inline int acpi_node_add_pin_mapping(struct fwnode_handle *fwnode,
-+					    const char *propname,
-+					    const char *pinctl_name,
-+					    unsigned int pin_offset,
-+					    unsigned int npins)
-+{
-+	return -ENXIO;
-+}
- #endif
- 
- /* Device properties */
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0008-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch b/recipes-kernel/linux/files/0008-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch
new file mode 100755
index 0000000..7551689
--- /dev/null
+++ b/recipes-kernel/linux/files/0008-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch
@@ -0,0 +1,49 @@
+From d0b09294778b647e881d2bd56563b37e146e683e Mon Sep 17 00:00:00 2001
+From: Dan O'Donovan <dan@emutex.com>
+Date: Thu, 9 May 2019 12:59:40 +0100
+Subject: [PATCH 08/30] platform/x86: upboard: fix gpio/pinctrl API references
+
+Changes in the signatures of some gpio and pinctrl subsystem API
+functions and data-structures, added in v4.15, need to be reflected
+in this UP-board legacy pinctrl driver (which was ported from a v4.14
+kernel)
+
+Signed-off-by: Dan O'Donovan <dan@emutex.com>
+---
+ drivers/platform/x86/up_board_pinctrl.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
+index e6c9de4bcfbc..bcc23ea472aa 100644
+--- a/drivers/platform/x86/up_board_pinctrl.c
++++ b/drivers/platform/x86/up_board_pinctrl.c
+@@ -622,7 +622,7 @@ static int up_gpio_request(struct gpio_chip *gc, unsigned offset)
+ 	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
+ 	struct gpio_desc *desc = pin->soc_gpio.desc;
+ 
+-	pinctrl_request_gpio(gc->base + offset);
++	pinctrl_gpio_request(gc->base + offset);
+ 	return gpio_request(desc_to_gpio(desc), gc->label);
+ }
+ 
+@@ -632,7 +632,7 @@ static void up_gpio_free(struct gpio_chip *gc, unsigned offset)
+ 	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
+ 	struct gpio_desc *desc = pin->soc_gpio.desc;
+ 
+-	pinctrl_free_gpio(gc->base + offset);
++	pinctrl_gpio_free(gc->base + offset);
+ 	gpio_free(desc_to_gpio(desc));
+ }
+ 
+@@ -908,7 +908,7 @@ static int up_pinctrl_probe(struct platform_device *pdev)
+ 		struct up_pin_info *pin = &board->pins[offset];
+ 		struct irq_data *irq_data;
+ 
+-		pin->irq = irq_find_mapping(up_pctrl->chip.irqdomain, offset);
++		pin->irq = irq_find_mapping(up_pctrl->chip.irq.domain, offset);
+ 		pin->soc_gpio.irq = gpiod_to_irq(pin->soc_gpio.desc);
+ 		irq_set_parent(pin->irq, pin->soc_gpio.irq);
+ 		irq_data = irq_get_irq_data(pin->irq);
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0009-upboard-added-support-for-UP-core-CREX-HAT.patch b/recipes-kernel/linux/files/0009-upboard-added-support-for-UP-core-CREX-HAT.patch
old mode 100644
new mode 100755
index 35eb704..5e98402
--- a/recipes-kernel/linux/files/0009-upboard-added-support-for-UP-core-CREX-HAT.patch
+++ b/recipes-kernel/linux/files/0009-upboard-added-support-for-UP-core-CREX-HAT.patch
@@ -1,18 +1,18 @@
-From 9053e8902aa382c02753747f73d3e055729b1ed4 Mon Sep 17 00:00:00 2001
+From d4faeef2f24c64939ba16c2856e8d6473d692bd7 Mon Sep 17 00:00:00 2001
 From: Nicola Lunghi <nicola.lunghi@emutex.com>
 Date: Thu, 24 Aug 2017 11:15:24 +0100
-Subject: [PATCH 13/19] upboard: added support for UP core + CREX HAT
+Subject: [PATCH 09/30] upboard: added support for UP core + CREX HAT
 
 Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
 [Javier: minor style consistency tweaks]
 Signed-off-by: Javier Arteaga <javier@emutex.com>
 ---
  drivers/mfd/upboard-fpga.c        |   5 +-
- drivers/pinctrl/pinctrl-upboard.c | 117 ++++++++++++++++++++++++++++++++++++++
+ drivers/pinctrl/pinctrl-upboard.c | 117 ++++++++++++++++++++++++++++++
  2 files changed, 120 insertions(+), 2 deletions(-)
 
 diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
-index 9f444f8..3ce27e2 100644
+index 9f444f876af1..3ce27e23f9a2 100644
 --- a/drivers/mfd/upboard-fpga.c
 +++ b/drivers/mfd/upboard-fpga.c
 @@ -290,8 +290,9 @@ static int __init upboard_fpga_detect_firmware(struct upboard_fpga *fpga)
@@ -28,7 +28,7 @@ index 9f444f8..3ce27e2 100644
  };
  MODULE_DEVICE_TABLE(acpi, upboard_fpga_acpi_match);
 diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index 64899e9..65ac489 100644
+index 64899e988bb5..65ac489d41a6 100644
 --- a/drivers/pinctrl/pinctrl-upboard.c
 +++ b/drivers/pinctrl/pinctrl-upboard.c
 @@ -5,6 +5,7 @@
@@ -185,5 +185,5 @@ index 64899e9..65ac489 100644
  MODULE_ALIAS("platform:upboard-pinctrl");
 \ No newline at end of file
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0010-upboard-Add-support-for-UP-CRST02.patch b/recipes-kernel/linux/files/0010-upboard-Add-support-for-UP-CRST02.patch
old mode 100644
new mode 100755
index bf0573d..47d59a5
--- a/recipes-kernel/linux/files/0010-upboard-Add-support-for-UP-CRST02.patch
+++ b/recipes-kernel/linux/files/0010-upboard-Add-support-for-UP-CRST02.patch
@@ -1,7 +1,7 @@
-From fca09160bc84c101d921fab8b45e6b2f0a4bb14d Mon Sep 17 00:00:00 2001
+From cfdec01d13572f63f4e0455a99059cd0e074a492 Mon Sep 17 00:00:00 2001
 From: Carlos Calderon <carlos@emuex.com>
 Date: Thu, 13 Sep 2018 16:23:45 +0100
-Subject: [PATCH 14/19] upboard: Add support for UP-CRST02
+Subject: [PATCH 10/30] upboard: Add support for UP-CRST02
 
 UP-CRST02 uses
 * ACPI ID AANT0F03
@@ -15,7 +15,7 @@ Add support to MFD and pinctrl.
  2 files changed, 38 insertions(+), 4 deletions(-)
 
 diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
-index 3ce27e2..0e81929 100644
+index 3ce27e23f9a2..0e8192902c35 100644
 --- a/drivers/mfd/upboard-fpga.c
 +++ b/drivers/mfd/upboard-fpga.c
 @@ -149,6 +149,20 @@ static const struct upboard_fpga_data upboard_up2_fpga_data = {
@@ -56,7 +56,7 @@ index 3ce27e2..0e81929 100644
  MODULE_DEVICE_TABLE(acpi, upboard_fpga_acpi_match);
  
 diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index 65ac489..ed1d9bd 100644
+index 65ac489d41a6..ed1d9bdb529c 100644
 --- a/drivers/pinctrl/pinctrl-upboard.c
 +++ b/drivers/pinctrl/pinctrl-upboard.c
 @@ -535,6 +535,13 @@ static unsigned int upboard_upcore_crex_rpi_mapping[] = {
@@ -100,5 +100,5 @@ index 65ac489..ed1d9bd 100644
  		return -ENODEV;
  
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch b/recipes-kernel/linux/files/0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch
old mode 100644
new mode 100755
index 7680085..d72c692
--- a/recipes-kernel/linux/files/0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch
+++ b/recipes-kernel/linux/files/0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch
@@ -1,7 +1,7 @@
-From fea05825c9d5d6c717c69c1e26b95f643a5a31cd Mon Sep 17 00:00:00 2001
+From 1467072523e24fde7d37227ffa575d36f7463484 Mon Sep 17 00:00:00 2001
 From: Dan O'Donovan <dan@emutex.com>
 Date: Thu, 22 Nov 2018 18:13:19 +0000
-Subject: [PATCH 16/19] pinctrl-upboard: add regmap patches for CREX and CRST02
+Subject: [PATCH 11/30] pinctrl-upboard: add regmap patches for CREX and CRST02
  UP Core carrier boards
 
 The initial pinctrl configuration on the CPLD on CREX and CRST02 boards isn't
@@ -14,17 +14,18 @@ update the configuration if they are later exported as GPIO pins.
 
 Signed-off-by: Dan O'Donovan <dan@emutex.com>
 ---
- drivers/pinctrl/pinctrl-upboard.c | 54 ++++++++++++++++++++++++++++++++++++---
+ drivers/pinctrl/pinctrl-upboard.c | 54 ++++++++++++++++++++++++++++---
  1 file changed, 50 insertions(+), 4 deletions(-)
 
 diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index ed1d9bd..5dae769 100644
+index ed1d9bdb529c..5dae76942f6e 100644
 --- a/drivers/pinctrl/pinctrl-upboard.c
 +++ b/drivers/pinctrl/pinctrl-upboard.c
-@@ -536,11 +536,53 @@ static unsigned int upboard_upcore_crex_rpi_mapping[] = {
+@@ -535,12 +535,54 @@ static unsigned int upboard_upcore_crex_rpi_mapping[] = {
+ 	UPBOARD_UPCORE_CREX_BIT_TO_PIN(1, I2S2_TX),
  };
  
- /*
++/*
 + * Init patches applied to the registers until the BIOS sets proper defaults
 + */
 +static const struct reg_sequence upboard_upcore_crex_reg_patches[] __initconst = {
@@ -65,7 +66,7 @@ index ed1d9bd..5dae769 100644
 +	.npatches = ARRAY_SIZE(upboard_upcore_crex_reg_patches),
 +};
 +
-+/*
+ /*
   * UP Core board + CRST02 carrier board data
   */
  
@@ -105,5 +106,5 @@ index ed1d9bd..5dae769 100644
  	if (bios_info && bios_info->patches) {
  		ret = regmap_register_patch(pctrl->regmap,
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch b/recipes-kernel/linux/files/0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch
old mode 100644
new mode 100755
index 3577664..2edf22e
--- a/recipes-kernel/linux/files/0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch
+++ b/recipes-kernel/linux/files/0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch
@@ -1,7 +1,7 @@
-From 5c517a894c437bc796922c1dfedab184a5739d27 Mon Sep 17 00:00:00 2001
+From 892a0d5a0fb135c2945927ec611910fffd6d336d Mon Sep 17 00:00:00 2001
 From: Dan O'Donovan <dan@emutex.com>
 Date: Tue, 11 Dec 2018 15:44:52 +0000
-Subject: [PATCH 17/19] pinctrl-upboard: add separate regmap patches for CREX
+Subject: [PATCH 12/30] pinctrl-upboard: add separate regmap patches for CREX
  and CRST02
 
 CREX actually has only a subset of the CRST02 registers (no
@@ -10,11 +10,11 @@ regmap patch.
 
 Signed-off-by: Dan O'Donovan <dan@emutex.com>
 ---
- drivers/pinctrl/pinctrl-upboard.c | 45 +++++++++++++++++++++++++++++----------
+ drivers/pinctrl/pinctrl-upboard.c | 45 +++++++++++++++++++++++--------
  1 file changed, 34 insertions(+), 11 deletions(-)
 
 diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index 5dae769..dea2cf0 100644
+index 5dae76942f6e..dea2cf0c9b04 100644
 --- a/drivers/pinctrl/pinctrl-upboard.c
 +++ b/drivers/pinctrl/pinctrl-upboard.c
 @@ -552,6 +552,37 @@ static const struct reg_sequence upboard_upcore_crex_reg_patches[] __initconst =
@@ -79,5 +79,5 @@ index 5dae769..dea2cf0 100644
  			   unsigned int group)
  {
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch b/recipes-kernel/linux/files/0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch
old mode 100644
new mode 100755
index 756fd17..49f6487
--- a/recipes-kernel/linux/files/0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch
+++ b/recipes-kernel/linux/files/0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch
@@ -1,7 +1,7 @@
-From 0b6a04bcaf0819225b3ace4e0a7645afbc896fbf Mon Sep 17 00:00:00 2001
+From 33f9ab43a2ee2d00bd585c5c86fa0c08b90a9787 Mon Sep 17 00:00:00 2001
 From: Dan O'Donovan <dan@emutex.com>
 Date: Tue, 11 Dec 2018 15:50:13 +0000
-Subject: [PATCH 18/19] correct the number of GPIOs for CREX and CRST02 boards
+Subject: [PATCH 13/30] correct the number of GPIOs for CREX and CRST02 boards
 
 The CREX and CRST02 boards actually have only 22 GPIO pins, unlike
 UP and UP^2 boards which have 28.  So the number of GPIOs to declare
@@ -14,7 +14,7 @@ Signed-off-by: Dan O'Donovan <dan@emutex.com>
  1 file changed, 6 insertions(+), 1 deletion(-)
 
 diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index dea2cf0..e4af343 100644
+index dea2cf0c9b04..e4af3431c699 100644
 --- a/drivers/pinctrl/pinctrl-upboard.c
 +++ b/drivers/pinctrl/pinctrl-upboard.c
 @@ -813,7 +813,6 @@ static int upboard_gpio_direction_output(struct gpio_chip *gc,
@@ -63,5 +63,5 @@ index dea2cf0..e4af343 100644
  	ret = devm_gpiochip_add_data(&pdev->dev, &pctrl->chip, &pctrl->chip);
  	if (ret)
 -- 
-2.7.4
+2.17.1
 
diff --git a/recipes-kernel/linux/files/0014-i2c-i2c-designware-platdrv-Cleanup-setting-of-the-ad.patch b/recipes-kernel/linux/files/0014-i2c-i2c-designware-platdrv-Cleanup-setting-of-the-ad.patch
deleted file mode 100644
index 6286235..0000000
--- a/recipes-kernel/linux/files/0014-i2c-i2c-designware-platdrv-Cleanup-setting-of-the-ad.patch
+++ /dev/null
@@ -1,78 +0,0 @@
-From 3d5d2b86002295c4859c84f4971f0d1cd70b459f Mon Sep 17 00:00:00 2001
-From: Hans de Goede <hdegoede@redhat.com>
-Date: Tue, 12 Mar 2019 15:55:53 +0100
-Subject: [PATCH 15/19] i2c: i2c-designware-platdrv: Cleanup setting of the
- adapter number
-
-i2c-designware-platdrv assumes that if the pdev has an apci-companion
-it should use a dynamic adapter-nr and otherwise it will use pdev->id
-as adapter-nr.
-
-Before this commit the setting of the adapter.nr was somewhat convoluted,
-in the acpi_companion case it was set from dw_i2c_acpi_configure, in the
-non acpi_companion case it was set from dw_i2c_set_fifo_size based on
-tx_fifo_depth not being set yet indicating that dw_i2c_acpi_configure was
-not executed.
-
-This cleans this up, directly setting the adapter-nr from
-dw_i2c_plat_probe for both cases.
-
-Signed-off-by: Hans de Goede <hdegoede@redhat.com>
-Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
-Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
-Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
----
- drivers/i2c/busses/i2c-designware-platdrv.c | 10 ++++++----
- 1 file changed, 6 insertions(+), 4 deletions(-)
-
-diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
-index b5750fd..593dc72 100644
---- a/drivers/i2c/busses/i2c-designware-platdrv.c
-+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
-@@ -90,7 +90,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
- 	struct acpi_device *adev;
- 	const char *uid;
- 
--	dev->adapter.nr = -1;
- 	dev->tx_fifo_depth = 32;
- 	dev->rx_fifo_depth = 32;
- 
-@@ -194,7 +193,7 @@ static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
- 	dev->mode = DW_IC_SLAVE;
- }
- 
--static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
-+static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev)
- {
- 	u32 param, tx_fifo_depth, rx_fifo_depth;
- 
-@@ -208,7 +207,6 @@ static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
- 	if (!dev->tx_fifo_depth) {
- 		dev->tx_fifo_depth = tx_fifo_depth;
- 		dev->rx_fifo_depth = rx_fifo_depth;
--		dev->adapter.nr = id;
- 	} else if (tx_fifo_depth >= 2) {
- 		dev->tx_fifo_depth = min_t(u32, dev->tx_fifo_depth,
- 				tx_fifo_depth);
-@@ -328,13 +326,17 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
- 				div_u64(clk_khz * t->sda_hold_ns + 500000, 1000000);
- 	}
- 
--	dw_i2c_set_fifo_size(dev, pdev->id);
-+	dw_i2c_set_fifo_size(dev);
- 
- 	adap = &dev->adapter;
- 	adap->owner = THIS_MODULE;
- 	adap->class = I2C_CLASS_DEPRECATED;
- 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
- 	adap->dev.of_node = pdev->dev.of_node;
-+	if (has_acpi_companion(&pdev->dev))
-+		adap->nr = -1;
-+	else
-+		adap->nr = pdev->id;
- 
- 	dev_pm_set_driver_flags(&pdev->dev,
- 				DPM_FLAG_SMART_PREPARE |
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0014-upboard-fpga-Enable-fpga-on-UP3-platform.patch b/recipes-kernel/linux/files/0014-upboard-fpga-Enable-fpga-on-UP3-platform.patch
new file mode 100755
index 0000000..dfce0db
--- /dev/null
+++ b/recipes-kernel/linux/files/0014-upboard-fpga-Enable-fpga-on-UP3-platform.patch
@@ -0,0 +1,81 @@
+From fb02bdd95d0cc3332c56354b5a7969a09503c109 Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Wed, 10 Apr 2019 11:40:09 +0100
+Subject: [PATCH 14/30] upboard-fpga: Enable fpga on UP3 platform
+
+Add acpi match for UP3 FPGA.
+---
+ drivers/mfd/upboard-fpga.c        | 10 +++++++++-
+ drivers/pinctrl/pinctrl-upboard.c | 11 +++++++++--
+ 2 files changed, 18 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
+index 0e8192902c35..b55e1b642cf5 100644
+--- a/drivers/mfd/upboard-fpga.c
++++ b/drivers/mfd/upboard-fpga.c
+@@ -308,6 +308,7 @@ static const struct acpi_device_id upboard_fpga_acpi_match[] = {
+ 	{ "AANT0F01", (kernel_ulong_t)&upboard_up2_fpga_data },
+ 	{ "AANT0F02", (kernel_ulong_t)&upboard_upcore_crex_fpga_data },
+ 	{ "AANT0F03", (kernel_ulong_t)&upboard_upcore_crst02_fpga_data },
++	{ "AANT0F04", (kernel_ulong_t)&upboard_up_fpga_data },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(acpi, upboard_fpga_acpi_match);
+@@ -341,6 +342,13 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 		},
+ 		.driver_data = (void *)UPFPGA_QUIRK_HRV1_IS_PROTO2,
+ 	},
++	{
++		.matches = { /* UP Xtreme */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BIOS_DATE, "03/18/2019"),
++		},
++		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
++	},
+ 	{ },
+ };
+ 
+@@ -424,4 +432,4 @@ module_platform_driver_probe(upboard_fpga_driver, upboard_fpga_probe);
+ 
+ MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
+ MODULE_DESCRIPTION("UP Board FPGA driver");
+-MODULE_LICENSE("GPL v2");
+\ No newline at end of file
++MODULE_LICENSE("GPL v2");
+diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
+index e4af3431c699..397c8acd81f6 100644
+--- a/drivers/pinctrl/pinctrl-upboard.c
++++ b/drivers/pinctrl/pinctrl-upboard.c
+@@ -840,6 +840,13 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 		},
+ 		.driver_data = (void *)&upboard_up2_bios_info_v0_3,
+ 	},
++	{
++		.matches = { /* UP Xtreme */
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BIOS_DATE, "03/18/2019"),
++		},
++		.driver_data = (void *)&upboard_up_bios_info_dvt,
++	},
+ 	{ },
+ };
+ 
+@@ -865,7 +872,7 @@ static int __init upboard_pinctrl_probe(struct platform_device *pdev)
+ 		return -ENODEV;
+ 
+ 	hid = acpi_device_hid(adev);
+-	if (!strcmp(hid, "AANT0F00")) {
++	if (!strcmp(hid, "AANT0F00") || !strcmp(hid, "AANT0F04")) {
+ 		pctldesc = &upboard_up_pinctrl_desc;
+ 		rpi_mapping = upboard_up_rpi_mapping;
+ 		ngpio  = ARRAY_SIZE(upboard_up_rpi_mapping);
+@@ -1004,4 +1011,4 @@ MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
+ MODULE_AUTHOR("Nicola Lunghi <nicolal@emutex.com>");
+ MODULE_DESCRIPTION("UP Board HAT pin controller driver");
+ MODULE_LICENSE("GPL v2");
+-MODULE_ALIAS("platform:upboard-pinctrl");
+\ No newline at end of file
++MODULE_ALIAS("platform:upboard-pinctrl");
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0015-i2c-i2c-designware-platdrv-Always-use-a-dynamic-adap.patch b/recipes-kernel/linux/files/0015-i2c-i2c-designware-platdrv-Always-use-a-dynamic-adap.patch
deleted file mode 100644
index 311c3d0..0000000
--- a/recipes-kernel/linux/files/0015-i2c-i2c-designware-platdrv-Always-use-a-dynamic-adap.patch
+++ /dev/null
@@ -1,80 +0,0 @@
-From 213ecfe8529b109267116c4bda5c718e3b5238e0 Mon Sep 17 00:00:00 2001
-From: Hans de Goede <hdegoede@redhat.com>
-Date: Tue, 12 Mar 2019 15:55:54 +0100
-Subject: [PATCH 16/19] i2c: i2c-designware-platdrv: Always use a dynamic
- adapter number
-
-Before this commit the i2c-designware-platdrv assumes that if the pdev
-has an apci-companion it should use a dynamic adapter-nr and it sets
-adapter->nr to -1, otherwise it will use pdev->id as adapter->nr.
-
-There are 3 ways how platform_device-s to which i2c-designware-platdrv
-will bind can be instantiated:
-
-1) Through of / devicetree
-2) Through ACPI enumeration
-3) Explicitly instantiated through platform_device_create + add
-
-1) In case of devicetree-instantiation the drivers/of code always sets
-pdev->id to PLATFORM_DEVID_NONE, which is -1 so in this case both paths
-to set adapter->nr end up doing the same thing.
-
-2) In case of ACPI instantiation the device will always have an
-ACPI-companion, so we are already using dynamic adapter-nrs.
-
-3) There are 2 places manually instantiating a designware_i2c platform_dev:
-drivers/mfd/intel_quark_i2c_gpio.c
-drivers/mfd/intel-lpss.c
-
-In the intel_quark_i2c_gpio.c case pdev->id is always 0, so switching to
-dynamic adapter-nrs here could lead to the bus-number no longer being
-stable, but the quark X1000 only has 1 i2c-controller, which will also
-be assigned bus-number 0 when using dynamic adapter-nrs.
-
-In the intel-lpss.c case intel_lpss_probe() is called from either
-intel-lpss-acpi.c in which case there always is an ACPI-companion, or
-from intel-lpss-pci.c. In most cases devices handled by intel-lpss-pci.c
-also have an ACPI-companion, so we use a dynamic adapter-nr. But in some
-cases the ACPI-companion is missing and we would use pdev->id (allocated
-from intel_lpss_devid_ida). Devices which use the intel-lpss-pci.c code
-typically have many i2c busses, so using pdev->id in this case may lead
-to a bus-number conflict, triggering a WARN(id < 0, "couldn't get idr")
-in i2c-core-base.c causing an oops an the adapter registration to fail.
-So in this case using non dynamic adapter-nrs is actually undesirable.
-
-One machine on which this oops was triggering is the Apollo Lake based
-Acer TravelMate Spin B118.
-
-TL;DR: Switching to always using dynamic adapter-numbers does not make
-any difference in most cases and in the one case where it does make a
-difference the behavior change is desirable because the old behavior
-caused an oops.
-
-BugLink: https://bugzilla.redhat.com/show_bug.cgi?id=1687065
-Signed-off-by: Hans de Goede <hdegoede@redhat.com>
-Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
-Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
-Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
----
- drivers/i2c/busses/i2c-designware-platdrv.c | 5 +----
- 1 file changed, 1 insertion(+), 4 deletions(-)
-
-diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
-index 593dc72..b38f338 100644
---- a/drivers/i2c/busses/i2c-designware-platdrv.c
-+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
-@@ -333,10 +333,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
- 	adap->class = I2C_CLASS_DEPRECATED;
- 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
- 	adap->dev.of_node = pdev->dev.of_node;
--	if (has_acpi_companion(&pdev->dev))
--		adap->nr = -1;
--	else
--		adap->nr = pdev->id;
-+	adap->nr = -1;
- 
- 	dev_pm_set_driver_flags(&pdev->dev,
- 				DPM_FLAG_SMART_PREPARE |
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0015-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch b/recipes-kernel/linux/files/0015-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch
new file mode 100755
index 0000000..cef4bfa
--- /dev/null
+++ b/recipes-kernel/linux/files/0015-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch
@@ -0,0 +1,27 @@
+From 37bcd20e65c9767a9b72cbd09b2bf0ad45513c41 Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Wed, 10 Apr 2019 11:44:06 +0100
+Subject: [PATCH 15/30] pinctrl-upboard: Dont initialise UART1 RTS as input
+
+In the case where the BIOS does initialise pin directions,
+pinctrl-upboard was setting the RTS line as in input. GPIO17
+is removed from the initialize as input list.
+---
+ drivers/pinctrl/pinctrl-upboard.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
+index 397c8acd81f6..65e46fdb5632 100644
+--- a/drivers/pinctrl/pinctrl-upboard.c
++++ b/drivers/pinctrl/pinctrl-upboard.c
+@@ -203,7 +203,6 @@ static const struct reg_sequence upboard_up_reg_patches[] __initconst = {
+ 		BIT(UPFPGA_UP_I2C1_SDA)	    |
+ 		BIT(UPFPGA_UP_I2C1_SCL)	    |
+ 		BIT(UPFPGA_UP_ADC0)	    |
+-		BIT(UPFPGA_UP_GPIO17)	    |
+ 		BIT(UPFPGA_UP_GPIO27)	    |
+ 		BIT(UPFPGA_UP_GPIO22)	    |
+ 		BIT(UPFPGA_UP_SPI_MISO)	    |
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0016-pinctrl-core-translate-gpio-to-pin-before-set-config.patch b/recipes-kernel/linux/files/0016-pinctrl-core-translate-gpio-to-pin-before-set-config.patch
new file mode 100755
index 0000000..74a5f1b
--- /dev/null
+++ b/recipes-kernel/linux/files/0016-pinctrl-core-translate-gpio-to-pin-before-set-config.patch
@@ -0,0 +1,54 @@
+From 3374d9f7dcbb59d8300707051a79325b3b08dd20 Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Tue, 16 Apr 2019 15:20:46 +0100
+Subject: [PATCH 16/30] pinctrl-core: translate gpio to pin before set config
+
+Ticket #: 2568
+
+pinconf_set_config needs the pin gpio translated to pin number
+before configuring the pin. The translation was not done in
+pinctrl_gpio_set_config. This is fixed here.
+---
+ drivers/pinctrl/core.c | 14 ++++++++++++--
+ 1 file changed, 12 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
+index 96250717637a..245e628046fe 100755
+--- a/drivers/pinctrl/core.c
++++ b/drivers/pinctrl/core.c
+@@ -984,8 +984,10 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
+ int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
+ {
+ 	unsigned long configs[] = { config };
++	struct pinctrl_gpio_range *range = NULL;
+ 	struct pinctrl_dev *pctldev;
+ 	struct gpio_desc *desc;
++	int pin;
+ 	int dir;
+ 	int ret = -EPROBE_DEFER;
+ 
+@@ -1012,11 +1014,19 @@ int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
+ 	 */
+ 	if (dir == 1) {
+ 		list_for_each_entry(pctldev, &pinctrldev_list, node) {
+-			ret = pinconf_set_config(pctldev, gpio, configs, ARRAY_SIZE(configs));
++			range = pinctrl_match_gpio_range(pctldev, gpio);
++			if (range == NULL)
++				continue;
++			pin = gpio_to_pin(range, gpio);
++			ret = pinconf_set_config(pctldev, pin, configs, ARRAY_SIZE(configs));
+ 		}
+ 	} else {
+ 		list_for_each_entry_reverse(pctldev, &pinctrldev_list, node) {
+-			ret = pinconf_set_config(pctldev, gpio, configs, ARRAY_SIZE(configs));
++			range = pinctrl_match_gpio_range(pctldev, gpio);
++			if (range == NULL)
++				continue;
++			pin = gpio_to_pin(range, gpio);
++			ret = pinconf_set_config(pctldev, pin, configs, ARRAY_SIZE(configs));
+ 		}
+ 	}
+ 
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0016-upxtreme-Add-support-for-UP-Xtreme.patch b/recipes-kernel/linux/files/0016-upxtreme-Add-support-for-UP-Xtreme.patch
deleted file mode 100644
index b847e67..0000000
--- a/recipes-kernel/linux/files/0016-upxtreme-Add-support-for-UP-Xtreme.patch
+++ /dev/null
@@ -1,83 +0,0 @@
-From 832fd6cbf25f281953e29d06e2dffe1a7980a69d Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Tue, 9 Jul 2019 09:05:00 +0100
-Subject: [PATCH 1/1] upxtreme: Add support for UP Xtreme
-
-Add UP Xtreme dmi match patterns to UP board fpga and pinctrl
----
- drivers/mfd/upboard-fpga.c        | 11 ++++++++++-
- drivers/pinctrl/pinctrl-upboard.c | 12 ++++++++++--
- 2 files changed, 20 insertions(+), 3 deletions(-)
-
-diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
-index 0e81929..42e6f24 100644
---- a/drivers/mfd/upboard-fpga.c
-+++ b/drivers/mfd/upboard-fpga.c
-@@ -308,6 +308,7 @@ static const struct acpi_device_id upboard_fpga_acpi_match[] = {
- 	{ "AANT0F01", (kernel_ulong_t)&upboard_up2_fpga_data },
- 	{ "AANT0F02", (kernel_ulong_t)&upboard_upcore_crex_fpga_data },
- 	{ "AANT0F03", (kernel_ulong_t)&upboard_upcore_crst02_fpga_data },
-+	{ "AANT0F04", (kernel_ulong_t)&upboard_up_fpga_data },
- 	{ }
- };
- MODULE_DEVICE_TABLE(acpi, upboard_fpga_acpi_match);
-@@ -341,6 +342,14 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
- 		},
- 		.driver_data = (void *)UPFPGA_QUIRK_HRV1_IS_PROTO2,
- 	},
-+	{
-+		.matches = { /* UP Xtreme */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
-+		},
-+		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
-+	},
- 	{ },
- };
- 
-@@ -424,4 +433,4 @@ module_platform_driver_probe(upboard_fpga_driver, upboard_fpga_probe);
- 
- MODULE_AUTHOR("Javier Arteaga <javier@emutex.com>");
- MODULE_DESCRIPTION("UP Board FPGA driver");
--MODULE_LICENSE("GPL v2");
-\ No newline at end of file
-+MODULE_LICENSE("GPL v2");
-diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index e4af343..229496b 100644
---- a/drivers/pinctrl/pinctrl-upboard.c
-+++ b/drivers/pinctrl/pinctrl-upboard.c
-@@ -840,6 +840,14 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
- 		},
- 		.driver_data = (void *)&upboard_up2_bios_info_v0_3,
- 	},
-+	{
-+		.matches = { /* UP Xtreme */
-+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
-+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
-+			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
-+		},
-+		.driver_data = (void *)&upboard_up_bios_info_dvt,
-+	},
- 	{ },
- };
- 
-@@ -865,7 +873,7 @@ static int __init upboard_pinctrl_probe(struct platform_device *pdev)
- 		return -ENODEV;
- 
- 	hid = acpi_device_hid(adev);
--	if (!strcmp(hid, "AANT0F00")) {
-+	if (!strcmp(hid, "AANT0F00") || !strcmp(hid, "AANT0F04")) {
- 		pctldesc = &upboard_up_pinctrl_desc;
- 		rpi_mapping = upboard_up_rpi_mapping;
- 		ngpio  = ARRAY_SIZE(upboard_up_rpi_mapping);
-@@ -1004,4 +1012,4 @@ MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
- MODULE_AUTHOR("Nicola Lunghi <nicolal@emutex.com>");
- MODULE_DESCRIPTION("UP Board HAT pin controller driver");
- MODULE_LICENSE("GPL v2");
--MODULE_ALIAS("platform:upboard-pinctrl");
-\ No newline at end of file
-+MODULE_ALIAS("platform:upboard-pinctrl");
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0017-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch b/recipes-kernel/linux/files/0017-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch
deleted file mode 100644
index 5a7d6a7..0000000
--- a/recipes-kernel/linux/files/0017-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 83edd14b87d2a8453f48f8efc7d042d148f9a918 Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Wed, 10 Apr 2019 11:44:06 +0100
-Subject: [PATCH 18/19] pinctrl-upboard: Dont initialise UART1 RTS as input
-
-In the case where the BIOS does initialise pin directions,
-pinctrl-upboard was setting the RTS line as in input. GPIO17
-is removed from the initialize as input list.
----
- drivers/pinctrl/pinctrl-upboard.c | 1 -
- 1 file changed, 1 deletion(-)
-
-diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index 397c8ac..65e46fd 100644
---- a/drivers/pinctrl/pinctrl-upboard.c
-+++ b/drivers/pinctrl/pinctrl-upboard.c
-@@ -203,7 +203,6 @@ static const struct reg_sequence upboard_up_reg_patches[] __initconst = {
- 		BIT(UPFPGA_UP_I2C1_SDA)	    |
- 		BIT(UPFPGA_UP_I2C1_SCL)	    |
- 		BIT(UPFPGA_UP_ADC0)	    |
--		BIT(UPFPGA_UP_GPIO17)	    |
- 		BIT(UPFPGA_UP_GPIO27)	    |
- 		BIT(UPFPGA_UP_GPIO22)	    |
- 		BIT(UPFPGA_UP_SPI_MISO)	    |
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0017-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch b/recipes-kernel/linux/files/0017-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch
new file mode 100755
index 0000000..9fa89f5
--- /dev/null
+++ b/recipes-kernel/linux/files/0017-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch
@@ -0,0 +1,56 @@
+From a329734d286105235648c2dd7c9cf2982a804d1b Mon Sep 17 00:00:00 2001
+From: Carlos Calderon <carlos@emutex.com>
+Date: Wed, 3 Oct 2018 13:09:36 +0100
+Subject: [PATCH 17/30] serial: 8250_dw: add quirk to disable DMA on Cherry
+ Trail SoC
+
+Using DMA with the HS-UART on the Atom X5-8350 "Cherry Trail" SoC
+results in data loss/corruption on UART transfers and the following
+error message filling the kernel log:
+  "serial8250: too much work for irq39"
+
+As a temporary workaround, this commit disables use of DMA for the
+HS-UARTs on Cherry Trail (matching ACPI device ID "8086228A").
+---
+ drivers/tty/serial/8250/8250_dw.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
+index d63481399477..a6091a3bbe9f 100644
+--- a/drivers/tty/serial/8250/8250_dw.c
++++ b/drivers/tty/serial/8250/8250_dw.c
+@@ -47,6 +47,7 @@ struct dw8250_data {
+ 
+ 	unsigned int		skip_autocfg:1;
+ 	unsigned int		uart_16550_compatible:1;
++	unsigned int		skip_dma:1;
+ };
+ 
+ static inline struct dw8250_data *to_dw8250_data(struct dw8250_port_data *data)
+@@ -440,10 +441,13 @@ static void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)
+ 		p->regshift = 2;
+ 		p->serial_in = dw8250_serial_in32;
+ 		data->uart_16550_compatible = true;
++	} else if (acpi_dev_present("8086228A", NULL, -1)) {
++		data->skip_dma = true;
+ 	}
+ 
+ 	/* Platforms with iDMA 64-bit */
+-	if (platform_get_resource_byname(to_platform_device(p->dev),
++	if (!data->skip_dma &&
++            platform_get_resource_byname(to_platform_device(p->dev),
+ 					 IORESOURCE_MEM, "lpss_priv")) {
+ 		data->data.dma.rx_param = p->dev->parent;
+ 		data->data.dma.tx_param = p->dev->parent;
+@@ -589,7 +593,7 @@ static int dw8250_probe(struct platform_device *pdev)
+ 		dw8250_setup_port(p);
+ 
+ 	/* If we have a valid fifosize, try hooking up DMA */
+-	if (p->fifosize) {
++	if (!data->skip_dma && p->fifosize) {
+ 		data->data.dma.rxconf.src_maxburst = p->fifosize / 4;
+ 		data->data.dma.txconf.dst_maxburst = p->fifosize / 4;
+ 		up->dma = &data->data.dma;
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0018-pinctrl-core-translate-gpio-to-pin-before-config.patch b/recipes-kernel/linux/files/0018-pinctrl-core-translate-gpio-to-pin-before-config.patch
deleted file mode 100644
index 122fe9a..0000000
--- a/recipes-kernel/linux/files/0018-pinctrl-core-translate-gpio-to-pin-before-config.patch
+++ /dev/null
@@ -1,74 +0,0 @@
-From 60e200a67bdae20dcf5e5c64719730f7658fcde4 Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Thu, 2 May 2019 15:00:35 +0100
-Subject: [PATCH] pinctrl:core: translate gpio to pin before config
-
-Ticket #: 2568
-
-pinconf_set_config needs the pin gpio translated to pin number
-before configuring the pin. The translation was not done in
-pinctrl_gpio_set_config. This is fixed here.
----
- drivers/pinctrl/core.c | 29 ++++++++++++++++++++++++++---
- 1 file changed, 26 insertions(+), 3 deletions(-)
-
-diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
-index 07eb1e1..bfd7d1c 100644
---- a/drivers/pinctrl/core.c
-+++ b/drivers/pinctrl/core.c
-@@ -854,6 +854,26 @@ int pinctrl_gpio_direction_output(unsigned gpio)
- }
- EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
- 
-+static int pinctrl_set_config_if_match(struct pinctrl_dev *pctldev,
-+					unsigned int gpio, unsigned long config)
-+{
-+	struct pinctrl_gpio_range *range;
-+	int ret = 0;
-+
-+	range = pinctrl_match_gpio_range(pctldev, gpio);
-+
-+	if (range != NULL) {
-+		int pin;
-+
-+		mutex_lock(&pctldev->mutex);
-+		pin = gpio_to_pin(range, gpio);
-+		ret = pinconf_set_config(pctldev, pin, &config, 1);
-+		mutex_unlock(&pctldev->mutex);
-+	}
-+
-+	return ret;
-+}
-+
- /**
-  * pinctrl_gpio_set_config() - Apply config to given GPIO pin
-  * @gpio: the GPIO pin number from the GPIO subsystem number space
-@@ -865,7 +885,6 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
-  */
- int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
- {
--	unsigned long configs[] = { config };
- 	struct pinctrl_dev *pctldev;
- 	struct gpio_desc *desc;
- 	int dir;
-@@ -894,11 +913,15 @@ int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
- 	 */
- 	if (dir == 1) {
- 		list_for_each_entry(pctldev, &pinctrldev_list, node) {
--			ret = pinconf_set_config(pctldev, gpio, configs, ARRAY_SIZE(configs));
-+			ret = pinctrl_set_config_if_match(pctldev, gpio, config);
-+			if (ret)
-+				break;
- 		}
- 	} else {
- 		list_for_each_entry_reverse(pctldev, &pinctrldev_list, node) {
--			ret = pinconf_set_config(pctldev, gpio, configs, ARRAY_SIZE(configs));
-+			ret = pinctrl_set_config_if_match(pctldev, gpio, config);
-+			if (ret)
-+				break;
- 		}
- 	}
- 
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0018-up-fpga-dmi-Update-DMI-match-date-string.patch b/recipes-kernel/linux/files/0018-up-fpga-dmi-Update-DMI-match-date-string.patch
new file mode 100755
index 0000000..cc7cf0f
--- /dev/null
+++ b/recipes-kernel/linux/files/0018-up-fpga-dmi-Update-DMI-match-date-string.patch
@@ -0,0 +1,40 @@
+From 6ac7279135f6df7315c3e164d3672beb5f74e4df Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Thu, 2 May 2019 17:13:12 +0100
+Subject: [PATCH 18/30] up-fpga:dmi: Update DMI match date string
+
+This matches the DMI DATE DATA for UP3 BIOS name UPW1AM0B(04/11/2019)
+---
+ drivers/mfd/upboard-fpga.c        | 2 +-
+ drivers/pinctrl/pinctrl-upboard.c | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
+index b55e1b642cf5..64d9dafb7f53 100644
+--- a/drivers/mfd/upboard-fpga.c
++++ b/drivers/mfd/upboard-fpga.c
+@@ -345,7 +345,7 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 	{
+ 		.matches = { /* UP Xtreme */
+ 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
+-			DMI_EXACT_MATCH(DMI_BIOS_DATE, "03/18/2019"),
++			DMI_EXACT_MATCH(DMI_BIOS_DATE, "04/11/2019"),
+ 		},
+ 		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
+ 	},
+diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
+index 65e46fdb5632..10cc9aaf0d02 100644
+--- a/drivers/pinctrl/pinctrl-upboard.c
++++ b/drivers/pinctrl/pinctrl-upboard.c
+@@ -842,7 +842,7 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 	{
+ 		.matches = { /* UP Xtreme */
+ 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
+-			DMI_EXACT_MATCH(DMI_BIOS_DATE, "03/18/2019"),
++			DMI_EXACT_MATCH(DMI_BIOS_DATE, "04/11/2019"),
+ 		},
+ 		.driver_data = (void *)&upboard_up_bios_info_dvt,
+ 	},
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0019-pinctrl-fpga-up-Update-DMI-data-match.patch b/recipes-kernel/linux/files/0019-pinctrl-fpga-up-Update-DMI-data-match.patch
new file mode 100755
index 0000000..d6258a6
--- /dev/null
+++ b/recipes-kernel/linux/files/0019-pinctrl-fpga-up-Update-DMI-data-match.patch
@@ -0,0 +1,44 @@
+From c12793379586f10b253c61e8b7d448df2561956a Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Wed, 29 May 2019 20:18:50 +0100
+Subject: [PATCH 19/30] pinctrl:fpga:up: Update DMI data match
+
+Offical board name and release have been made available in the DMI data.
+upboard_fpga.c and pinctrl_upboard.c DMI matches have been update to
+use board name and version.
+---
+ drivers/mfd/upboard-fpga.c        | 3 ++-
+ drivers/pinctrl/pinctrl-upboard.c | 3 ++-
+ 2 files changed, 4 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
+index 64d9dafb7f53..42e6f242e92a 100644
+--- a/drivers/mfd/upboard-fpga.c
++++ b/drivers/mfd/upboard-fpga.c
+@@ -345,7 +345,8 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 	{
+ 		.matches = { /* UP Xtreme */
+ 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
+-			DMI_EXACT_MATCH(DMI_BIOS_DATE, "04/11/2019"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
+ 		},
+ 		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
+ 	},
+diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
+index 10cc9aaf0d02..f9bd3d157503 100644
+--- a/drivers/pinctrl/pinctrl-upboard.c
++++ b/drivers/pinctrl/pinctrl-upboard.c
+@@ -842,7 +842,8 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 	{
+ 		.matches = { /* UP Xtreme */
+ 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
+-			DMI_EXACT_MATCH(DMI_BIOS_DATE, "04/11/2019"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
+ 		},
+ 		.driver_data = (void *)&upboard_up_bios_info_dvt,
+ 	},
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0019-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch b/recipes-kernel/linux/files/0019-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch
deleted file mode 100644
index 68c3ae1..0000000
--- a/recipes-kernel/linux/files/0019-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch
+++ /dev/null
@@ -1,55 +0,0 @@
-From 245e16c812444da01cecb17524178217a92fedcb Mon Sep 17 00:00:00 2001
-From: Carlos Calderon <carlos@emutex.com>
-Date: Wed, 3 Oct 2018 13:09:36 +0100
-Subject: [PATCH] serial: 8250_dw: add quirk to disable DMA on Cherry Trail SoC
-
-Using DMA with the HS-UART on the Atom X5-8350 "Cherry Trail" SoC
-results in data loss/corruption on UART transfers and the following
-error message filling the kernel log:
-  "serial8250: too much work for irq39"
-
-As a temporary workaround, this commit disables use of DMA for the
-HS-UARTs on Cherry Trail (matching ACPI device ID "8086228A").
----
- drivers/tty/serial/8250/8250_dw.c | 8 ++++++--
- 1 file changed, 6 insertions(+), 2 deletions(-)
-
-diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
-index 284e8d0..70db76b 100644
---- a/drivers/tty/serial/8250/8250_dw.c
-+++ b/drivers/tty/serial/8250/8250_dw.c
-@@ -67,6 +67,7 @@ struct dw8250_data {
- 
- 	unsigned int		skip_autocfg:1;
- 	unsigned int		uart_16550_compatible:1;
-+	unsigned int		skip_dma:1;
- };
- 
- static inline u32 dw8250_readl_ext(struct uart_port *p, int offset)
-@@ -432,10 +433,13 @@ static void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)
- 		p->regshift = 2;
- 		p->serial_in = dw8250_serial_in32;
- 		data->uart_16550_compatible = true;
-+	} else if (acpi_dev_present("8086228A", NULL, -1)) {
-+		data->skip_dma = true;
- 	}
- 
- 	/* Platforms with iDMA 64-bit */
--	if (platform_get_resource_byname(to_platform_device(p->dev),
-+	if (!data->skip_dma &&
-+	    platform_get_resource_byname(to_platform_device(p->dev),
- 					 IORESOURCE_MEM, "lpss_priv")) {
- 		data->dma.rx_param = p->dev->parent;
- 		data->dma.tx_param = p->dev->parent;
-@@ -631,7 +635,7 @@ static int dw8250_probe(struct platform_device *pdev)
- 		dw8250_setup_port(p);
- 
- 	/* If we have a valid fifosize, try hooking up DMA */
--	if (p->fifosize) {
-+	if (!data->skip_dma && p->fifosize) {
- 		data->dma.rxconf.src_maxburst = p->fifosize / 4;
- 		data->dma.txconf.dst_maxburst = p->fifosize / 4;
- 		uart.dma = &data->dma;
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0020-ASoC-Intel-new-Baytrail-Cherrytrail-PCM512x-machine-.patch b/recipes-kernel/linux/files/0020-ASoC-Intel-new-Baytrail-Cherrytrail-PCM512x-machine-.patch
new file mode 100755
index 0000000..96bc736
--- /dev/null
+++ b/recipes-kernel/linux/files/0020-ASoC-Intel-new-Baytrail-Cherrytrail-PCM512x-machine-.patch
@@ -0,0 +1,275 @@
+From fd27e2704991515090edfcdd1b99c0fad9a45efc Mon Sep 17 00:00:00 2001
+From: Carlos Calderon <carlos@emutex.com>
+Date: Wed, 3 Oct 2018 16:18:05 +0100
+Subject: [PATCH 20/30] ASoC: Intel: new Baytrail/Cherrytrail+PCM512x machine
+ driver
+
+Basic machine driver to set SSP2 in I2S 2ch 24-bit mode.
+
+Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
+---
+ sound/soc/intel/Kconfig                 |  12 ++
+ sound/soc/intel/boards/Makefile         |   2 +
+ sound/soc/intel/boards/bytcht_pcm512x.c | 208 ++++++++++++++++++++++++
+ 3 files changed, 222 insertions(+)
+ create mode 100644 sound/soc/intel/boards/bytcht_pcm512x.c
+
+diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
+index 9c9287a0aa7d..fe0f5d528f51 100644
+--- a/sound/soc/intel/Kconfig
++++ b/sound/soc/intel/Kconfig
+@@ -246,5 +246,17 @@ config SND_SOC_INTEL_KEEMBAY
+ 	  If you have a Intel Keembay platform then enable this option
+ 	  by saying Y or m.
+ 
++config SND_SOC_INTEL_BYT_CHT_PCM512x_MACH
++	tristate "ASoC Audio driver for Intel Baytrail & Cherrytrail with TI PCM512x codec"
++	depends on X86_INTEL_LPSS && I2C && ACPI
++	select SND_SOC_PCM512x_I2C
++	select SND_SST_ATOM_HIFI2_PLATFORM
++	select SND_SST_IPC_ACPI
++	select SND_SOC_INTEL_SST_MATCH if ACPI
++	help
++	  This adds support for ASoC machine driver for Intel(R) Baytrail and Cherrytrail
++	  platforms with PCM512X audio codec.
++	  If unsure select "N".
++
+ # ASoC codec drivers
+ source "sound/soc/intel/boards/Kconfig"
+diff --git a/sound/soc/intel/boards/Makefile b/sound/soc/intel/boards/Makefile
+index f04239441aac..da68cbe4be35 100644
+--- a/sound/soc/intel/boards/Makefile
++++ b/sound/soc/intel/boards/Makefile
+@@ -15,6 +15,7 @@ snd-soc-sst-cht-bsw-max98090_ti-objs := cht_bsw_max98090_ti.o
+ snd-soc-sst-cht-bsw-nau8824-objs := cht_bsw_nau8824.o
+ snd-soc-sst-byt-cht-cx2072x-objs := bytcht_cx2072x.o
+ snd-soc-sst-byt-cht-da7213-objs := bytcht_da7213.o
++snd-soc-sst-byt-cht-pcm512x-objs := bytcht_pcm512x.o
+ snd-soc-sst-byt-cht-es8316-objs := bytcht_es8316.o
+ snd-soc-sst-byt-cht-nocodec-objs := bytcht_nocodec.o
+ snd-soc-sof_rt5682-objs := sof_rt5682.o
+@@ -47,6 +48,7 @@ obj-$(CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH) += snd-soc-sst-cht-bsw-max9
+ obj-$(CONFIG_SND_SOC_INTEL_CHT_BSW_NAU8824_MACH) += snd-soc-sst-cht-bsw-nau8824.o
+ obj-$(CONFIG_SND_SOC_INTEL_BYT_CHT_CX2072X_MACH) += snd-soc-sst-byt-cht-cx2072x.o
+ obj-$(CONFIG_SND_SOC_INTEL_BYT_CHT_DA7213_MACH) += snd-soc-sst-byt-cht-da7213.o
++obj-$(CONFIG_SND_SOC_INTEL_BYT_CHT_PCM512x_MACH) += snd-soc-sst-byt-cht-pcm512x.o
+ obj-$(CONFIG_SND_SOC_INTEL_BYT_CHT_ES8316_MACH) += snd-soc-sst-byt-cht-es8316.o
+ obj-$(CONFIG_SND_SOC_INTEL_BYT_CHT_NOCODEC_MACH) += snd-soc-sst-byt-cht-nocodec.o
+ obj-$(CONFIG_SND_SOC_INTEL_KBL_DA7219_MAX98357A_MACH) += snd-soc-kbl_da7219_max98357a.o
+diff --git a/sound/soc/intel/boards/bytcht_pcm512x.c b/sound/soc/intel/boards/bytcht_pcm512x.c
+new file mode 100644
+index 000000000000..b2a71b27da9d
+--- /dev/null
++++ b/sound/soc/intel/boards/bytcht_pcm512x.c
+@@ -0,0 +1,208 @@
++/*
++ *  bytcht-pcm512x.c - ASoc Machine driver for Intel Baytrail and
++ *             Cherrytrail-based platforms, with TI PCM512x codec
++ *
++ *  Copyright (C) 2016 Intel Corporation
++ *  Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
++ *
++ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; version 2 of the License.
++ *
++ *  This program is distributed in the hope that it will be useful, but
++ *  WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ *  General Public License for more details.
++ *
++ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++ */
++
++#include <linux/module.h>
++#include <linux/acpi.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <asm/platform_sst_audio.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++#include <sound/soc-acpi.h>
++#include "../../codecs/pcm512x.h"
++#include "../atom/sst-atom-controls.h"
++
++static const struct snd_soc_dapm_widget dapm_widgets[] = {
++	SND_SOC_DAPM_SPK("Ext Spk", NULL),
++};
++
++static const struct snd_soc_dapm_route audio_map[] = {
++	{"Playback", NULL, "ssp2 Tx"},
++	{"ssp2 Tx", NULL, "codec_out0"},
++	{"ssp2 Tx", NULL, "codec_out1"},
++};
++
++static const struct snd_kcontrol_new controls[] = {
++	SOC_DAPM_PIN_SWITCH("Ext Spk"),
++};
++
++static int codec_fixup(struct snd_soc_pcm_runtime *rtd,
++		       struct snd_pcm_hw_params *params)
++{
++	int ret;
++	struct snd_interval *rate = hw_param_interval(params,
++			SNDRV_PCM_HW_PARAM_RATE);
++	struct snd_interval *channels = hw_param_interval(params,
++						SNDRV_PCM_HW_PARAM_CHANNELS);
++
++	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
++	rate->min = rate->max = 48000;
++	channels->min = channels->max = 2;
++
++	/* set SSP2 to 24-bit */
++	params_set_format(params, SNDRV_PCM_FORMAT_S24_LE);
++
++	/*
++	 * Default mode for SSP configuration is TDM 4 slot, override config
++	 * with explicit setting to I2S 2ch 24-bit. The word length is set with
++	 * dai_set_tdm_slot() since there is no other API exposed
++	 */
++	ret = snd_soc_dai_set_fmt(rtd->cpu_dai,
++				  SND_SOC_DAIFMT_I2S     |
++				  SND_SOC_DAIFMT_NB_NF   |
++				  SND_SOC_DAIFMT_CBS_CFS
++				  );
++	if (ret < 0) {
++		dev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);
++		return ret;
++	}
++
++	ret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 24);
++	if (ret < 0) {
++		dev_err(rtd->dev, "can't set I2S config, err %d\n", ret);
++		return ret;
++	}
++
++	return 0;
++}
++
++static int aif1_startup(struct snd_pcm_substream *substream)
++{
++	return snd_pcm_hw_constraint_single(substream->runtime,
++			SNDRV_PCM_HW_PARAM_RATE, 48000);
++}
++
++static const struct snd_soc_ops aif1_ops = {
++	.startup = aif1_startup,
++};
++
++static struct snd_soc_dai_link dailink[] = {
++	[MERR_DPCM_AUDIO] = {
++		.name = "Audio Port",
++		.stream_name = "Audio",
++		.cpu_dai_name = "media-cpu-dai",
++		.codec_dai_name = "snd-soc-dummy-dai",
++		.codec_name = "snd-soc-dummy",
++		.platform_name = "sst-mfld-platform",
++		.nonatomic = true,
++		.dynamic = 1,
++		.dpcm_playback = 1,
++		.dpcm_capture = 1,
++		.ops = &aif1_ops,
++	},
++	[MERR_DPCM_DEEP_BUFFER] = {
++		.name = "Deep-Buffer Audio Port",
++		.stream_name = "Deep-Buffer Audio",
++		.cpu_dai_name = "deepbuffer-cpu-dai",
++		.codec_dai_name = "snd-soc-dummy-dai",
++		.codec_name = "snd-soc-dummy",
++		.platform_name = "sst-mfld-platform",
++		.nonatomic = true,
++		.dynamic = 1,
++		.dpcm_playback = 1,
++		.ops = &aif1_ops,
++	},
++	/* CODEC<->CODEC link */
++	/* back ends */
++	{
++		.name = "SSP2-Codec",
++		.id = 0,
++		.cpu_dai_name = "ssp2-port",
++		.platform_name = "sst-mfld-platform",
++		.no_pcm = 1,
++		.codec_dai_name = "pcm512x-hifi",
++		.codec_name = "i2c-10EC512x:00",
++		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
++						| SND_SOC_DAIFMT_CBS_CFS,
++		.be_hw_params_fixup = codec_fixup,
++		.nonatomic = true,
++		.dpcm_playback = 1,
++	},
++};
++
++/* SoC card */
++static struct snd_soc_card bytcht_pcm512x_card = {
++	.name = "bytcht-pcm512x",
++	.owner = THIS_MODULE,
++	.dai_link = dailink,
++	.num_links = ARRAY_SIZE(dailink),
++	.dapm_widgets = dapm_widgets,
++	.num_dapm_widgets = ARRAY_SIZE(dapm_widgets),
++	.dapm_routes = audio_map,
++	.num_dapm_routes = ARRAY_SIZE(audio_map),
++	.controls = controls,
++	.num_controls = ARRAY_SIZE(controls),
++};
++
++static char codec_name[SND_ACPI_I2C_ID_LEN];
++
++static int bytcht_pcm512x_probe(struct platform_device *pdev)
++{
++	int ret_val = 0;
++	int i;
++	struct snd_soc_card *card;
++	struct snd_soc_acpi_mach *mach;
++	const char *i2c_name = NULL;
++	int dai_index = 0;
++
++	mach = (&pdev->dev)->platform_data;
++	card = &bytcht_pcm512x_card;
++	card->dev = &pdev->dev;
++
++	/* fix index of codec dai */
++	for (i = 0; i < ARRAY_SIZE(dailink); i++) {
++		if (!strcmp(dailink[i].codec_name, "i2c-104C512x:00")) {
++			dai_index = i;
++			break;
++		}
++	}
++
++	/* fixup codec name based on HID */
++	i2c_name = acpi_dev_get_first_match_name(mach->id, NULL, -1);
++	if (i2c_name != NULL) {
++		snprintf(codec_name, sizeof(codec_name),
++			"%s%s", "i2c-", i2c_name);
++		dailink[dai_index].codec_name = codec_name;
++	}
++
++	ret_val = devm_snd_soc_register_card(&pdev->dev, card);
++	if (ret_val) {
++		dev_err(&pdev->dev,
++			"snd_soc_register_card failed %d\n", ret_val);
++		return ret_val;
++	}
++	platform_set_drvdata(pdev, card);
++	return ret_val;
++}
++
++static struct platform_driver bytcht_pcm521x_driver = {
++	.driver = {
++		.name = "bytcht-pcm512x",
++	},
++	.probe = bytcht_pcm512x_probe,
++};
++module_platform_driver(bytcht_pcm521x_driver);
++
++MODULE_DESCRIPTION("ASoC Intel(R) Baytrail/Cherrytrail + PCM512x Machine driver");
++MODULE_AUTHOR("Pierre-Louis Bossart");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:bytcht-pcm512x");
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0020-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch b/recipes-kernel/linux/files/0020-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch
deleted file mode 100644
index d9d9b08..0000000
--- a/recipes-kernel/linux/files/0020-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-From 5c014fd59dfd8972f44529abb11e0faaeafef7ba Mon Sep 17 00:00:00 2001
-From: Dan O'Donovan <dan@emutex.com>
-Date: Thu, 9 May 2019 12:59:40 +0100
-Subject: [PATCH] platform/x86: upboard: fix gpio/pinctrl API references
-
-Changes in the signatures of some gpio and pinctrl subsystem API
-functions and data-structures, added in v4.15, need to be reflected
-in this UP-board legacy pinctrl driver (which was ported from a v4.14
-kernel)
-
-Signed-off-by: Dan O'Donovan <dan@emutex.com>
----
- drivers/platform/x86/up_board_pinctrl.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
-diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
-index e6c9de4..bcc23ea 100644
---- a/drivers/platform/x86/up_board_pinctrl.c
-+++ b/drivers/platform/x86/up_board_pinctrl.c
-@@ -622,7 +622,7 @@ static int up_gpio_request(struct gpio_chip *gc, unsigned offset)
- 	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
- 	struct gpio_desc *desc = pin->soc_gpio.desc;
- 
--	pinctrl_request_gpio(gc->base + offset);
-+	pinctrl_gpio_request(gc->base + offset);
- 	return gpio_request(desc_to_gpio(desc), gc->label);
- }
- 
-@@ -632,7 +632,7 @@ static void up_gpio_free(struct gpio_chip *gc, unsigned offset)
- 	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
- 	struct gpio_desc *desc = pin->soc_gpio.desc;
- 
--	pinctrl_free_gpio(gc->base + offset);
-+	pinctrl_gpio_free(gc->base + offset);
- 	gpio_free(desc_to_gpio(desc));
- }
- 
-@@ -908,7 +908,7 @@ static int up_pinctrl_probe(struct platform_device *pdev)
- 		struct up_pin_info *pin = &board->pins[offset];
- 		struct irq_data *irq_data;
- 
--		pin->irq = irq_find_mapping(up_pctrl->chip.irqdomain, offset);
-+		pin->irq = irq_find_mapping(up_pctrl->chip.irq.domain, offset);
- 		pin->soc_gpio.irq = gpiod_to_irq(pin->soc_gpio.desc);
- 		irq_set_parent(pin->irq, pin->soc_gpio.irq);
- 		irq_data = irq_get_irq_data(pin->irq);
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0021-ASoC-Intel-bytcht_pcm512x-use-modern-dai_link-style.patch b/recipes-kernel/linux/files/0021-ASoC-Intel-bytcht_pcm512x-use-modern-dai_link-style.patch
new file mode 100755
index 0000000..24a4d6b
--- /dev/null
+++ b/recipes-kernel/linux/files/0021-ASoC-Intel-bytcht_pcm512x-use-modern-dai_link-style.patch
@@ -0,0 +1,122 @@
+From 2f627e43ddb45b072336fa497d06ebc6931ad310 Mon Sep 17 00:00:00 2001
+From: frank2_hsieh <frank2_hsieh@asus.com>
+Date: Tue, 8 Sep 2020 14:25:03 +0800
+Subject: [PATCH 21/30] ASoC: Intel: bytcht_pcm512x: use modern dai_link style
+
+Refer the following commit.
+ASoC: Intel: bytcht_cx2072x: use modern dai_link style
+---
+ sound/soc/intel/boards/bytcht_pcm512x.c | 47 +++++++++++++++----------
+ 1 file changed, 29 insertions(+), 18 deletions(-)
+
+diff --git a/sound/soc/intel/boards/bytcht_pcm512x.c b/sound/soc/intel/boards/bytcht_pcm512x.c
+index b2a71b27da9d..c25ad0982a15 100644
+--- a/sound/soc/intel/boards/bytcht_pcm512x.c
++++ b/sound/soc/intel/boards/bytcht_pcm512x.c
+@@ -95,47 +95,56 @@ static const struct snd_soc_ops aif1_ops = {
+ 	.startup = aif1_startup,
+ };
+ 
++SND_SOC_DAILINK_DEF(dummy,
++       DAILINK_COMP_ARRAY(COMP_DUMMY()));
++
++SND_SOC_DAILINK_DEF(media,
++       DAILINK_COMP_ARRAY(COMP_CPU("media-cpu-dai")));
++
++SND_SOC_DAILINK_DEF(deepbuffer,
++       DAILINK_COMP_ARRAY(COMP_CPU("deepbuffer-cpu-dai")));
++
++SND_SOC_DAILINK_DEF(ssp2,
++       DAILINK_COMP_ARRAY(COMP_CPU("ssp2-port")));
++
++SND_SOC_DAILINK_DEF(pcm512x,
++       DAILINK_COMP_ARRAY(COMP_CODEC("i2c-10EC512x:00", "pcm512x-hifi")));
++
++SND_SOC_DAILINK_DEF(platform,
++       DAILINK_COMP_ARRAY(COMP_PLATFORM("sst-mfld-platform")));
++
+ static struct snd_soc_dai_link dailink[] = {
+ 	[MERR_DPCM_AUDIO] = {
+ 		.name = "Audio Port",
+ 		.stream_name = "Audio",
+-		.cpu_dai_name = "media-cpu-dai",
+-		.codec_dai_name = "snd-soc-dummy-dai",
+-		.codec_name = "snd-soc-dummy",
+-		.platform_name = "sst-mfld-platform",
+ 		.nonatomic = true,
+ 		.dynamic = 1,
+ 		.dpcm_playback = 1,
+ 		.dpcm_capture = 1,
+ 		.ops = &aif1_ops,
++		SND_SOC_DAILINK_REG(media, dummy, platform),
+ 	},
+ 	[MERR_DPCM_DEEP_BUFFER] = {
+ 		.name = "Deep-Buffer Audio Port",
+ 		.stream_name = "Deep-Buffer Audio",
+-		.cpu_dai_name = "deepbuffer-cpu-dai",
+-		.codec_dai_name = "snd-soc-dummy-dai",
+-		.codec_name = "snd-soc-dummy",
+-		.platform_name = "sst-mfld-platform",
+ 		.nonatomic = true,
+ 		.dynamic = 1,
+ 		.dpcm_playback = 1,
+ 		.ops = &aif1_ops,
++		SND_SOC_DAILINK_REG(deepbuffer, dummy, platform),
+ 	},
+ 	/* CODEC<->CODEC link */
+ 	/* back ends */
+ 	{
+ 		.name = "SSP2-Codec",
+ 		.id = 0,
+-		.cpu_dai_name = "ssp2-port",
+-		.platform_name = "sst-mfld-platform",
+ 		.no_pcm = 1,
+-		.codec_dai_name = "pcm512x-hifi",
+-		.codec_name = "i2c-10EC512x:00",
+ 		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+ 						| SND_SOC_DAIFMT_CBS_CFS,
+ 		.be_hw_params_fixup = codec_fixup,
+ 		.nonatomic = true,
+ 		.dpcm_playback = 1,
++		SND_SOC_DAILINK_REG(ssp2, pcm512x, platform),
+ 	},
+ };
+ 
+@@ -161,7 +170,8 @@ static int bytcht_pcm512x_probe(struct platform_device *pdev)
+ 	int i;
+ 	struct snd_soc_card *card;
+ 	struct snd_soc_acpi_mach *mach;
+-	const char *i2c_name = NULL;
++	//const char *i2c_name = NULL;
++	struct acpi_device *adev;
+ 	int dai_index = 0;
+ 
+ 	mach = (&pdev->dev)->platform_data;
+@@ -170,18 +180,19 @@ static int bytcht_pcm512x_probe(struct platform_device *pdev)
+ 
+ 	/* fix index of codec dai */
+ 	for (i = 0; i < ARRAY_SIZE(dailink); i++) {
+-		if (!strcmp(dailink[i].codec_name, "i2c-104C512x:00")) {
++		if (!strcmp(dailink[i].codecs->name, "i2c-104C512x:00")) {
+ 			dai_index = i;
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* fixup codec name based on HID */
+-	i2c_name = acpi_dev_get_first_match_name(mach->id, NULL, -1);
+-	if (i2c_name != NULL) {
++	adev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);
++	if (adev != NULL) {
+ 		snprintf(codec_name, sizeof(codec_name),
+-			"%s%s", "i2c-", i2c_name);
+-		dailink[dai_index].codec_name = codec_name;
++			"%s%s", "i2c-", acpi_dev_name(adev));
++		put_device(&adev->dev);
++		dailink[dai_index].codecs->name = codec_name;
+ 	}
+ 
+ 	ret_val = devm_snd_soc_register_card(&pdev->dev, card);
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0021-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch b/recipes-kernel/linux/files/0021-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch
deleted file mode 100644
index 5beab4d..0000000
--- a/recipes-kernel/linux/files/0021-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From 45931854e169ccbe804a9705a0fd9cfcb4e3e3ff Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Thu, 11 Jul 2019 14:58:04 +0000
-Subject: [PATCH 1/1] upboard pinctrl: drop regmap patches for UP Xtreme
-
-Since BIOS release UPW1AM0N (07/05/2019) for UP Xtreme, the FPGA pinctrl
-configuration registers are intialised by the BIOS and regmap patches to set
-default values can now be removed.
----
- drivers/mfd/upboard-fpga.c        | 1 -
- drivers/pinctrl/pinctrl-upboard.c | 8 --------
- 2 files changed, 9 deletions(-)
-
-diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
-index 42e6f24..532b58f 100644
---- a/drivers/mfd/upboard-fpga.c
-+++ b/drivers/mfd/upboard-fpga.c
-@@ -348,7 +348,6 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
- 			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
- 			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
- 		},
--		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
- 	},
- 	{ },
- };
-diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
-index f9bd3d1..2ee1085 100644
---- a/drivers/pinctrl/pinctrl-upboard.c
-+++ b/drivers/pinctrl/pinctrl-upboard.c
-@@ -839,14 +839,6 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
- 		},
- 		.driver_data = (void *)&upboard_up2_bios_info_v0_3,
- 	},
--	{
--		.matches = { /* UP Xtreme */
--			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
--			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
--			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
--		},
--		.driver_data = (void *)&upboard_up_bios_info_dvt,
--	},
- 	{ },
- };
- 
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0022-i2c-designware-platdrv-Add-module-parameter-to-overr.patch b/recipes-kernel/linux/files/0022-i2c-designware-platdrv-Add-module-parameter-to-overr.patch
deleted file mode 100644
index 019d6e9..0000000
--- a/recipes-kernel/linux/files/0022-i2c-designware-platdrv-Add-module-parameter-to-overr.patch
+++ /dev/null
@@ -1,46 +0,0 @@
-From 593a991da9309ac934215d36375fc96cec606c55 Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Thu, 19 Dec 2019 20:08:32 +0000
-Subject: [PATCH] i2c: designware-platdrv: Add module parameter to override i2c
- speed
-
-This commit adds a module parameter to i2c-designware-platdrv.c to allow the
-user to override the i2c bus speed set by the acpi.
----
- drivers/i2c/busses/i2c-designware-platdrv.c | 13 +++++++++++++
- 1 file changed, 13 insertions(+)
-
-diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
-index b38f338..e6271f8 100644
---- a/drivers/i2c/busses/i2c-designware-platdrv.c
-+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
-@@ -33,6 +33,10 @@
- 
- #include "i2c-designware-core.h"
- 
-+static unsigned int i2c_freq;
-+module_param(i2c_freq, uint, S_IRUGO);
-+MODULE_PARM_DESC(i2c_freq, "I2C clock frequency");
-+
- static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
- {
- 	return clk_get_rate(dev->clk)/1000;
-@@ -267,6 +271,15 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
- 	else
- 		i2c_parse_fw_timings(&pdev->dev, t, false);
- 
-+	if (i2c_freq) {
-+		dev_warn(&pdev->dev,
-+			"I2C Frequency override by module parameter:"
-+			"old frequency=%u new frequency=%u\n",
-+			t->bus_freq_hz,
-+			i2c_freq);
-+		t->bus_freq_hz = i2c_freq;
-+	}
-+
- 	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
- 	/*
- 	 * Some DSTDs use a non standard speed, round down to the lowest
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0022-pinctrl-core-translate-gpio-to-pin-before-config.patch b/recipes-kernel/linux/files/0022-pinctrl-core-translate-gpio-to-pin-before-config.patch
new file mode 100755
index 0000000..cf616ab
--- /dev/null
+++ b/recipes-kernel/linux/files/0022-pinctrl-core-translate-gpio-to-pin-before-config.patch
@@ -0,0 +1,83 @@
+From a06d1c41ab898dcd3a70b1242fe8b6b4686dc16e Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Thu, 4 Jul 2019 13:03:51 +0100
+Subject: [PATCH 22/30] pinctrl-core: translate gpio to pin before config
+
+This commit reverts e73fcf0459e9c63bd55a9acf2f85cbf9e9c77f67 and performs the
+gpio to pin translation using the same method as pinctrl_gpio_direction.
+---
+ drivers/pinctrl/core.c | 39 ++++++++++++++++++++++++++-------------
+ 1 file changed, 26 insertions(+), 13 deletions(-)
+
+diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
+index 245e628046fe..3b1f376c80ec 100755
+--- a/drivers/pinctrl/core.c
++++ b/drivers/pinctrl/core.c
+@@ -972,6 +972,26 @@ int pinctrl_gpio_direction_output(unsigned gpio)
+ }
+ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
+ 
++static int pinctrl_set_config_if_match(struct pinctrl_dev *pctldev,
++					unsigned int gpio, unsigned long config)
++{
++	struct pinctrl_gpio_range *range;
++	int ret = 0;
++
++	range = pinctrl_match_gpio_range(pctldev, gpio);
++
++	if (range != NULL) {
++		int pin;
++
++		mutex_lock(&pctldev->mutex);
++		pin = gpio_to_pin(range, gpio);
++		ret = pinconf_set_config(pctldev, pin, &config, 1);
++		mutex_unlock(&pctldev->mutex);
++	}
++
++	return ret;
++}
++
+ /**
+  * pinctrl_gpio_set_config() - Apply config to given GPIO pin
+  * @gpio: the GPIO pin number from the GPIO subsystem number space
+@@ -983,11 +1003,8 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
+  */
+ int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
+ {
+-	unsigned long configs[] = { config };
+-	struct pinctrl_gpio_range *range = NULL;
+ 	struct pinctrl_dev *pctldev;
+ 	struct gpio_desc *desc;
+-	int pin;
+ 	int dir;
+ 	int ret = -EPROBE_DEFER;
+ 
+@@ -1014,19 +1031,15 @@ int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
+ 	 */
+ 	if (dir == 1) {
+ 		list_for_each_entry(pctldev, &pinctrldev_list, node) {
+-			range = pinctrl_match_gpio_range(pctldev, gpio);
+-			if (range == NULL)
+-				continue;
+-			pin = gpio_to_pin(range, gpio);
+-			ret = pinconf_set_config(pctldev, pin, configs, ARRAY_SIZE(configs));
++			ret = pinctrl_set_config_if_match(pctldev, gpio, config);
++			if (ret)
++				break;
+ 		}
+ 	} else {
+ 		list_for_each_entry_reverse(pctldev, &pinctrldev_list, node) {
+-			range = pinctrl_match_gpio_range(pctldev, gpio);
+-			if (range == NULL)
+-				continue;
+-			pin = gpio_to_pin(range, gpio);
+-			ret = pinconf_set_config(pctldev, pin, configs, ARRAY_SIZE(configs));
++			ret = pinctrl_set_config_if_match(pctldev, gpio, config);
++			if (ret)
++				break;
+ 		}
+ 	}
+ 
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0023-i2c-designware-platdrv-Use-ACPI-method-FREQ-to-get-i.patch b/recipes-kernel/linux/files/0023-i2c-designware-platdrv-Use-ACPI-method-FREQ-to-get-i.patch
deleted file mode 100644
index 5661973..0000000
--- a/recipes-kernel/linux/files/0023-i2c-designware-platdrv-Use-ACPI-method-FREQ-to-get-i.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From 6ef77aa395643355f3c49b7100c2bb032db99f0b Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Thu, 19 Dec 2019 18:46:29 +0000
-Subject: [PATCH] i2c: designware-platdrv: Use ACPI method FREQ to get i2c
- speed
-
-The UP Board BIOS provides a method to specify the i2c speed for HAT i2c
-ports. This commit adds the mechanisms to retrieve this value from the ACPI
-method and apply it to the i2c controller.
----
- drivers/i2c/busses/i2c-designware-platdrv.c | 16 ++++++++++++++++
- 1 file changed, 16 insertions(+)
-
-diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
-index eca5bc9..ea4b2b4 100644
---- a/drivers/i2c/busses/i2c-designware-platdrv.c
-+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
-@@ -84,6 +84,19 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
- 	kfree(buf.pointer);
- }
- 
-+static void dw_i2c_acpi_freq_param(struct platform_device *pdev, u32 *freq)
-+{
-+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
-+	unsigned long long tmp;
-+
-+	if (ACPI_FAILURE(acpi_evaluate_integer(handle, "FREQ", NULL, &tmp)))
-+		return;
-+
-+	*freq = (u32)tmp;
-+	dev_dbg(&pdev->dev, "%u Hz bus speed specified by 'FREQ' ACPI method\n",
-+		*freq);
-+}
-+
- static int dw_i2c_acpi_configure(struct platform_device *pdev)
- {
- 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-@@ -270,6 +283,9 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
- 	else
- 		i2c_parse_fw_timings(&pdev->dev, t, false);
- 
-+	if (has_acpi_companion(&pdev->dev))
-+		dw_i2c_acpi_freq_param(pdev, &t->bus_freq_hz);
-+
- 	if (i2c_freq) {
- 		dev_warn(&pdev->dev,
- 			"I2C Frequency override by module parameter:"
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0023-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch b/recipes-kernel/linux/files/0023-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch
new file mode 100755
index 0000000..03a4c73
--- /dev/null
+++ b/recipes-kernel/linux/files/0023-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch
@@ -0,0 +1,47 @@
+From 02be7bf52341d0bd73ff1c3fde9f47167a37fa76 Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Thu, 11 Jul 2019 14:58:04 +0000
+Subject: [PATCH 23/30] upboard pinctrl: drop regmap patches for UP Xtreme
+
+Since BIOS release UPW1AM0N (07/05/2019) for UP Xtreme, the FPGA pinctrl
+configuration registers are intialised by the BIOS and regmap patches to set
+default values can now be removed.
+---
+ drivers/mfd/upboard-fpga.c        | 1 -
+ drivers/pinctrl/pinctrl-upboard.c | 8 --------
+ 2 files changed, 9 deletions(-)
+
+diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
+index 42e6f242e92a..532b58f0aed4 100644
+--- a/drivers/mfd/upboard-fpga.c
++++ b/drivers/mfd/upboard-fpga.c
+@@ -348,7 +348,6 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
+ 			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
+ 		},
+-		.driver_data = (void *)UPFPGA_QUIRK_UNINITIALISED,
+ 	},
+ 	{ },
+ };
+diff --git a/drivers/pinctrl/pinctrl-upboard.c b/drivers/pinctrl/pinctrl-upboard.c
+index f9bd3d157503..2ee1085e60db 100644
+--- a/drivers/pinctrl/pinctrl-upboard.c
++++ b/drivers/pinctrl/pinctrl-upboard.c
+@@ -839,14 +839,6 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 		},
+ 		.driver_data = (void *)&upboard_up2_bios_info_v0_3,
+ 	},
+-	{
+-		.matches = { /* UP Xtreme */
+-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
+-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UP-WHL01"),
+-			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V0.1"),
+-		},
+-		.driver_data = (void *)&upboard_up_bios_info_dvt,
+-	},
+ 	{ },
+ };
+ 
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0024-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch b/recipes-kernel/linux/files/0024-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch
deleted file mode 100644
index 8606f51..0000000
--- a/recipes-kernel/linux/files/0024-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From 9669f10ef1cc954a6d37a054ac0b2b434099053d Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Wed, 20 Nov 2019 11:33:52 +0000
-Subject: [PATCH 1/3] spi: pxa2xx: Set dir and value when requesting cs gpio
-
-The pxa2xx driver assumes the gpio direction and value have already been
-configured prior to requesting the gpio for chip select.
-
-This is not always the case on the UP Platform so this commit replaces
-GPIOD_ASIS with GPIOD_OUT_HIGH.
-
-Signed-off-by: Michael Campion <michael.campion@emutex.com>
----
- drivers/spi/spi-pxa2xx.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
-index 4cb515a..1f54a7b 100644
---- a/drivers/spi/spi-pxa2xx.c
-+++ b/drivers/spi/spi-pxa2xx.c
-@@ -1769,7 +1769,7 @@ static int pxa2xx_spi_probe(struct platform_device *pdev)
- 		for (i = 0; i < master->num_chipselect; i++) {
- 			struct gpio_desc *gpiod;
- 
--			gpiod = devm_gpiod_get_index(dev, "cs", i, GPIOD_ASIS);
-+			gpiod = devm_gpiod_get_index(dev, "cs", i, GPIOD_OUT_HIGH);
- 			if (IS_ERR(gpiod)) {
- 				/* Means use native chip select */
- 				if (PTR_ERR(gpiod) == -ENOENT)
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0024-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch b/recipes-kernel/linux/files/0024-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch
new file mode 100755
index 0000000..bf75b09
--- /dev/null
+++ b/recipes-kernel/linux/files/0024-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch
@@ -0,0 +1,122 @@
+From 4721db5b614e7e6b3c20d16a226af67425f06b44 Mon Sep 17 00:00:00 2001
+From: Dan O'Donovan <dan@emutex.com>
+Date: Thu, 15 Nov 2018 21:33:12 +0000
+Subject: [PATCH 24/30] up: pinctrl: change SoC gpio references to use h/w pin
+ offsets
+
+Commit 03c4749dd6c7 "gpio / ACPI: Drop unnecessary ACPI GPIO to
+ Linux GPIO translation" changed how the GPIO pins were numbered
+by the CherryView pinctrl/gpio driver.  Consequently, the numeric
+references to those GPIO pins need also to be updated in this driver
+to match.  The numbering scheme is now based directly on the h/w
+pin offsets within the controller (which are non-contiguous) instead
+of the contiguous numbering that was previously used.
+
+Signed-off-by: Dan O'Donovan <dan@emutex.com>
+---
+ drivers/platform/x86/up_board_pinctrl.c | 70 ++++++++++++-------------
+ 1 file changed, 35 insertions(+), 35 deletions(-)
+
+diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
+index bcc23ea472aa..c31804602dad 100644
+--- a/drivers/platform/x86/up_board_pinctrl.c
++++ b/drivers/platform/x86/up_board_pinctrl.c
+@@ -180,7 +180,7 @@ static struct up_soc_gpiochip_info chip_cht_SE = { .name = "INT33FF:03" };
+ #define GPIO_PINRANGE(start, end)		\
+ 	{					\
+ 		.base = (start),		\
+-		.npins = (end) - (start) $ 1,	\
++		.npins = (end) - (start) + 1,	\
+ 	}
+ 
+ #define N_GPIO 28
+@@ -199,34 +199,34 @@ static struct up_soc_gpiochip_info chip_cht_SE = { .name = "INT33FF:03" };
+  */
+ /* UP Board uses a CPLD to provide I/O signal buffers and mux switching */
+ static struct up_pin_info up_pins[N_GPIO] = {
+-	GPIO_PIN_UP(&chip_cht_SW, 33,  9, FDIR_OUT, 28, 0, 1),	/*  0 */
+-	GPIO_PIN_UP(&chip_cht_SW, 37, 23, FDIR_OUT, 28, 0, 1),	/*  1 */
+-	GPIO_PIN_UP(&chip_cht_SW, 32,  0, FDIR_OUT, 29, 0, 1),	/*  2 */
+-	GPIO_PIN_UP(&chip_cht_SW, 35,  1, FDIR_OUT, 29, 0, 1),	/*  3 */
+-	GPIO_PIN_UP(&chip_cht_E,  18,  2, FDIR_IN,  30, 0, 1),	/*  4 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  21, 10, FDIR_NONE),		/*  5 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  12, 11, FDIR_NONE),		/*  6 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 48, 22, FDIR_NONE),		/*  7 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  7, 21, FDIR_OUT),		/*  8 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  3,  7, FDIR_IN),		/*  9 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  6,  6, FDIR_OUT),		/* 10 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  4,  8, FDIR_OUT),		/* 11 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  5, 24, FDIR_OUT),		/* 12 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  1, 12, FDIR_OUT),		/* 13 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 13, 15, FDIR_OUT),		/* 14 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  9, 16, FDIR_IN),		/* 15 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 11, 25, FDIR_IN),		/* 16 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  8,  3, FDIR_OUT),		/* 17 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 50, 17, FDIR_OUT),		/* 18 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 54, 13, FDIR_OUT),		/* 19 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 52, 26, FDIR_IN),		/* 20 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 55, 27, FDIR_OUT),		/* 21 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 12,  5, FDIR_OUT),		/* 22 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 15, 18, FDIR_OUT),		/* 23 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 18, 19, FDIR_OUT),		/* 24 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 11, 20, FDIR_OUT),		/* 25 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 14, 14, FDIR_OUT),		/* 26 */
+-	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  8,  4, FDIR_OUT),		/* 27 */
++	GPIO_PIN_UP(&chip_cht_SW, 61,  9, FDIR_OUT, 28, 0, 1),	/*  0 */
++	GPIO_PIN_UP(&chip_cht_SW, 65, 23, FDIR_OUT, 28, 0, 1),	/*  1 */
++	GPIO_PIN_UP(&chip_cht_SW, 60,  0, FDIR_OUT, 29, 0, 1),	/*  2 */
++	GPIO_PIN_UP(&chip_cht_SW, 63,  1, FDIR_OUT, 29, 0, 1),	/*  3 */
++	GPIO_PIN_UP(&chip_cht_E,  21,  2, FDIR_IN,  30, 0, 1),	/*  4 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  24, 10, FDIR_NONE),	/*  5 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  15, 11, FDIR_NONE),	/*  6 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 79, 22, FDIR_NONE),	/*  7 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  7, 21, FDIR_OUT),	/*  8 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  3,  7, FDIR_IN),	/*  9 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  6,  6, FDIR_OUT),	/* 10 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  4,  8, FDIR_OUT),	/* 11 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  5, 24, FDIR_OUT),	/* 12 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  1, 12, FDIR_OUT),	/* 13 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 20, 15, FDIR_OUT),	/* 14 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 16, 16, FDIR_IN),	/* 15 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 18, 25, FDIR_IN),	/* 16 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 15,  3, FDIR_OUT),	/* 17 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 92, 17, FDIR_OUT),	/* 18 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 96, 13, FDIR_OUT),	/* 19 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 94, 26, FDIR_IN),	/* 20 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 97, 27, FDIR_OUT),	/* 21 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 19,  5, FDIR_OUT),	/* 22 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 22, 18, FDIR_OUT),	/* 23 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 25, 19, FDIR_OUT),	/* 24 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 18, 20, FDIR_OUT),	/* 25 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 21, 14, FDIR_OUT),	/* 26 */
++	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 15,  4, FDIR_OUT),	/* 27 */
+ };
+ 
+ static struct up_cpld_led_info up_cpld_leds[] = {
+@@ -236,11 +236,11 @@ static struct up_cpld_led_info up_cpld_leds[] = {
+ };
+ 
+ static struct up_cpld_info up_cpld = {
+-	.strobe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_N, 21),
+-	.reset_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 15),
+-	.data_in_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 13),
+-	.data_out_gpio		= SOC_GPIO_INPUT(&chip_cht_E, 23),
+-	.oe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_SW, 43),
++	.strobe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_N, 27),
++	.reset_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 18),
++	.data_in_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 16),
++	.data_out_gpio		= SOC_GPIO_INPUT(&chip_cht_E, 26),
++	.oe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_SW, 78),
+ 	.dir_reg		= CPLD_DIR_REG_INIT,
+ 	.do_verify		= true,
+ 	.do_strobe_after_write	= false,
+@@ -986,4 +986,4 @@ module_exit(up_pinctrl_exit);
+ MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
+ MODULE_DESCRIPTION("Pin Control driver for UP Board I/O pin header");
+ MODULE_LICENSE("GPL v2");
+-MODULE_ALIAS("platform:up-pinctrl");
+\ No newline at end of file
++MODULE_ALIAS("platform:up-pinctrl");
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0025-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch b/recipes-kernel/linux/files/0025-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch
deleted file mode 100644
index d6155bc..0000000
--- a/recipes-kernel/linux/files/0025-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch
+++ /dev/null
@@ -1,81 +0,0 @@
-From ef7dbac4473ad98ec8d06463b9fad57b138fc331 Mon Sep 17 00:00:00 2001
-From: Michael Campion <michael.campion@emutex.com>
-Date: Wed, 20 Nov 2019 13:15:08 +0000
-Subject: [PATCH 2/3] platform/x86: upboard: Add gpio chip select for UP Board
- SPI
-
-The UP Board SOC provides only 1 native chip select but requires 2 chip
-select lines for compatibility with RPi peripherals.
-
-This patch adds the option to enable a gpio chip select on any available
-HAT gpio (0 to 27) by passing the value to the up_board module parameter
-spi_cs1_gpio on the kernel command line.
-
-Signed-off-by: Michael Campion <michael.campion@emutex.com>
----
- drivers/platform/x86/up_board.c | 28 ++++++++++++++++++++++++++++
- 1 file changed, 28 insertions(+)
-
-diff --git a/drivers/platform/x86/up_board.c b/drivers/platform/x86/up_board.c
-index 3acbed7..a83ca94 100644
---- a/drivers/platform/x86/up_board.c
-+++ b/drivers/platform/x86/up_board.c
-@@ -28,6 +28,8 @@
- #include <linux/regulator/fixed.h>
- #include <linux/regulator/machine.h>
- #include <linux/acpi.h>
-+#include <linux/gpio/machine.h>
-+#include <linux/gpio.h>
- 
- #define UP_BOARD_SPIDEV_BUS_NUM 2
- #define UP_BOARD_SPIDEV_MAX_CLK 25000000
-@@ -46,6 +48,14 @@ static bool spidev1 = false;
- module_param(spidev1, bool, S_IRUGO);
- MODULE_PARM_DESC(spidev1, "register a spidev device on SPI bus 2-1");
- 
-+/* Default SPI bus 2-1 chip select on HAT pin 26 */
-+#define SPI_CS1_DEFAULT_GPIO (7)
-+
-+static int spi_cs1_gpio = SPI_CS1_DEFAULT_GPIO;
-+module_param(spi_cs1_gpio, int, S_IRUGO);
-+MODULE_PARM_DESC(spi_cs1_gpio,
-+		"Gpio for SPI bus 2-1 chip select (0 to 27), or -1 to disable");
-+
- /* On the UP board, if the ODEn bit is set on the pad configuration
-  * it seems to impair some functions on the I/O header such as UART, SPI
-  * and even I2C.  So we disable it for all header pins by default.
-@@ -101,6 +111,19 @@ static struct spi_board_info up_spidev_info __initdata = {
- 	.max_speed_hz   = UP_BOARD_SPIDEV_MAX_CLK,
- };
- 
-+/* On UP Board there is no native chip select 1 available on SPI Bus 2. This
-+ * table will be used to reserve a gpio for chip select 1 using the default
-+ * gpio on HAT Pin 26 or the gpio number passed to this module's spi_cs1_gpio
-+ * parameter. -1 will disable the reservation of a gpio for chip select.
-+ */
-+static struct gpiod_lookup_table up_spi_cs_gpiod_table = {
-+	.dev_id		= "8086228E:01",
-+	.table		= {
-+		GPIO_LOOKUP_IDX("up-pinctrl",
-+				SPI_CS1_DEFAULT_GPIO, "cs", 1, GPIO_ACTIVE_HIGH),
-+	},
-+};
-+
- static int __init
- up_board_init_devices(void)
- {
-@@ -170,6 +193,11 @@ up_board_init(void) {
- 
- 	board_info = system_id->driver_data;
- 
-+	if (gpio_is_valid(spi_cs1_gpio)) {
-+		up_spi_cs_gpiod_table.table[0].chip_hwnum = spi_cs1_gpio;
-+		gpiod_add_lookup_table(&up_spi_cs_gpiod_table);
-+	}
-+
- 	/* Register pin control mappings specific to board version */
- 	if (board_info->pinmux_maps) {
- 		ret = pinctrl_register_mappings(board_info->pinmux_maps,
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0025-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch b/recipes-kernel/linux/files/0025-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch
new file mode 100755
index 0000000..e6e71f5
--- /dev/null
+++ b/recipes-kernel/linux/files/0025-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch
@@ -0,0 +1,32 @@
+From 0dfc7c69760873603c63c8604037066e304ebcb5 Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Wed, 20 Nov 2019 11:33:52 +0000
+Subject: [PATCH 25/30] spi: pxa2xx: Set dir and value when requesting cs gpio
+
+The pxa2xx driver assumes the gpio direction and value have already been
+configured prior to requesting the gpio for chip select.
+
+This is not always the case on the UP Platform so this commit replaces
+GPIOD_ASIS with GPIOD_OUT_HIGH.
+
+Signed-off-by: Michael Campion <michael.campion@emutex.com>
+---
+ drivers/spi/spi-pxa2xx.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
+index 727ba6f5f241..a7db822cd1b7 100644
+--- a/drivers/spi/spi-pxa2xx.c
++++ b/drivers/spi/spi-pxa2xx.c
+@@ -1854,7 +1854,7 @@ static int pxa2xx_spi_probe(struct platform_device *pdev)
+ 		for (i = 0; i < controller->num_chipselect; i++) {
+ 			struct gpio_desc *gpiod;
+ 
+-			gpiod = devm_gpiod_get_index(dev, "cs", i, GPIOD_ASIS);
++			gpiod = devm_gpiod_get_index(dev, "cs", i, GPIOD_OUT_HIGH);
+ 			if (IS_ERR(gpiod)) {
+ 				/* Means use native chip select */
+ 				if (PTR_ERR(gpiod) == -ENOENT)
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0026-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch b/recipes-kernel/linux/files/0026-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch
new file mode 100755
index 0000000..70b33b9
--- /dev/null
+++ b/recipes-kernel/linux/files/0026-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch
@@ -0,0 +1,81 @@
+From b3b9eea9a0b3acb14395c6c7fd3a78a6ee2e2000 Mon Sep 17 00:00:00 2001
+From: Michael Campion <michael.campion@emutex.com>
+Date: Wed, 20 Nov 2019 13:15:08 +0000
+Subject: [PATCH 26/30] platform/x86: upboard: Add gpio chip select for UP
+ Board SPI
+
+The UP Board SOC provides only 1 native chip select but requires 2 chip
+select lines for compatibility with RPi peripherals.
+
+This patch adds the option to enable a gpio chip select on any available
+HAT gpio (0 to 27) by passing the value to the up_board module parameter
+spi_cs1_gpio on the kernel command line.
+
+Signed-off-by: Michael Campion <michael.campion@emutex.com>
+---
+ drivers/platform/x86/up_board.c | 28 ++++++++++++++++++++++++++++
+ 1 file changed, 28 insertions(+)
+
+diff --git a/drivers/platform/x86/up_board.c b/drivers/platform/x86/up_board.c
+index 3acbed72dbf6..a83ca94ad924 100644
+--- a/drivers/platform/x86/up_board.c
++++ b/drivers/platform/x86/up_board.c
+@@ -28,6 +28,8 @@
+ #include <linux/regulator/fixed.h>
+ #include <linux/regulator/machine.h>
+ #include <linux/acpi.h>
++#include <linux/gpio/machine.h>
++#include <linux/gpio.h>
+ 
+ #define UP_BOARD_SPIDEV_BUS_NUM 2
+ #define UP_BOARD_SPIDEV_MAX_CLK 25000000
+@@ -46,6 +48,14 @@ static bool spidev1 = false;
+ module_param(spidev1, bool, S_IRUGO);
+ MODULE_PARM_DESC(spidev1, "register a spidev device on SPI bus 2-1");
+ 
++/* Default SPI bus 2-1 chip select on HAT pin 26 */
++#define SPI_CS1_DEFAULT_GPIO (7)
++
++static int spi_cs1_gpio = SPI_CS1_DEFAULT_GPIO;
++module_param(spi_cs1_gpio, int, S_IRUGO);
++MODULE_PARM_DESC(spi_cs1_gpio,
++		"Gpio for SPI bus 2-1 chip select (0 to 27), or -1 to disable");
++
+ /* On the UP board, if the ODEn bit is set on the pad configuration
+  * it seems to impair some functions on the I/O header such as UART, SPI
+  * and even I2C.  So we disable it for all header pins by default.
+@@ -101,6 +111,19 @@ static struct spi_board_info up_spidev_info __initdata = {
+ 	.max_speed_hz   = UP_BOARD_SPIDEV_MAX_CLK,
+ };
+ 
++/* On UP Board there is no native chip select 1 available on SPI Bus 2. This
++ * table will be used to reserve a gpio for chip select 1 using the default
++ * gpio on HAT Pin 26 or the gpio number passed to this module's spi_cs1_gpio
++ * parameter. -1 will disable the reservation of a gpio for chip select.
++ */
++static struct gpiod_lookup_table up_spi_cs_gpiod_table = {
++	.dev_id		= "8086228E:01",
++	.table		= {
++		GPIO_LOOKUP_IDX("up-pinctrl",
++				SPI_CS1_DEFAULT_GPIO, "cs", 1, GPIO_ACTIVE_HIGH),
++	},
++};
++
+ static int __init
+ up_board_init_devices(void)
+ {
+@@ -170,6 +193,11 @@ up_board_init(void) {
+ 
+ 	board_info = system_id->driver_data;
+ 
++	if (gpio_is_valid(spi_cs1_gpio)) {
++		up_spi_cs_gpiod_table.table[0].chip_hwnum = spi_cs1_gpio;
++		gpiod_add_lookup_table(&up_spi_cs_gpiod_table);
++	}
++
+ 	/* Register pin control mappings specific to board version */
+ 	if (board_info->pinmux_maps) {
+ 		ret = pinctrl_register_mappings(board_info->pinmux_maps,
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0026-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch b/recipes-kernel/linux/files/0026-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch
deleted file mode 100644
index 9761b19..0000000
--- a/recipes-kernel/linux/files/0026-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch
+++ /dev/null
@@ -1,122 +0,0 @@
-From e77179bdcab5c0b10523ab6cc65a799eba0a8d8d Mon Sep 17 00:00:00 2001
-From: Dan O'Donovan <dan@emutex.com>
-Date: Thu, 15 Nov 2018 21:33:12 +0000
-Subject: [PATCH] up: pinctrl: change SoC gpio references to use h/w pin
- offsets
-
-Commit 03c4749dd6c7 "gpio / ACPI: Drop unnecessary ACPI GPIO to
- Linux GPIO translation" changed how the GPIO pins were numbered
-by the CherryView pinctrl/gpio driver.  Consequently, the numeric
-references to those GPIO pins need also to be updated in this driver
-to match.  The numbering scheme is now based directly on the h/w
-pin offsets within the controller (which are non-contiguous) instead
-of the contiguous numbering that was previously used.
-
-Signed-off-by: Dan O'Donovan <dan@emutex.com>
----
- drivers/platform/x86/up_board_pinctrl.c | 70 ++++++++++++++++-----------------
- 1 file changed, 35 insertions(+), 35 deletions(-)
-
-diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
-index bcc23ea..c318046 100644
---- a/drivers/platform/x86/up_board_pinctrl.c
-+++ b/drivers/platform/x86/up_board_pinctrl.c
-@@ -180,7 +180,7 @@ static struct up_soc_gpiochip_info chip_cht_SE = { .name = "INT33FF:03" };
- #define GPIO_PINRANGE(start, end)		\
- 	{					\
- 		.base = (start),		\
--		.npins = (end) - (start) $ 1,	\
-+		.npins = (end) - (start) + 1,	\
- 	}
- 
- #define N_GPIO 28
-@@ -199,34 +199,34 @@ static struct up_soc_gpiochip_info chip_cht_SE = { .name = "INT33FF:03" };
-  */
- /* UP Board uses a CPLD to provide I/O signal buffers and mux switching */
- static struct up_pin_info up_pins[N_GPIO] = {
--	GPIO_PIN_UP(&chip_cht_SW, 33,  9, FDIR_OUT, 28, 0, 1),	/*  0 */
--	GPIO_PIN_UP(&chip_cht_SW, 37, 23, FDIR_OUT, 28, 0, 1),	/*  1 */
--	GPIO_PIN_UP(&chip_cht_SW, 32,  0, FDIR_OUT, 29, 0, 1),	/*  2 */
--	GPIO_PIN_UP(&chip_cht_SW, 35,  1, FDIR_OUT, 29, 0, 1),	/*  3 */
--	GPIO_PIN_UP(&chip_cht_E,  18,  2, FDIR_IN,  30, 0, 1),	/*  4 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  21, 10, FDIR_NONE),		/*  5 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  12, 11, FDIR_NONE),		/*  6 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 48, 22, FDIR_NONE),		/*  7 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  7, 21, FDIR_OUT),		/*  8 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  3,  7, FDIR_IN),		/*  9 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  6,  6, FDIR_OUT),		/* 10 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  4,  8, FDIR_OUT),		/* 11 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  5, 24, FDIR_OUT),		/* 12 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  1, 12, FDIR_OUT),		/* 13 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 13, 15, FDIR_OUT),		/* 14 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  9, 16, FDIR_IN),		/* 15 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 11, 25, FDIR_IN),		/* 16 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW,  8,  3, FDIR_OUT),		/* 17 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 50, 17, FDIR_OUT),		/* 18 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 54, 13, FDIR_OUT),		/* 19 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 52, 26, FDIR_IN),		/* 20 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 55, 27, FDIR_OUT),		/* 21 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 12,  5, FDIR_OUT),		/* 22 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 15, 18, FDIR_OUT),		/* 23 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 18, 19, FDIR_OUT),		/* 24 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 11, 20, FDIR_OUT),		/* 25 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 14, 14, FDIR_OUT),		/* 26 */
--	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  8,  4, FDIR_OUT),		/* 27 */
-+	GPIO_PIN_UP(&chip_cht_SW, 61,  9, FDIR_OUT, 28, 0, 1),	/*  0 */
-+	GPIO_PIN_UP(&chip_cht_SW, 65, 23, FDIR_OUT, 28, 0, 1),	/*  1 */
-+	GPIO_PIN_UP(&chip_cht_SW, 60,  0, FDIR_OUT, 29, 0, 1),	/*  2 */
-+	GPIO_PIN_UP(&chip_cht_SW, 63,  1, FDIR_OUT, 29, 0, 1),	/*  3 */
-+	GPIO_PIN_UP(&chip_cht_E,  21,  2, FDIR_IN,  30, 0, 1),	/*  4 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  24, 10, FDIR_NONE),	/*  5 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_E,  15, 11, FDIR_NONE),	/*  6 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 79, 22, FDIR_NONE),	/*  7 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  7, 21, FDIR_OUT),	/*  8 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  3,  7, FDIR_IN),	/*  9 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  6,  6, FDIR_OUT),	/* 10 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  4,  8, FDIR_OUT),	/* 11 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  5, 24, FDIR_OUT),	/* 12 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE,  1, 12, FDIR_OUT),	/* 13 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 20, 15, FDIR_OUT),	/* 14 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 16, 16, FDIR_IN),	/* 15 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 18, 25, FDIR_IN),	/* 16 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 15,  3, FDIR_OUT),	/* 17 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 92, 17, FDIR_OUT),	/* 18 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 96, 13, FDIR_OUT),	/* 19 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 94, 26, FDIR_IN),	/* 20 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SW, 97, 27, FDIR_OUT),	/* 21 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 19,  5, FDIR_OUT),	/* 22 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 22, 18, FDIR_OUT),	/* 23 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 25, 19, FDIR_OUT),	/* 24 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 18, 20, FDIR_OUT),	/* 25 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 21, 14, FDIR_OUT),	/* 26 */
-+	GPIO_PIN_UP_NO_MUX(&chip_cht_SE, 15,  4, FDIR_OUT),	/* 27 */
- };
- 
- static struct up_cpld_led_info up_cpld_leds[] = {
-@@ -236,11 +236,11 @@ static struct up_cpld_led_info up_cpld_leds[] = {
- };
- 
- static struct up_cpld_info up_cpld = {
--	.strobe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_N, 21),
--	.reset_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 15),
--	.data_in_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 13),
--	.data_out_gpio		= SOC_GPIO_INPUT(&chip_cht_E, 23),
--	.oe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_SW, 43),
-+	.strobe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_N, 27),
-+	.reset_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 18),
-+	.data_in_gpio		= SOC_GPIO_OUTPUT(&chip_cht_E, 16),
-+	.data_out_gpio		= SOC_GPIO_INPUT(&chip_cht_E, 26),
-+	.oe_gpio		= SOC_GPIO_OUTPUT(&chip_cht_SW, 78),
- 	.dir_reg		= CPLD_DIR_REG_INIT,
- 	.do_verify		= true,
- 	.do_strobe_after_write	= false,
-@@ -986,4 +986,4 @@ module_exit(up_pinctrl_exit);
- MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
- MODULE_DESCRIPTION("Pin Control driver for UP Board I/O pin header");
- MODULE_LICENSE("GPL v2");
--MODULE_ALIAS("platform:up-pinctrl");
-\ No newline at end of file
-+MODULE_ALIAS("platform:up-pinctrl");
--- 
-2.7.4
-
diff --git a/recipes-kernel/linux/files/0027-up-pinctrl-fix-null-pointer-issue.patch b/recipes-kernel/linux/files/0027-up-pinctrl-fix-null-pointer-issue.patch
new file mode 100755
index 0000000..05f6cbb
--- /dev/null
+++ b/recipes-kernel/linux/files/0027-up-pinctrl-fix-null-pointer-issue.patch
@@ -0,0 +1,57 @@
+From 5452ee154fdad9920b799016e4b511b3394816d5 Mon Sep 17 00:00:00 2001
+From: frank2_hsieh <frank2_hsieh@asus.com>
+Date: Thu, 12 Mar 2020 09:51:00 +0800
+Subject: [PATCH 27/30] up: pinctrl: fix null pointer issue
+
+---
+ drivers/platform/x86/up_board_pinctrl.c | 27 ++++++++++++++++++++++++-
+ 1 file changed, 26 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/platform/x86/up_board_pinctrl.c b/drivers/platform/x86/up_board_pinctrl.c
+index c31804602dad..f4c5d5939fd2 100644
+--- a/drivers/platform/x86/up_board_pinctrl.c
++++ b/drivers/platform/x86/up_board_pinctrl.c
+@@ -567,6 +567,31 @@ static void up_gpio_irq_shutdown(struct irq_data *data)
+ 	free_irq(pin->soc_gpio.irq, pin);
+ }
+ 
++static int up_irq_chip_set_type_parent(struct irq_data *data, unsigned int type)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
++	struct up_pctrl *up_pctrl = gc_to_up_pctrl(gc);
++	unsigned offset = irqd_to_hwirq(data);
++	struct up_pin_info *pin = &up_pctrl->board->pins[offset];
++
++	printk("%s: type:%d, gc->label:%s, offset:%d\n",__func__, type, gc->label, offset);
++	pin->irq = irq_find_mapping(up_pctrl->chip.irq.domain, offset);
++	pin->soc_gpio.irq = gpiod_to_irq(pin->soc_gpio.desc);
++	printk("%s: pin->irq:%d, pin->soc_gpio.irq:%d\n",__func__, pin->irq, pin->soc_gpio.irq);
++
++	data = irq_get_irq_data(pin->irq);
++	data->parent_data = irq_get_irq_data(pin->soc_gpio.irq);
++
++
++	if(data->parent_data) {
++		printk("%s: no NULL\n",__func__);
++		return irq_chip_set_type_parent(data, type);
++	} else {
++		printk("%s: NULL\n",__func__);
++		return 0;
++	}
++}
++
+ static struct irq_chip up_gpio_irqchip = {
+ 	.name = "up-gpio",
+ 	.irq_startup = up_gpio_irq_startup,
+@@ -576,7 +601,7 @@ static struct irq_chip up_gpio_irqchip = {
+ 	.irq_mask = irq_chip_mask_parent,
+ 	.irq_unmask = irq_chip_unmask_parent,
+ 	.irq_ack = irq_chip_ack_parent,
+-	.irq_set_type = irq_chip_set_type_parent,
++	.irq_set_type = up_irq_chip_set_type_parent,
+ };
+ 
+ static int up_gpio_dir_in(struct gpio_chip *gc, unsigned offset)
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0028-pinctrl-core-no-need-to-check-mux-usage-on-upboard.patch b/recipes-kernel/linux/files/0028-pinctrl-core-no-need-to-check-mux-usage-on-upboard.patch
new file mode 100755
index 0000000..935e983
--- /dev/null
+++ b/recipes-kernel/linux/files/0028-pinctrl-core-no-need-to-check-mux-usage-on-upboard.patch
@@ -0,0 +1,70 @@
+From 78530c0f42e47173b4a75a4895182e1ae9712f56 Mon Sep 17 00:00:00 2001
+From: frank2_hsieh <frank2_hsieh@asus.com>
+Date: Tue, 8 Sep 2020 18:24:48 +0800
+Subject: [PATCH 28/30] pinctrl-core: no need to check mux usage on upboard
+
+the following patch added the function to check pin mux usage.
+UP board only configuration pin mux on BIOS so it skip the function.
+
+pinctrl/gpio: Take MUX usage into account
+---
+ drivers/gpio/gpiolib.c |  3 +--
+ drivers/pinctrl/core.c | 28 ----------------------------
+ 2 files changed, 1 insertion(+), 30 deletions(-)
+
+diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
+index 9003642a42af..341d4df80583 100644
+--- a/drivers/gpio/gpiolib.c
++++ b/drivers/gpio/gpiolib.c
+@@ -1101,8 +1101,7 @@ static long gpio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ 		    test_bit(FLAG_IS_HOGGED, &desc->flags) ||
+ 		    test_bit(FLAG_USED_AS_IRQ, &desc->flags) ||
+ 		    test_bit(FLAG_EXPORT, &desc->flags) ||
+-		    test_bit(FLAG_SYSFS, &desc->flags) ||
+-		    !pinctrl_gpio_can_use_line(chip->base + lineinfo.line_offset))
++		    test_bit(FLAG_SYSFS, &desc->flags))
+ 			lineinfo.flags |= GPIOLINE_FLAG_KERNEL;
+ 		if (test_bit(FLAG_IS_OUT, &desc->flags))
+ 			lineinfo.flags |= GPIOLINE_FLAG_IS_OUT;
+diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
+index 3b1f376c80ec..b481493b2a2f 100755
+--- a/drivers/pinctrl/core.c
++++ b/drivers/pinctrl/core.c
+@@ -786,34 +786,6 @@ int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
+ 	return -EINVAL;
+ }
+ 
+-bool pinctrl_gpio_can_use_line(unsigned gpio)
+-{
+-	struct pinctrl_dev *pctldev;
+-	struct pinctrl_gpio_range *range;
+-	bool result;
+-	int pin;
+-
+-	/*
+-	 * Try to obtain GPIO range, if it fails
+-	 * we're probably dealing with GPIO driver
+-	 * without a backing pin controller - bail out.
+-	 */
+-	if (pinctrl_get_device_gpio_range(gpio, &pctldev, &range))
+-		return true;
+-
+-	mutex_lock(&pctldev->mutex);
+-
+-	/* Convert to the pin controllers number space */
+-	pin = gpio_to_pin(range, gpio);
+-
+-	result = pinmux_can_be_used_for_gpio(pctldev, pin);
+-
+-	mutex_unlock(&pctldev->mutex);
+-
+-	return result;
+-}
+-EXPORT_SYMBOL_GPL(pinctrl_gpio_can_use_line);
+-
+ /**
+  * pinctrl_gpio_request() - request a single pin to be used as GPIO
+  * @gpio: the GPIO pin number from the GPIO subsystem number space
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0029-upboard-fpga-support-upn-apl01-project.patch b/recipes-kernel/linux/files/0029-upboard-fpga-support-upn-apl01-project.patch
new file mode 100755
index 0000000..10159b3
--- /dev/null
+++ b/recipes-kernel/linux/files/0029-upboard-fpga-support-upn-apl01-project.patch
@@ -0,0 +1,33 @@
+From 66d308019830e3e4ab3073cf7e752d6a9c7d3cc2 Mon Sep 17 00:00:00 2001
+From: frank2_hsieh <frank2_hsieh@asus.com>
+Date: Mon, 24 Aug 2020 12:15:42 +0800
+Subject: [PATCH 29/30] upboard-fpga: support upn-apl01 project
+
+Product Name is UPN-APL01
+Board Version is V1.0
+---
+ drivers/mfd/upboard-fpga.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/drivers/mfd/upboard-fpga.c b/drivers/mfd/upboard-fpga.c
+index 532b58f0aed4..c7b36e839173 100644
+--- a/drivers/mfd/upboard-fpga.c
++++ b/drivers/mfd/upboard-fpga.c
+@@ -334,6 +334,14 @@ static const struct dmi_system_id upboard_dmi_table[] __initconst = {
+ 		.driver_data = (void *)(UPFPGA_QUIRK_UNINITIALISED |
+ 			UPFPGA_QUIRK_HRV1_IS_PROTO2),
+ 	},
++	{
++		.matches = { /* UP2 Pro*/
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "UPN-APL01"),
++			DMI_EXACT_MATCH(DMI_BOARD_VERSION, "V1.0"),
++		},
++		.driver_data = (void *)UPFPGA_QUIRK_HRV1_IS_PROTO2,
++	},
+ 	{
+ 		.matches = { /* UP2 */
+ 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AAEON"),
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/0030-upboard-fix-NULL-pointer-after-modifying-up_spi_cs_g.patch b/recipes-kernel/linux/files/0030-upboard-fix-NULL-pointer-after-modifying-up_spi_cs_g.patch
new file mode 100755
index 0000000..afcae72
--- /dev/null
+++ b/recipes-kernel/linux/files/0030-upboard-fix-NULL-pointer-after-modifying-up_spi_cs_g.patch
@@ -0,0 +1,29 @@
+From 3c62cf5c017dd2dfcb2f63f4ac54ce3bf80cbe27 Mon Sep 17 00:00:00 2001
+From: frank2_hsieh <frank2_hsieh@asus.com>
+Date: Mon, 12 Oct 2020 21:24:34 +0800
+Subject: [PATCH 30/30] upboard: fix NULL pointer after modifying
+ up_spi_cs_gpiod_table
+
+spi-pxa2xx-platform driver happens NULL pointer issue when searching
+cs from gpiod_lookup_table.
+GPIO lookup tables are supposed to be zero terminated. Let's do that
+and avoid accidentally walking off the end.
+---
+ drivers/platform/x86/up_board.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/platform/x86/up_board.c b/drivers/platform/x86/up_board.c
+index a83ca94ad924..b3b395124efb 100644
+--- a/drivers/platform/x86/up_board.c
++++ b/drivers/platform/x86/up_board.c
+@@ -121,6 +121,7 @@ static struct gpiod_lookup_table up_spi_cs_gpiod_table = {
+ 	.table		= {
+ 		GPIO_LOOKUP_IDX("up-pinctrl",
+ 				SPI_CS1_DEFAULT_GPIO, "cs", 1, GPIO_ACTIVE_HIGH),
++	{}
+ 	},
+ };
+ 
+-- 
+2.17.1
+
diff --git a/recipes-kernel/linux/files/up-board-user-config.cfg b/recipes-kernel/linux/files/up-board-user-config.cfg
old mode 100644
new mode 100755
index 530e656..2c8008d
--- a/recipes-kernel/linux/files/up-board-user-config.cfg
+++ b/recipes-kernel/linux/files/up-board-user-config.cfg
@@ -11,7 +11,6 @@ CONFIG_DW_DMAC_CORE=y
 CONFIG_DW_DMAC=y
 CONFIG_TI_ADC081C=m
 
-CONFIG_ISDN_AUDIO=y
 CONFIG_MFD_TWL4030_AUDIO=y
 CONFIG_VIDEO_TVAUDIO=m
 CONFIG_SND_USB_AUDIO=m
diff --git a/recipes-kernel/linux/files/up-board.cfg b/recipes-kernel/linux/files/up-board.cfg
old mode 100644
new mode 100755
index 7ddfa3e..4b72f5a
--- a/recipes-kernel/linux/files/up-board.cfg
+++ b/recipes-kernel/linux/files/up-board.cfg
@@ -131,7 +131,6 @@ CONFIG_VETH=y
 CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
 CONFIG_NETFILTER_XT_MATCH_IPVS=m
 CONFIG_BLK_DEV_THROTTLING=y
-CONFIG_CFQ_GROUP_IOSCHED=y
 CONFIG_CGROUP_HUGETLB=y
 CONFIG_CFS_BANDWIDTH=y
 CONFIG_IP_VS=m
diff --git a/recipes-kernel/linux/linux-intel_4.19.bbappend b/recipes-kernel/linux/linux-intel_4.19.bbappend
deleted file mode 100644
index 414b020..0000000
--- a/recipes-kernel/linux/linux-intel_4.19.bbappend
+++ /dev/null
@@ -1,39 +0,0 @@
-FILESEXTRAPATHS_prepend := "${THISDIR}/files:"
-
-PR := "${PR}.1"
-
-SRC_URI += " \
-	file://up-board.cfg \
-	file://up-board-user-config.cfg \
-	file://0000-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch \
-	file://0001-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch \
-	file://0002-iio-adc128s052-allow-driver-to-be-matched-using-ACPI.patch \
-	file://0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch \
-	file://0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch \
-	file://0005-iio-adc128s052-allow-device-to-be-matched-using-acpi.patch \
-	file://0006-mfd-Add-support-for-UP-board-CPLD-FPGA.patch \
-	file://0007-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch \
-	file://0008-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch \
-	file://0009-upboard-added-support-for-UP-core-CREX-HAT.patch \
-	file://0010-upboard-Add-support-for-UP-CRST02.patch \
-	file://0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch \
-	file://0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch \
-	file://0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch \
-	file://0014-i2c-i2c-designware-platdrv-Cleanup-setting-of-the-ad.patch \
-	file://0015-i2c-i2c-designware-platdrv-Always-use-a-dynamic-adap.patch \
-	file://0016-upxtreme-Add-support-for-UP-Xtreme.patch \
-	file://0017-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch \
-	file://0018-pinctrl-core-translate-gpio-to-pin-before-config.patch \
-	file://0019-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch \
-	file://0020-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch \
-	file://0021-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch \
-	file://0022-i2c-designware-platdrv-Add-module-parameter-to-overr.patch \
-	file://0023-i2c-designware-platdrv-Use-ACPI-method-FREQ-to-get-i.patch \
-	file://0024-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch \
-	file://0025-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch \
-	file://0026-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch \
-"
-# replace these SRCREVs with the real commit ids once you've had
-# the appropriate changes committed to the upstream linux-yocto repo
-# SRCREV_machine_pn-linux-yocto_up-board ?= "${AUTOREV}"
-# SRCREV_meta_pn-linux-yocto_up-board ?= "${AUTOREV}"
diff --git a/recipes-kernel/linux/linux-intel_5.4.bbappend b/recipes-kernel/linux/linux-intel_5.4.bbappend
new file mode 100755
index 0000000..f9e97e4
--- /dev/null
+++ b/recipes-kernel/linux/linux-intel_5.4.bbappend
@@ -0,0 +1,43 @@
+FILESEXTRAPATHS_prepend := "${THISDIR}/files:"
+
+PR := "${PR}.1"
+
+SRC_URI += " \
+       file://up-board.cfg \
+       file://up-board-user-config.cfg \
+       file://0001-ACPI-Add-support-to-map-GPIO-resources-to-ranges.patch \
+       file://0002-disable-RTS-override-on-LPSS-UART-with-Auto-Flow-Con.patch \
+       file://0003-pinctrl-allow-multiple-pin-controllers-for-a-GPIO.patch \
+       file://0004-regmap-Expose-regmap_writable-function-to-check-if-a.patch \
+       file://0005-mfd-Add-support-for-UP-board-CPLD-FPGA.patch \
+       file://0006-up-pinctrl-Bring-in-legacy-fpga-and-pinctrl-driver.patch \
+       file://0007-acpi-acpi_node_add_pin_mapping-added-to-header-file.patch \
+       file://0008-platform-x86-upboard-fix-gpio-pinctrl-API-references.patch \
+       file://0009-upboard-added-support-for-UP-core-CREX-HAT.patch \
+       file://0010-upboard-Add-support-for-UP-CRST02.patch \
+       file://0011-pinctrl-upboard-add-regmap-patches-for-CREX-and-CRST.patch \
+       file://0012-pinctrl-upboard-add-separate-regmap-patches-for-CREX.patch \
+       file://0013-correct-the-number-of-GPIOs-for-CREX-and-CRST02-boar.patch \
+       file://0014-upboard-fpga-Enable-fpga-on-UP3-platform.patch \
+       file://0015-pinctrl-upboard-Dont-initialise-UART1-RTS-as-input.patch \
+       file://0016-pinctrl-core-translate-gpio-to-pin-before-set-config.patch \
+       file://0017-serial-8250_dw-add-quirk-to-disable-DMA-on-Cherry-Tr.patch \
+       file://0018-up-fpga-dmi-Update-DMI-match-date-string.patch \
+       file://0019-pinctrl-fpga-up-Update-DMI-data-match.patch \
+       file://0020-ASoC-Intel-new-Baytrail-Cherrytrail-PCM512x-machine-.patch \
+       file://0021-ASoC-Intel-bytcht_pcm512x-use-modern-dai_link-style.patch \
+       file://0022-pinctrl-core-translate-gpio-to-pin-before-config.patch \
+       file://0023-upboard-pinctrl-drop-regmap-patches-for-UP-Xtreme.patch \
+       file://0024-up-pinctrl-change-SoC-gpio-references-to-use-h-w-pin.patch \
+       file://0025-spi-pxa2xx-Set-dir-and-value-when-requesting-cs-gpio.patch \
+       file://0026-platform-x86-upboard-Add-gpio-chip-select-for-UP-Boa.patch \
+       file://0027-up-pinctrl-fix-null-pointer-issue.patch \
+       file://0028-pinctrl-core-no-need-to-check-mux-usage-on-upboard.patch \
+       file://0029-upboard-fpga-support-upn-apl01-project.patch \
+       file://0030-upboard-fix-NULL-pointer-after-modifying-up_spi_cs_g.patch \
+"
+# replace these SRCREVs with the real commit ids once you've had
+# the appropriate changes committed to the upstream linux-yocto repo
+# SRCREV_machine_pn-linux-yocto_up-board ?= "${AUTOREV}"
+# SRCREV_meta_pn-linux-yocto_up-board ?= "${AUTOREV}"
+
-- 
2.7.4

